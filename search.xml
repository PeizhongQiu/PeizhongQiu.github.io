<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>A*</title>
    <url>/p/7300a56d.html</url>
    <content><![CDATA[]]></content>
      <tags>
        <tag>资源调度</tag>
      </tags>
  </entry>
  <entry>
    <title>Dash: Scalable Hashing on Persistent Memory</title>
    <url>/p/6ab0c77.html</url>
    <content><![CDATA[<h2 id="dash-bucket结构"><a href="#dash-bucket结构" class="headerlink" title="dash bucket结构"></a>dash bucket结构</h2><p>Dash的总体结构如图1所示。从图中可以看出，该结构和CCEH同样采取了可拓展的哈希结构，并且同样有三个层次，一个是Directory层，一个是Segment层，一个是Bucket层。不同的是，每个Segment层除了正常的Bucket外，还有Stash buckets用来存储冲突的键值对。根据论文，一个Segment层的Stash buckets数量为2或4。另外，在Directory层有三个主要变量，Lock是锁，Version用来做版本控制，Clean用来判断系统的关闭是否是干净的。</p>
<span id="more"></span>

<img src="/p/6ab0c77/dash_architecture.PNG" class title="图1 Dash总体结构">

<p>图2是bucket层的具体结构。从图中可知，一个bucket就只存储14个键值对，一个键值对16个字节。另外，每个bucket有32字节的元数据，其中包括4字节的版本锁，根据代码可知，最高位是互斥锁，后面31位作为版本号进行版本控制；接着的counter是用来计算bucket中有多少个键值对；membership是一个位图，用来显示那些不是直接索引到该bucket中的键值对；Alloc.bitmap也是一个位图，用来显示该bucket中的全部键值对；接下来是18个fingeprint，每个fingerprint是1字节，所谓的fingerprint是哈希值的后8位，通过fingerprint可以大量减少NVM读的次数，有一点值得注意，一个bucket只有14个键值对，但是却有18个fingerprint，这是stash bucket中在本bucket溢出的键值对的fingerprint；overflow fingerprint bitmap是4位，判断溢出的对应的fingerprint是否被占用；overflow bit用来判断这个bucket是否有溢出的键值对，stash bucket index用来判断fingerprint对应的键值对在哪个bucket；overflow membership用来判断溢出的键值对是否直接索引到该bucket ；overflow count表示直接对应该bucket的键值对却无法插入到该bucket和下一个bucket的键值对数量，注意overcount不包括那些在bucket或下一个bucket有存储fingerprint的键值对。</p>
<img src="/p/6ab0c77/dash_bucket.PNG" class title="图2 bucket结构">

<h2 id="dash实现细节"><a href="#dash实现细节" class="headerlink" title="dash实现细节"></a>dash实现细节</h2><p>每个Segment有64个bucket，因此可以根据6位来确定bucket的位置。哈希值最后8位是作为fingerprint，最后9到14位来确定bucket位置。</p>
<h3 id="dash-insert"><a href="#dash-insert" class="headerlink" title="dash insert"></a>dash insert</h3><p>最上层的伪代码如图3所示。首先，是判断键值是否已经存在，如果存在，则直接返回。其次，如果target_bucket和probing_bucket都未满，为了让两者负载均衡，会插入到两者数量较少的一边；如果两者都满了，则会判断target和probing target中是否有可以移动的键值对，即在target中属于前一个bucket的键值对，且前一个bucket有空余的位置，则将其中一个插入到前一个bucket，或者probe target中属于probe target的键值对，且后一个bucket有空余的位置，则将其中一个插入到前一个bucket。最后，如果没有空闲的位置，则插入到stash中，并设置target的overflow为1，如果stash中也没有空余的位置，则分裂。接下来，对其中的有些细节进行补充。</p>
<img src="/p/6ab0c77/insert_top.PNG" class title="图3 dash insert伪代码">

<h3 id="key-exists"><a href="#key-exists" class="headerlink" title="key exists"></a>key exists</h3><p>根据源代码，首先是在target_bucket和probing_bucket中寻找是否存在相同的键值，这个部分可以利用fingerprint大量减少读的次数，并且，fingerprint可以使用SSE加速，另外，在源代码中，对14位每位进行判断的时候，使用了循环展开的方法降低开销；之后，判断是否需要去stash中查找，判断是否要在stash中查找要依次查看overflow bit是否为0，overcount是否为0，overflowBit与overflow fingerprint与overflow membership的关系，不满足则要对stash进行搜索。</p>
<h3 id="bucket-insert"><a href="#bucket-insert" class="headerlink" title="bucket insert"></a>bucket insert</h3><p>首先找到空闲的键值对，这可以利用bitmap进行位运算得到。接着插入，并设置标志位。由于clflush一次刷新一个cacheline，一个cacheline为64字节，所以所有的元数据都可以在一次刷新中刷入。</p>
<h3 id="split"><a href="#split" class="headerlink" title="split"></a>split</h3><p>Split过程基本与CCEH相似。重点说明几点不同之处：第一，分裂的时候，dash要将所有bucket的锁都上锁，第二，dash在分裂时候的正确性由libpmemobj的事务保障，这保证分裂出去的Segment在程序崩溃之后能够回收成功。</p>
<h3 id="search"><a href="#search" class="headerlink" title="search"></a>search</h3><p>search伪代码如图4所示。从伪代码中，可以看出，在搜索的过程中并没有使用锁。dash采用乐观锁的方式大大提高并行环境下的搜索效率。在搜索之前，判断bucket是否上锁；在搜索完成后，dash通过检查bucket的版本是否与之前读取的一致来判断search的过程中是否有进程对bucket进行修改，如果有，则会重新读取。另外，由于fingerprint的存在，大大减少了读的次数。</p>
<img src="/p/6ab0c77/dash_search.PNG" class title="图4 dash search伪代码">

<h2 id="dash-与-cceh评测"><a href="#dash-与-cceh评测" class="headerlink" title="dash 与 cceh评测"></a>dash 与 cceh评测</h2><h3 id="cceh改写"><a href="#cceh改写" class="headerlink" title="cceh改写"></a>cceh改写</h3><p>dash的作者对cceh进行了改写，首先在insert上，作者增加了判断新增的键值对是否存在的判断，由于cceh没有此方面的实现，所以作者相当于搜索了一次；另外，在split的过程中，作者将cceh的分裂用libpmemobj的事务进行处理。</p>
<h3 id="单线程比较"><a href="#单线程比较" class="headerlink" title="单线程比较"></a>单线程比较</h3><p>对于key大小大于8字节的键值对来说，由于每次读取键值都需要先读指针，再读key，这就体现了fingerprint的优越性，fingerprint大大减少了读的次数。</p>
<img src="/p/6ab0c77/re1.PNG" class title="图5 单线程">

<h3 id="多线程比较"><a href="#多线程比较" class="headerlink" title="多线程比较"></a>多线程比较</h3><img src="/p/6ab0c77/re2.PNG" class title="图6 多线程">

<h3 id="负载因子"><a href="#负载因子" class="headerlink" title="负载因子"></a>负载因子</h3><img src="/p/6ab0c77/re3.PNG" class title="图7 负载因子">

<h2 id="dash代码运行环境要求"><a href="#dash代码运行环境要求" class="headerlink" title="dash代码运行环境要求"></a>dash代码运行环境要求</h2><p>源代码地址 <a href="https://github.com/baotonglu/dash.git">https://github.com/baotonglu/dash.git</a><br>linux 内核版本4.17之后<br>glibc 版本2.29之后</p>
]]></content>
      <tags>
        <tag>NVM论文研读</tag>
      </tags>
  </entry>
  <entry>
    <title>User-Defined Cloud</title>
    <url>/p/aeabe00a.html</url>
    <content><![CDATA[<p>Yiying Zhang, Ardalan Amiri Sani, and Guoqing Harry Xu. 2021. User-Defined Cloud. In Workshop on Hot Topics in Operating Systems (HotOS ’21), May 31–June 2, 2021, Ann Arbor, MI, USA. ACM, New York, NY, USA, 8 pages. <a href="https://doi.org/10.1145/3458336.3465304">https://doi.org/10.1145/3458336.3465304</a></p>
<span id="more"></span>

<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>云使用者问题：</p>
<ul>
<li>多花费35%的前在不需要的计算资源上。因为没有云服务能够匹配他们精确的需求。</li>
<li>部分领域的使用者不能在云上跑他们的负载。</li>
<li>安全问题。</li>
</ul>
<p>云服务提供商问题：</p>
<ul>
<li>新硬件部署和安全功能增加</li>
<li>兼容问题</li>
</ul>
<p>原因就是云提供商定义和管理云去满足用户的需求。</p>
<p>主张用户定义云，云服务提供商创建和管理云。</p>
<p>User-Define Cloud(UDC)，用户可以定义硬件资源，执行环境，安全需要，系统功能。细粒度方式定义</p>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>用户：</p>
<ul>
<li>根据需要，自定义整个从软件到硬件的栈结构。</li>
<li>只需要支付他们需要的资源和功能</li>
<li>安全自定义</li>
</ul>
<p>提供商：</p>
<ul>
<li>独立的增加和删除软硬件功能。</li>
<li>更多的用户</li>
<li>更多的钱</li>
</ul>
<h2 id="UDC提议"><a href="#UDC提议" class="headerlink" title="UDC提议"></a>UDC提议</h2><p>三个原则：</p>
<ul>
<li>Expressing definitions of low-level layers as runtime aspects.  </li>
<li>Decouple specifications from their realization and decouple different aspects.</li>
<li>Fine granularity at each layer.</li>
</ul>
]]></content>
      <tags>
        <tag>云计算论文研读</tag>
      </tags>
  </entry>
  <entry>
    <title>linux 内核参考资料</title>
    <url>/p/f16f5a0d.html</url>
    <content><![CDATA[<h2 id="attribute"><a href="#attribute" class="headerlink" title="__attribute__"></a>__attribute__</h2><span id="more"></span>

<p><a href="https://gcc.gnu.org/onlinedocs/gcc-4.0.0/gcc/Function-Attributes.html#Function-Attributes">https://gcc.gnu.org/onlinedocs/gcc-4.0.0/gcc/Function-Attributes.html#Function-Attributes</a></p>
<p><a href="https://gcc.gnu.org/onlinedocs/gcc-4.0.0/gcc/Type-Attributes.html#Type-Attributes">https://gcc.gnu.org/onlinedocs/gcc-4.0.0/gcc/Type-Attributes.html#Type-Attributes</a></p>
<p><a href="https://gcc.gnu.org/onlinedocs/gcc-4.0.0/gcc/Variable-Attributes.html#Variable-Attributes">https://gcc.gnu.org/onlinedocs/gcc-4.0.0/gcc/Variable-Attributes.html#Variable-Attributes</a></p>
<h2 id="percpu"><a href="#percpu" class="headerlink" title="percpu"></a>percpu</h2><p><a href="https://zhuanlan.zhihu.com/p/260986194">https://zhuanlan.zhihu.com/p/260986194</a></p>
<h2 id="kvm-shared-msrs"><a href="#kvm-shared-msrs" class="headerlink" title="kvm_shared_msrs"></a>kvm_shared_msrs</h2><p><a href="https://oenhan.com/kvm_shared_msrs">https://oenhan.com/kvm_shared_msrs</a></p>
<h2 id="slab-内存分配"><a href="#slab-内存分配" class="headerlink" title="slab 内存分配"></a>slab 内存分配</h2><p><a href="https://zhuanlan.zhihu.com/p/105582468">https://zhuanlan.zhihu.com/p/105582468</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/106106008">https://zhuanlan.zhihu.com/p/106106008</a></p>
<h2 id="CPU-hotplug"><a href="#CPU-hotplug" class="headerlink" title="CPU hotplug"></a>CPU hotplug</h2><p><a href="https://www.kernel.org/doc/html/latest/core-api/cpu_hotplug.html">https://www.kernel.org/doc/html/latest/core-api/cpu_hotplug.html</a></p>
]]></content>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>cpuidle</title>
    <url>/p/e0428171.html</url>
    <content><![CDATA[<h2 id="逻辑-CPU"><a href="#逻辑-CPU" class="headerlink" title="逻辑 CPU"></a>逻辑 CPU</h2><span id="more"></span> 

<p>​        在 CPU 任务调度器看来 CPU 空闲时间管理是直接作用在 CPU 上的。在它看来，CPU 是一个逻辑单元。也就是说，CPU 不必是单独的物理实体，而可能只是一个对软件表现为单独的单核处理器的接口。 换句话说，CPU 是一个实体，它表现为正在从内存中获取属于一个程序的指令并执行它们，但它在物理上不需要以这种方式工作。 一般来说，这里可以考虑三种不同的情况。</p>
<ul>
<li><p>如果整个处理器一次只能执行一个指令序列，那么整个处理器就是一个 CPU。 在这种情况下，如果要求硬件进入空闲状态，整个处理器都将进入空闲状态。</p>
</li>
<li><p>如果处理器是多核的，每个核一次至少能够执行一个程序。核之间不需要完全相互独立（例如，它们可能共享缓存），但大多数时候它们仍然在物理上彼此并行工作，因此如果每一个核只执行一个程序，那么这些程序大部分彼此独立运行。在这种情况下，每个核都是一个 CPU，如果要求硬件进入空闲状态，首先请求它的核将进入空闲状态，但更大的单元也可能进入空闲状态，即，如果较大单元中除一个之外的所有核都已在“核级别”处于空闲状态，当这个核要求处理器进入空闲状态，则可能会将整个较大单元置于空闲状态，这也会影响该单元中的其他核。</p>
</li>
<li><p>如果多核处理器中的每个核能够在同一时间范围内执行多个程序（也就是说，每个核可能能够从内存中的多个位置获取指令并在同一时间范围内执行它们）。在这种情况下，核以“捆绑”的形式呈现给软件，每个“捆绑”由多个单独的单核处理器组成，称为硬件线程（或英特尔硬件上的超线程），每个都可以遵循一个指令序列。然后，从 CPU 空闲时间管理的角度来看，硬件线程是 CPU，如果其中一个请求处理器进入空闲状态，则请求它的硬件线程（或 CPU）将停止，但不会再发生任何事情，除非同一核中的所有其他硬件线程也要求处理器进入空闲状态。在这种情况下，核可能会单独进入空闲状态，或者包含它的较大单元可能会整体进入空闲状态（如果较大单元中的其他核已经处于空闲状态）。</p>
</li>
</ul>
<h2 id="空闲-CPU"><a href="#空闲-CPU" class="headerlink" title="空闲 CPU"></a>空闲 CPU</h2><p>​        当一个 CPU 没有可以运行的任务时，称这个 CPU 是空闲的。换个说法，linux 内核中定义了一系列内部调度类，如果除了空闲类之外，没有任何任务在给定的 CPU 上运行，则该 CPU 就是空闲的。如果硬件不能允许 CPU 上不运行任何指令，则 CPU 必须要运行一些无用的指令直到 CPU 真正被工作需要。但是这浪费电，所以大多数 CPU 支持一些低功耗状态，内核可以将它们置为这些状态，直到需要 CPU 做有用的工作。</p>
<p>​        空闲状态的进入和退出不是没有代价的。进入和退出都需要一些时间，而且，在进入空闲状态，功耗会短暂地略高于空闲状态前的状态的正常值，在退出空闲状态时，功耗也会短暂地略高于退出空闲时的目标状态的正常值。随着空闲状态的不断加深，CPU 消耗越来越少的功耗，但是进入和退出空闲状态的开销也会越来越大。这意味着对于较短的空闲时间，相当浅的空闲状态是系统资源的最佳利用； 对于更长的空闲时间，更深的空闲状态的成本将通过空闲时节省的功率来抵消。 因此，在决定空闲深度之前需要预测 CPU 空闲多长时间。 这是空闲循环的工作。</p>
<h2 id="空闲循环（idle-loop）"><a href="#空闲循环（idle-loop）" class="headerlink" title="空闲循环（idle loop）"></a>空闲循环（idle loop）</h2><p>​        空闲循环在它的每次迭代中都需要两个主要步骤。首先，它调用属于 CPU 空闲时间管理子系统 CPUIdle 的称为 governor 的代码模块，为 CPU 选择一个空闲状态以请求硬件进入。其次，它调用来自 CPUIdle 子系统的另一个代码模块 driver，以实际要求处理器硬件进入由 governor 选择的空闲状态。</p>
<p>​        governor 的作用是找到最适合当前条件的空闲状态。为此，逻辑 CPU 可以要求硬件进入的空闲状态以独立于平台或处理器架构的抽象方式表示，并以一维（线性）数组的形式组织。在内核初始化时，与内核运行平台相匹配的 CPUIdle driver 会准备和提供该数组。这允许 CPUIdle governor 独立于底层硬件并可以与 Linux 内核运行的任何平台一起工作。</p>
<p>​        该数组中的每个空闲状态有两个参数会成为 governor 考虑的对象：目标驻留（target residency）和（最坏情况）退出延迟（exit latency）。目标驻留时间是硬件必须在给定状态中花费的最短时间，包括进入它所需的时间（可能很长）。只有花费比目标驻留时间长，才能比通过进入较浅的空闲状态节省更多的能量。 [空闲状态的“深度”大致对应于处理器在该状态下消耗的功率。] 退出延迟是要求处理器硬件进入空闲状态的 CPU 从空闲状态被唤醒到开始执行第一条指令所需的最长时间。请注意，通常退出延迟还必须包含进入给定状态所需的时间。万一在硬件进入空闲状态时发生唤醒，必须完全进入空闲状态后才能退出。</p>
<p>​        有两种类型的信息可以影响 governor 的决定。首先，governor 知道距离最近的计时器事件的时间。那个时间是确切知道的，因为内核对计时器进行编程，并且它确切知道它们何时会触发，这是给定 CPU 所依赖的硬件可以处于空闲状态的最长时间，包括进入和退出它所需的时间。但是，CPU 可能随时被非定时器事件唤醒（特别是在最近的定时器触发之前），并且通常不知道何时会发生这种情况。governor只能看到 CPU 在被唤醒后实际空闲了多少时间（从现在开始，该时间将被称为空闲持续时间（idle duration）），并且它可以以某种方式使用该信息以及直到最近的计时器的时间估计未来的空闲时间。governor 如何使用该信息取决于它所实现的算法，这是在 CPUIdle 子系统中拥有多个 governor 的主要原因。</p>
<p>​        有四个可用的 CPUIdle governors：menu、TEO、ladder 和 haltpoll。默认情况下使用哪一个取决于内核的配置，特别是空闲循环是否可以停止调度程序 tick。可用的 governor 可以从 available_governors 中读取，并且governor 可以在运行时更改。内核当前使用的 CPUIdle governor的名称可以从 sysfs 中 /sys/devices/system/cpu/cpuidle/ 下的 current_governor_ro 或 current_governor 文件中读取。</p>
<p>​        另一方面，使用哪个 CPUIdle driver 通常取决于内核运行的平台，但有些平台有多个匹配的驱动程序。例如，有两个驱动程序可以与大多数英特尔平台一起使用，intel_idle 和 acpi_idle，一个具有硬编码的空闲状态信息，另一个能够分别从系统的 ACPI 表中读取该信息。尽管如此，即使在这些情况下，在系统初始化时选择的驱动程序也不能在以后替换，因此必须尽早决定使用其中的一个。内核当前使用的CPUIdle driver 的名称可以从sysfs中/sys/devices/system/cpu/cpuidle/下的current_driver文件中读取。</p>
<h2 id="空闲-CPU-和调度器-tick"><a href="#空闲-CPU-和调度器-tick" class="headerlink" title="空闲 CPU 和调度器 tick"></a>空闲 CPU 和调度器 tick</h2><p>​        CPU 调度程序的 tick 使这项工作变得特别困难。这是一个由 CPU 调度器运行的定时器，目的是分时 CPU：如果你要在单个 CPU 上运行多个任务，每个任务只能运行一段时间，然后定期搁置做另一份任务。tick 不需要在空闲的 CPU 上运行，因为没有应该共享 CPU 的任务。此外，如果允许 tick 在原本空闲的 CPU 上运行，它将通过限制 CPU 可能保持空闲的时间来禁止 governor 选择深度空闲状态。所以在内核 4.16 和更早版本中，调度程序在调用 governor 之前禁用 tick。当 CPU 被中断唤醒时，调度程序会决定是否有工作要做，如果有，则重新激活 tick。</p>
<p>​        如果 governor 预测到长时间空闲，并且空闲时间也的确是长，则 governor 获胜：CPU 将进入深度空闲状态并节省电量。但是，如果 governor 预测长时间闲置而空闲时间很短，那么 governor 会失败，因为进入深度空闲状态的成本不会通过短时间空闲状态的节电来弥补。更糟糕的是，如果 governor 预测空闲时间较短，无论实际空闲状态持续时间多长，它都会失败：如果空闲状态实际持续时间很长，则错过了潜在的节能效果；如果时间很短，则停止和重新启动 tick 的成本又被不必要地支付，即因为停止和启动 tick 是有代价的，如果 governor 预测短暂的空闲，停止 tick 是没有意义的。</p>
<p>​        Wysocki 考虑尝试重新设计 governor 来解决这个问题，但得出的结论是，基本问题是在调用 governor 之前停止 tick，即在获得预测的空闲状态之前就停止了 tick。因此，他为内核 4.17 重新设计了空闲循环：governor 预测空闲状态之后再做出停止 tick 的决定。如果预测长时间空闲，则停止 tick，以免过早唤醒 CPU。如果建议是短时间空闲，tick 则保持开启状态以避免关闭它的成本。这意味着 tick 是一个 safety net，如果空闲时间比预期的长，它会唤醒 CPU，并给 governor 另一个机会来让它正确。</p>
<p>​        当空闲的 CPU 被中断唤醒时，无论是从保持运行的 tick 还是其他事件，调度程序立即决定是否有工作要做。如果有，则在需要时重新启动滴答；但如果没有，则立即重新调用 governor。由于现在可以在 tick 运行和停止时调用 governor，因此必须重新设计调控器以考虑到这一点。</p>
<p>​        重新检查之前的赢/输表，Wysocki 预计这次返工会改善情况。如果预测到长时间空闲，tick 仍然停止，所以没有任何变化：如果实际空闲时间长，我们就赢了，如果实际空闲时间短，我们就输了。但是如果预测到短空闲，我们会更好：如果实际空闲很短，我们就节省了停止和重新启动 tick 的成本；如果实际空闲很长，未停止的计时器将唤醒 governor，并再次预测。</p>
<p>​        Wysocki 在许多系统上对此进行了测试。上图是所有测试系统的特征，显示了空闲系统上的功耗与时间的关系。绿线是旧的空闲循环，红线是新的：新方案下的功耗更低，而且比以前更可预测。并非所有测试的 CPU 都显示绿线和红线之间的差距如此之大，但所有 CPU 都在凹凸不平的绿线下方显示了一条平坦的红线。正如 Wysocki 所说，与旧方案相比，这种新方案预测短的空闲时间的频率更低，但它们预测为短空闲时间正确的概率更高。</p>
<p>​        内核可以配置为完全禁止在空闲循环中停止 tick。 这可以通过取消设置 CONFIG_NO_HZ_IDLE 配置选项或通过在命令行中传递 nohz=off 来完成。 在这两种情况下，由于 tick 的停止被禁用，空闲循环代码简单地忽略了governor 的决定，并且 tick 永远不会停止。</p>
<p>​        运行配置为允许在空闲 CPU 上停止 tick 的内核的系统称为 tickless 系统，它们通常被认为比运行无法停止 tick 的内核的系统更节能。 如果给定的系统是 tickless 的，它将默认使用 menu，如果它不是 tickless，则其上的默认 CPUIdle 调控器将是 ladder。</p>
<h2 id="menu-governor"><a href="#menu-governor" class="headerlink" title="menu governor"></a>menu governor</h2><p>​        menu governor 是 tickless 的默认 CPUIdle 系统。它相当复杂，但其设计的基本原理十分直接，当它为 CPU 选择空闲状态时，它会尝试预测空闲持续时间并使用预测值进行空闲状态选择。</p>
<p>​        menu governor 首先获取到最近的计时器事件的时间，并假设调度程序 tick 将停止。该时间，在下文中称为睡眠时长，是下一次 CPU 唤醒前的时间上限。它用于确定睡眠长度范围，进而获得睡眠长度校正因子。</p>
<p>​        menu governor 维护两个睡眠长度校正因子数组。其中一个用于先前在给定 CPU 上运行的任务正在等待某些 I/O 操作完成时使用，而另一个则用在其他情况。每个数组包含多个校正因子值，这些值对应于不同的睡眠长度范围，数组中表示的每个范围都比前一个范围宽大约 10 倍。</p>
<p>​        给定睡眠长度范围的校正因子（在为 CPU 选择空闲状态之前确定）在 CPU 被唤醒后更新，睡眠长度越接近观察到的空闲持续时间，校正因子越接近 1 （它必须介于 0 和 1 之间）。睡眠长度乘以它落入的范围的校正因子以获得预测空闲持续时间的第一近似值。</p>
<p>接下来，调控器使用简单的模式识别算法来改进其空闲时间预测。也就是说，它保存最后 8 个观察到的空闲持续时间值，并在下次预测空闲持续时间时，计算它们的平均值和方差。如果方差较小（小于 400 平方毫秒）或相对于平均值较小（平均值大于标准差的 6 倍），则将平均值视为“典型区间”值。否则，将丢弃保存的最长观察空闲持续时间值，并对剩余的值重复计算。同样，如果它们的方差很小（在上述意义上），则将平均值作为“典型区间”值，依此类推，直到确定“典型区间”或忽略太多数据点，其中假设“典型区间”等于“无穷大”（最大无符号整数值）。以这种方式计算的“典型间隔”与睡眠长度乘以校正因子进行比较，并将两者中的最小值作为预测的空闲持续时间。</p>
<p>然后，调控器计算额外的延迟限制以帮助“交互式”工作负载。它使用观察，如果所选空闲状态的退出延迟与预测的空闲持续时间相当，则在该状态中花费的总时间可能会非常短，并且进入该状态所节省的能量将相对较小，所以可能最好避免与进入该状态和退出该状态相关的开销。因此，选择较浅的状态可能是一个更好的选择。额外延迟限制的第一个近似值是预测的空闲持续时间本身，它另外除以一个值，该值取决于先前在给定 CPU 上运行的任务数，现在它们正在等待 I/O 操作完成。将该划分的结果与来自电源管理服务质量或 PM QoS 框架的延迟限制进行比较，并将两者中的最小值作为空闲状态退出延迟的限制。</p>
<p>现在，governer 已准备好遍历空闲状态列表并选择其中一个。为此，它将每个状态的目标驻留时间与预测的空闲持续时间以及它的退出延迟与计算的延迟限制进行比较。它选择目标驻留时间最接近预测的空闲持续时间但仍低于它的状态，并且退出延迟不超过限制。</p>
<p>在最后一步，如果调控器尚未决定停止调度程序滴答，则调控器可能仍需要细化空闲状态选择。如果它预测的空闲持续时间小于滴答周期并且滴答尚未停止（在空闲循环的先前迭代中），则会发生这种情况。然后，在之前的计算中使用的睡眠长度可能直到最近的计时器事件才反映实时，如果它确实大于那个时间，则调控器可能需要选择一个具有合适目标驻留的较浅状态。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://lwn.net/Articles/767630/">https://lwn.net/Articles/767630/</a></p>
<p><a href="https://www.kernel.org/doc/html/latest/admin-guide/pm/cpuidle.html">https://www.kernel.org/doc/html/latest/admin-guide/pm/cpuidle.html</a></p>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>cpu利用率</title>
    <url>/p/357e56ad.html</url>
    <content><![CDATA[<h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>写一个程序，让用户来决定 Windows 任务管理器的CPU占用率。程序越精简越好，语言不限。比如：</p>
<ul>
<li><p>CPU占用率固定在50%，为一条直线；</p>
</li>
<li><p>CPU占用率为一条直线，但是具体占用率由用户决定（参数范围1-100）；</p>
</li>
<li><p>CPU占用率状态是正弦曲线。</p>
<span id="more"></span></li>
</ul>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>在任务管理器的一个刷新周期里，CPU忙（执行应用程序）的时间和刷新周期总时间比率就是CPU的占用率，也就是说，任务管理器中显示的是每个刷新周期内CPU占用率的统计平均值。因此，可以写一个程序，让他在任务管理器的刷新期间内一会儿忙，一会儿闲，然后通过调节忙/闲的比例，就可以控制任务管理器中显示的CPU占用率。</p>
<h3 id="解法1"><a href="#解法1" class="headerlink" title="解法1"></a>解法1</h3><p>由于现在使用的windows电脑一般是多核，为了能够让程序能够在单个cpu上运行，可以在<font color="#FF0000">任务管理器</font>中<font color="#FF0000">详细信息</font>栏选中运行的程序，右键点击，选择<font color="#FF0000">设置相关性</font>，并在跳出的界面里选择程序运行所在的cpu。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(;;);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>首先查看死循环的CPU资源利用率。从图中可以发现，cpu的利用率达到了100%。</p>
<img src="/p/357e56ad/cpu1.PNG" class title="图1 cpu1">

<p>对上面的代码进行修改。增加sleep函数。现在我使用的电脑的cpu主频是1.60GHz，即每秒1.6*10<sup>9</sup>时钟周期。假设每个时钟周期运行两条代码。循环转换成汇编大约5条指令。于是，cpu一秒就可以运行(1.6*10<sup>9</sup>*2) / 5 = 3.2*10<sup>8</sup>个循环。于是，我们写了第二版代码。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(;;)&#123;</span><br><span class="line">		<span class="keyword">int</span> i;</span><br><span class="line">		<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">320000000</span>; i++);</span><br><span class="line">		Sleep(<span class="number">1000</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>运行结果下图所示。我们可以看到呈现为锯齿状，这是因为CPU工作一秒，休息一秒。而我们的刷新周期是小于一秒的，所以会呈现这样的曲线。</p>
<img src="/p/357e56ad/cpu2.PNG" class title="图2 cpu2">

<p>显然，这不符合我们的要求，我们尝试增加循环的频率，将320000000和1000降低两个数量级。注意，sleep时间不能太小，太小会造成线程频繁挂起和唤醒，无形中增加了内核时间的不确定性因素。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(;;)&#123;</span><br><span class="line">		<span class="keyword">int</span> i;</span><br><span class="line">		<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">3200000</span>; i++);</span><br><span class="line">		Sleep(<span class="number">10</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>从下图中可以看出cpu占用率在60左右浮动。通过不断调整3200000参数，就能在一条指定的机器上获得一条大致稳定的50%CPU占用率曲线。</p>
<img src="/p/357e56ad/cpu3.PNG" class title="图3 cpu3">

<p>经过一番调试之后，最终参数大约为2400000，最终效果图如下图所示。</p>
<img src="/p/357e56ad/cpu4.PNG" class title="图3 cpu4">

<p>使用这种方法，有两点注意：</p>
<ul>
<li><p>尽量减少sleep/awake频率，减少操作系统内核调度程序的干扰。</p>
</li>
<li><p>尽量不要调用system call，因为这也会导致很多不可控的内核运行时间。</p>
</li>
</ul>
<p>该方法有个很严重的问题：不能适应机器差异性。一旦换了CPU，必须要重新评估。</p>
<h3 id="解法2"><a href="#解法2" class="headerlink" title="解法2"></a>解法2</h3><p>GetTickCount()可以获得系统启动到现在所经历时间的毫秒值，最后能够统计到49.7天。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> busyTime = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">int</span> idleTime = busyTime;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> startTime = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(;;)&#123;</span><br><span class="line">		startTime = GetTickCount();</span><br><span class="line">		<span class="keyword">while</span>((GetTickCount() - startTime) &lt;= busyTime);</span><br><span class="line">		Sleep(idleTime);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>注意这两种方法都是假设当前cpu只有当前程序运行，但实际上操作系统中有很多程序会同时执行各种各样的任务，因此，实际运行的效果会如下图所示。</p>
<img src="/p/357e56ad/cpu5.PNG" class title="图5 cpu5">

<p>那么，我们该怎样做呢？这就要运用到另一个工具perfmon.exe。</p>
<p>Perfmon可以获得有关操作系统，应用程序和硬件的各种能效计数器。</p>
]]></content>
      <tags>
        <tag>编程之美读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/p/4a17b156.html</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<span id="more"></span>

<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>WIN10配置hexo</title>
    <url>/p/c7035f77.html</url>
    <content><![CDATA[<p>具体可以参考官方中文文档<a href="https://hexo.io/zh-cn/docs/index.html">https://hexo.io/zh-cn/docs/index.html</a></p>
<span id="more"></span>


<h1 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h1><p><strong>方法一</strong>：官方的安装地址：<a href="https://nodejs.org/en/download/">https://nodejs.org/en/download/</a><br><strong>方法二</strong>：通过 nvs（推荐）或者nvm 安装。nvs安装地址：<a href="https://github.com/jasongin/nvs/">https://github.com/jasongin/nvs/</a></p>
<h1 id="安装git（略）"><a href="#安装git（略）" class="headerlink" title="安装git（略）"></a>安装git（略）</h1><h1 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm install -g hexo-cli</span><br><span class="line">$ npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>
<h1 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo g #完整命令为hexo generate，用于生成静态文件</span><br><span class="line">$ hexo s #完整命令为hexo server，用于启动服务器，主要用来本地预览</span><br><span class="line">$ hexo d #完整命令为hexo deploy，用于将本地文件发布到github上</span><br><span class="line">$ hexo n #完整命令为hexo new，用于新建一篇文章</span><br></pre></td></tr></table></figure>
<h1 id="建站"><a href="#建站" class="headerlink" title="建站"></a>建站</h1><p><strong>1、</strong>安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo init &lt;folder&gt;</span><br><span class="line">$ cd &lt;folder&gt;</span><br><span class="line">$ npm install</span><br></pre></td></tr></table></figure>
<p>接下来说明部分文件的作用。<br><strong>_config.yml</strong><br>网站的 <em>配置</em>  信息，您可以在此配置大部分的参数。</p>
<p><strong>package.json</strong><br><em>应用程序</em> 的信息。EJS, Stylus 和 Markdown renderer 已默认安装，您可以自由移除。</p>
<p><strong>scaffolds</strong><br><em>模版</em> 文件夹。当您新建文章时，Hexo 会根据 scaffold 来建立文件。</p>
<p>Hexo的模板是指在新建的文章文件中默认填充的内容。例如，如果您修改scaffold/post.md中的Front-matter内容，那么每次新建一篇文章时都会包含这个修改。</p>
<p><strong>source</strong><br><em>资源</em> 文件夹是存放用户资源的地方。除 _posts 文件夹之外，开头命名为 _ (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去。</p>
<p><strong>themes</strong><br><em>主题</em> 文件夹。Hexo 会根据主题来生成静态页面。</p>
<p><strong>2、</strong>将hexo和github进行关联<br>首先在github上创建一个仓库，仓库名为***.github.io，接着编辑**_config.yml**文件，在_config.yml最下方，添加如下配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: git@github.com:***&#x2F;***.github.io.git</span><br><span class="line">  branch: main</span><br></pre></td></tr></table></figure>
<p><strong>3、</strong>将本地文件同步到github</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo g</span><br><span class="line">$ hexo d</span><br></pre></td></tr></table></figure>
<p>此时，我们的博客已经搭建起来，并发布到Github上了，这时可以登陆自己的Github查看代码是否已经推送到对应Repository。最后到github的settings的GitHub Pages中查看，可以在那里看到一个网址，点击即可访问查看。</p>
]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>查看时间，磁盘/内存可用空间</title>
    <url>/p/ffafa36b.html</url>
    <content><![CDATA[<h2 id="查看时间"><a href="#查看时间" class="headerlink" title="查看时间"></a>查看时间</h2><span id="more"></span>

<h3 id="date"><a href="#date" class="headerlink" title="date"></a>date</h3><p>date命令显示当前系统时间和日期：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">date</span><br></pre></td></tr></table></figure>

<img src="/p/ffafa36b/date.PNG" class title="图1 date">


<h3 id="cal"><a href="#cal" class="headerlink" title="cal"></a>cal</h3><p>cal命令显示当月的日历：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cal</span><br></pre></td></tr></table></figure>

<img src="/p/ffafa36b/cal.PNG" class title="图2 cal">


<h2 id="查看磁盘-内存可用空间"><a href="#查看磁盘-内存可用空间" class="headerlink" title="查看磁盘/内存可用空间"></a>查看磁盘/内存可用空间</h2><h3 id="df"><a href="#df" class="headerlink" title="df"></a>df</h3><p>df命令显示磁盘驱动器当前的可用空间：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">df</span><br></pre></td></tr></table></figure>

<img src="/p/ffafa36b/df.PNG" class title="图3 df">



<h3 id="free"><a href="#free" class="headerlink" title="free"></a>free</h3><p>free命令显示可用内存：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">free</span><br></pre></td></tr></table></figure>

<img src="/p/ffafa36b/free.PNG" class title="图4 free">



<h2 id="目录操作"><a href="#目录操作" class="headerlink" title="目录操作"></a>目录操作</h2><h3 id="pwd"><a href="#pwd" class="headerlink" title="pwd"></a>pwd</h3><p>pwd命令显示当前工作目录：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pwd</span><br></pre></td></tr></table></figure>

<img src="/p/ffafa36b/pwd.PNG" class title="图5 pwd">

<h3 id="ls"><a href="#ls" class="headerlink" title="ls"></a>ls</h3><p>ls命令列出当前工作目录的文件和目录：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ls</span><br></pre></td></tr></table></figure>

<img src="/p/ffafa36b/ls.PNG" class title="图6 ls">

<h3 id="cd"><a href="#cd" class="headerlink" title="cd"></a>cd</h3><p>cd命令改变工作目录。只需要输入cd命令，然后再输入目标工作目录的路径名即可：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd bin</span><br></pre></td></tr></table></figure>

<img src="/p/ffafa36b/cd.PNG" class title="图7 cd">



]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Makefiles 简介</title>
    <url>/p/c677bb8a.html</url>
    <content><![CDATA[<p>内容摘自《GNU Make》第二章。</p>
<span id="more"></span>

<p>本文将讨论一个简单的 Makefile，这个 Makefile 将描述如何编译和连接 8 个 C 语言源代码文件和 3 个头文件。当 make 重新编译，每一个修改了的 C 语言源代码文件都要重新编译。如果头文件发生了修改，所有包含了该头文件的源代码文件要重新编译。每一次编译都会产生一个目标文件，当发生重新编译时，所有文件都要重新链接成一个新的可执行文件。</p>
<h2 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h2><p>一个简单的 Makefile 由很多规则组成，规则有着以下的模式：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">target ... : prerequisites ...</span><br><span class="line">	recipe</span><br><span class="line">	...</span><br><span class="line">	...</span><br></pre></td></tr></table></figure>

<p>target 一般是程序要生成的文件名字，比如说是可执行文件或目标文件的名字。target 还可能是需要执行的操作的名字，比如 clean。</p>
<p>prerequisites 是被用作创建 target 的依赖文件。target 一般会依赖一些文件。</p>
<p>recipe 是 make 要执行的操作。recipe 可以有超过一条命令。注意，<strong>必须在每个 recipe 行的开始加上 tab。</strong>recipe 一般在有 prerequisites 的规则中，当 prerequisites 中的文件变化时创建 target 文件。但是，一些规则指定了 recipe 就不需要 prerequisites，比如 clean。</p>
<h2 id="简单的例子"><a href="#简单的例子" class="headerlink" title="简单的例子"></a>简单的例子</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">edit : main.o kbd.o command.o display.o \</span><br><span class="line">		insert.o search.o files.o utils.o</span><br><span class="line">		cc -o edit main.o kbd.o command.o display.o \</span><br><span class="line">					insert.o search.o files.o utils.o</span><br><span class="line">					</span><br><span class="line">main.o : main.c defs.h</span><br><span class="line">		cc -c main.c</span><br><span class="line">kbd.o : kbd.c defs.h command.h</span><br><span class="line">		cc -c kbd.c</span><br><span class="line">command.o : command.c defs.h command.h</span><br><span class="line">		cc -c command.c</span><br><span class="line">display.o : display.c defs.h buffer.h</span><br><span class="line">		cc -c display.c</span><br><span class="line">insert.o : insert.c defs.h buffer.h</span><br><span class="line">		cc -c insert.c</span><br><span class="line">search.o : search.c defs.h buffer.h</span><br><span class="line">		cc -c search.c</span><br><span class="line">files.o : files.c defs.h buffer.h command.h</span><br><span class="line">		cc -c files.c</span><br><span class="line">utils.o : utils.c defs.h</span><br><span class="line">		cc -c utils.c</span><br><span class="line">		</span><br><span class="line">clean :</span><br><span class="line">		rm edit main.o kbd.o command.o display.o \</span><br><span class="line">			insert.o search.o files.o utils.o</span><br></pre></td></tr></table></figure>

<p>如果想要创建名为 edit 的可执行文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure>

<p>如果想要删除所有目录下的所有可执行文件和目标文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">make clean</span><br></pre></td></tr></table></figure>

<h2 id="make-执行-Makefile"><a href="#make-执行-Makefile" class="headerlink" title="make 执行 Makefile"></a>make 执行 Makefile</h2><p>在默认情况下，make 从第一个 target 开始执行（不是以 ”.“ 开头 target）。这个被称为 default goal。Goal 是 make 努力更新的最终 targets。上面的例子中，default goal 就是edit，所以是第一个规则。</p>
<p>在执行 make 时，首先读取当前目录下的 makefile 文件然后处理第一个规则。在上面的例子中，这个规则是用来链接 edit，但是在 make 能完全处理这个规则之前，make 必须处理 edit 依赖的文件的规则，在上面这个例子中就是目标文件。每个目标文件都要根据自己的规则进行处理。</p>
<p>如果一个规则不被 goal 依赖，则这个命令就不会被处理，除非你告诉 make 要执行，比如make clean。</p>
<p>当目标文件不存在，或源文件，头文件比目标文件更新时，会进行重新编译。当执行文件不存在，或者执行文件比目标文件更晚时，执行文件会更新。</p>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>在上一个例子中，我们在 edit 规则中枚举所有的目标文件两次，这是很不方便的。如果有新的目标文件加入，可能会导致忘记在所有地方都修改。因此可以使用变量简化。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">objects &#x3D; main.o kbd.o command.o display.o \</span><br><span class="line">		insert.o search.o files.o utils.o</span><br><span class="line">		</span><br><span class="line">edit : $(objects)</span><br><span class="line">		cc -o edit $(objects)</span><br><span class="line">		</span><br><span class="line">main.o : main.c defs.h</span><br><span class="line">		cc -c main.c</span><br><span class="line">kbd.o : kbd.c defs.h command.h</span><br><span class="line">		cc -c kbd.c</span><br><span class="line">command.o : command.c defs.h command.h</span><br><span class="line">		cc -c command.c</span><br><span class="line">display.o : display.c defs.h buffer.h</span><br><span class="line">		cc -c display.c</span><br><span class="line">insert.o : insert.c defs.h buffer.h</span><br><span class="line">		cc -c insert.c</span><br><span class="line">search.o : search.c defs.h buffer.h</span><br><span class="line">		cc -c search.c</span><br><span class="line">files.o : files.c defs.h buffer.h command.h</span><br><span class="line">		cc -c files.c</span><br><span class="line">utils.o : utils.c defs.h</span><br><span class="line">		cc -c utils.c</span><br><span class="line">		</span><br><span class="line">clean :</span><br><span class="line">		rm edit $(objects)</span><br></pre></td></tr></table></figure>

<h2 id="make-推断-recipes"><a href="#make-推断-recipes" class="headerlink" title="make 推断 recipes"></a>make 推断 recipes</h2><p>隐含的规则：默认使用 “cc -c” 命令把 .c 文件编译成 “.o” 文件，所以如果使用该命令，则可以省略。另外，由于.o文件默认会寻找名字相同的 .c 文件作为依赖，所以在 prerequisites 中可以省略名字相同的 .c 文件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">objects &#x3D; main.o kbd.o command.o display.o \</span><br><span class="line">		insert.o search.o files.o utils.o</span><br><span class="line">		</span><br><span class="line">edit : $(objects)</span><br><span class="line">		cc -o edit $(objects)</span><br><span class="line">		</span><br><span class="line">main.o : defs.h</span><br><span class="line">kbd.o : defs.h command.h</span><br><span class="line">command.o : defs.h command.h</span><br><span class="line">display.o : defs.h buffer.h</span><br><span class="line">insert.o : defs.h buffer.h</span><br><span class="line">search.o : defs.h buffer.h</span><br><span class="line">files.o : defs.h buffer.h command.h</span><br><span class="line">utils.o : defs.h</span><br><span class="line"></span><br><span class="line">.PHONY : clean</span><br><span class="line">clean :</span><br><span class="line">		rm edit $(objects)</span><br></pre></td></tr></table></figure>

<h2 id="另一种写法"><a href="#另一种写法" class="headerlink" title="另一种写法"></a>另一种写法</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">objects &#x3D; main.o kbd.o command.o display.o \</span><br><span class="line">		insert.o search.o files.o utils.o</span><br><span class="line">		</span><br><span class="line">edit : $(objects)</span><br><span class="line">		cc -o edit $(objects)</span><br><span class="line">		</span><br><span class="line">$(objects) : defs.h</span><br><span class="line">kbd.o command.o files.o : command.h</span><br><span class="line">display.o insert.o search.o files.o : buffer.h</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>makefile</tag>
      </tags>
  </entry>
  <entry>
    <title>写 Makefile 文件</title>
    <url>/p/dcfc36a.html</url>
    <content><![CDATA[<p>内容摘自《GNU Make》第三章。</p>
<span id="more"></span>

<h2 id="Makefile-内容"><a href="#Makefile-内容" class="headerlink" title="Makefile 内容"></a>Makefile 内容</h2><ul>
<li><p>明确规则。明确的规则表明何时和怎样去 remake 一个或多个文件，这些文件称为规则的 targets。规则会列举 target 依赖的其他文件，这些文件称为 target 的 prerequistes。有些时候还会给出 recipe 用来创建或更新 target。</p>
</li>
<li><p>隐含规则。隐含规则表明基于 target 的名字就可以知道何时和怎样去 remake 一个或多个文件。</p>
</li>
<li><p>变量声明。将文本字符串指定给某一个变量，使得后续可以使用变量替代对应的文本字符串。</p>
</li>
<li><p>指令。指令是让 make 去做一些特殊的事情：</p>
<ul>
<li>读取其他 makefile 文件</li>
<li>决定是使用还是放弃 makefile 的部分内容。</li>
<li>定义一个多行的变量。</li>
</ul>
</li>
<li><p>注释。“#”。不能在变量声明或函数调用中使用注释，在变量声明和函数调用中，“#” 会被当作字面值，而不是注释的开始。</p>
</li>
</ul>
<h2 id="长行切割"><a href="#长行切割" class="headerlink" title="长行切割"></a>长行切割</h2><p>Makefile 使用基于行的语法，每个换行符都是特殊的，标志着声明的结束。虽然GNU对于一行的长度没有限制，但是为了可读性，需要将较长的行分割成多行。这可以使用 ’\‘ 。对于 “\“ + “\n” 的处理要看声明是否是recipe。如果不是，”\“ + “\n” 会被当做空格处理。另外，所有 “\“ + “\n” 附近的空格都会被压缩为一个空格，这包括 “\“ + “\n”  之前的空格，”\“ + “\n”  之后的行开头的空格和连续的 “\“ + “\n” 组合。</p>
<p>如果不想要空格，可以使用 ”$\“ + “\n”。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var :&#x3D; one$\</span><br><span class="line">		word</span><br></pre></td></tr></table></figure>

<p>等价于：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var :&#x3D; oneword</span><br></pre></td></tr></table></figure>

<h2 id="Makefile-文件名"><a href="#Makefile-文件名" class="headerlink" title="Makefile 文件名"></a>Makefile 文件名</h2><p>默认会依次找以下文件名：GNUmakefile，makefile，Makefile。</p>
<p>建议使用 Makefile，因为与 README 这些文件靠的近。除非特殊指定 GNU make，要不然不要使用GNUmakefile。因为其他 make 版本不支持。</p>
<p>如果没有找到以上的文件， make 就不会使用任何 makefile。你必须通过命令行指定 goal，然后 make 会使用隐藏规则 remake。</p>
<p>如果你想给你的 makefile 换一个名字，则要加 -f 或 –file 选项。</p>
]]></content>
      <tags>
        <tag>makefile</tag>
      </tags>
  </entry>
  <entry>
    <title>Nova源码阅读（一） openstack简介</title>
    <url>/p/ecb3c3ec.html</url>
    <content><![CDATA[<p>内容主要摘自于《Openstack设计与实现》。</p>
<h2 id="openstack与AWS"><a href="#openstack与AWS" class="headerlink" title="openstack与AWS"></a>openstack与AWS</h2><p>与AWS相比，openstack只是处于一个追随者的位置。</p>
<span id="more"></span>

<h3 id="AWS架构"><a href="#AWS架构" class="headerlink" title="AWS架构"></a>AWS架构</h3><p>AWS由五层组成，自下而上包括AWS全球基础架构，基础服务，应用平台服务，管理和用户应用程序。</p>
<p>AWS提供六类主要服务：数据库，存储和内容分发，分析，计算和网络，部署管理，应用服务。</p>
<ul>
<li>数据库：NoSQL数据库服务DynamoDB，关系数据库服务RDS，缓存和数据仓库服务Redshift</li>
<li>存储和内容分发：简单存储服务S3，块存储服务EBS，Amazon云前端Cloud Front，Amazon Glacier，AWS存储网关Storage Gateway。</li>
<li>分析：用于大数据的EMR，用于大规模实时流数据处理Kinesis，数据管道Data Pipeline</li>
<li>计算和网络服务：负责虚拟机调度和管理EC2，保证企业在公有云上搭建安全私有云的虚拟私有云服务VPC，负载均衡ELB，虚拟桌面管理服务WorkSpaces，计算资源自动扩容缩容的Auto Scaling，为企业定制的专属网络连接DirectConnect，高可靠性且可扩展的域名系统web服务Route 53</li>
<li>部署管理：建立和管理AWS资源CloudFormation，监控CloudWatch，轻松部署Web应用和服务的Elastic Beanstalk，验证访问管理IAM，日志管理CloudTrail，为运维人员配备的应用管理服务OpsWorks和安全服务CloudHSM</li>
<li>应用服务：云搜索CloudSearch，流媒体转码Elastic Transcoder，简单邮件服务SES，简单队列服务SQS，简单工作流服务SWF，应用程序流AppStream</li>
</ul>
<h3 id="AWS与Openstack相对应的项目"><a href="#AWS与Openstack相对应的项目" class="headerlink" title="AWS与Openstack相对应的项目"></a>AWS与Openstack相对应的项目</h3><table>
<thead>
<tr>
<th align="center">AWS模块</th>
<th align="center">Openstack模块</th>
</tr>
</thead>
<tbody><tr>
<td align="center">EC2</td>
<td align="center">Nova</td>
</tr>
<tr>
<td align="center">S3</td>
<td align="center">Swift</td>
</tr>
<tr>
<td align="center">EBS</td>
<td align="center">Cinder</td>
</tr>
<tr>
<td align="center">IAM</td>
<td align="center">Keystone</td>
</tr>
<tr>
<td align="center">CloudWatch</td>
<td align="center">Ceilometer</td>
</tr>
<tr>
<td align="center">CloudFormation</td>
<td align="center">Heat</td>
</tr>
<tr>
<td align="center">支持RDS, DynamoDB</td>
<td align="center">支持MySQL，PostgreSQL，MongoDB</td>
</tr>
</tbody></table>
<h2 id="openstack-架构"><a href="#openstack-架构" class="headerlink" title="openstack 架构"></a>openstack 架构</h2><img src="/p/ecb3c3ec/openstack%E6%A0%87%E5%87%86%E6%9E%B6%E6%9E%84.jpeg" class title="图1 openstack结构">

<p>OpenStack曾经包含7个核心组件：</p>
<table>
<thead>
<tr>
<th align="center">组件名称</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Nova</td>
<td align="center">提供虚拟机服务</td>
</tr>
<tr>
<td align="center">Swift</td>
<td align="center">存储和检索对象/文件</td>
</tr>
<tr>
<td align="center">KeyStone</td>
<td align="center">身份认证和授权，跟踪用户及他们的权限</td>
</tr>
<tr>
<td align="center">Horizon</td>
<td align="center">提供界面</td>
</tr>
<tr>
<td align="center">Cinder</td>
<td align="center">块存储服务</td>
</tr>
<tr>
<td align="center">Neutron</td>
<td align="center">网络连接服务，允许用户创建自己的虚拟网络并连接各种网络设备接口</td>
</tr>
<tr>
<td align="center">Glance</td>
<td align="center">虚拟机镜像的存储，查询和检索服务</td>
</tr>
</tbody></table>
]]></content>
      <tags>
        <tag>openstack</tag>
      </tags>
  </entry>
  <entry>
    <title>nova-参数</title>
    <url>/p/200ca30a.html</url>
    <content><![CDATA[<p>train版本</p>
<p><a href="https://docs.openstack.org/nova/train/configuration/config.html">https://docs.openstack.org/nova/train/configuration/config.html</a></p>
]]></content>
      <tags>
        <tag>openstack</tag>
      </tags>
  </entry>
  <entry>
    <title>Nova源码阅读（二） openstack通用技术</title>
    <url>/p/7952953b.html</url>
    <content><![CDATA[<p>内容主要摘自于《Openstack设计与实现》。</p>
<span id="more"></span>

<h2 id="消息总线"><a href="#消息总线" class="headerlink" title="消息总线"></a>消息总线</h2><p>Openstack遵循这样的原则：项目之间通过<strong>RESTful API</strong>进行通信，项目内部的不同服务进程之间的通信，则必须通过<strong>消息总线</strong>。oslo.messaging 库实现了以下两种方式来完成项目内部的不同服务进程之间的通信。</p>
<ul>
<li>远程过程调用（RPC）。通过RPC，一个服务进程可以调用其他远程服务进程的方法，并且有两种调用方式：同步和异步。</li>
<li>事件通知（Event Notification）。某个服务进程可以把事件通知发送到消息总线上，该消息总线上的所有对此类事件感兴趣的服务进程，都可以获得此事件通知并进行进一步的处理，但是处理的结果并不会返回给事件的发送者。</li>
</ul>
<h3 id="AMQP-advanced-message-queuing-protocol"><a href="#AMQP-advanced-message-queuing-protocol" class="headerlink" title="AMQP(advanced message queuing protocol)"></a>AMQP(advanced message queuing protocol)</h3><p>在Openstack支持的消息总线类型中，大部分都是基于AMQP的。AMQP是一个异步消息传递所使用的开放的应用层协议，主要包括信息的导向，队列，路由，可靠性和安全性。oslo.messaging中支持的AMQP主要包括两个版本，AMQP 0.9.1和AMQP 1.0，两个版本有较大区别。</p>
<h4 id="AMQP-0-9-1"><a href="#AMQP-0-9-1" class="headerlink" title="AMQP 0.9.1"></a>AMQP 0.9.1</h4><img src="/p/7952953b/AMQP.PNG" class title="图1 AMQP结构">

<p>当不同的消息由生产者（Publisher application）发送到broker时，会根据不同的条件把消息传递给不同的消费者（consumer）。如果消费者无法接收到信息或者接受信息不够快时，会把消息缓存在内存和磁盘上。</p>
<p>生产者将消息发送给Exchange，并由Exchange来决定消息的路由，即消息发送给哪个Queue，然后消费者从Queue中取出消息，进行处理。</p>
<p>每一个消息都有一个routing key，每一个queue有一个binding key，Exchange在收到消息时，会将routing key与每一个queue的binding key进行匹配，匹配成功，则会将信息转发到对应的queue中。</p>
<p>转发的类型有三种：</p>
<ul>
<li><p>direct：routing key与binding key完全一致，不支持通配符；</p>
</li>
<li><p>topic：支持通配符；</p>
</li>
<li><p>fanout：忽略routing key与binding key。消息转发到所有queue中。</p>
</li>
</ul>
<h4 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h4><p>RabbitMQ是一个实现了AMQP的消息中间件服务，支持多种语言的客户端开发，支持用户自定义插件开发的框架及多种插件。</p>
<h4 id="AMQP-1-0"><a href="#AMQP-1-0" class="headerlink" title="AMQP 1.0"></a>AMQP 1.0</h4><p>与AMQP 0.9.1相比，1.0协议更加灵活和复杂。1.0实现了一种消息路由模式：位于调用者和服务器之间的不再是单节点的broker，而是一群互相连接的消息路由组成的路由网；路由不具备queue，没有存储消息的能力，作用只是传递消息；路由节点之间通过使用tcp连接进行通信；调用者可以通过tcp连接连到路由网中的某个路由，从而接入路由网。</p>
<h2 id="SQLAlchemy与数据库"><a href="#SQLAlchemy与数据库" class="headerlink" title="SQLAlchemy与数据库"></a>SQLAlchemy与数据库</h2><img src="/p/7952953b/SQLAlchemy.PNG" class title="图2 SQLAlchemy结构">

<p>SQLAlchemy 主要包括两个部分：SQLAlchemy Core和SQLAlchemy ORM。SQLAlchemy core包括SQL语言表达式，数据引擎，连接池等。所有的实现都是以连接不同类型的后台数据库，提交查询和更新SQL请求，定义数据库数据类型和定义schema等为目的。SQLAlchemy ORM提供数据映射模式，即把程序语言的对象数据映射成数据库的关系数据，或者把关系数据映射为对象数据。另外SQLAlchemy对象关系映射是一个可选模块，开发人员可以完全不使用任何对象模型，直接使用SQLAlchemy操作数据。</p>
<h2 id="RESTful-与-WSGI"><a href="#RESTful-与-WSGI" class="headerlink" title="RESTful 与 WSGI"></a>RESTful 与 WSGI</h2><h3 id="RESTful"><a href="#RESTful" class="headerlink" title="RESTful"></a>RESTful</h3><p>参考文献：</p>
<ol>
<li><a href="https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm">https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm</a></li>
<li><a href="http://restful.p2hp.com/">http://restful.p2hp.com/</a></li>
</ol>
<p>REST（representational state transfer，表述性状态转移）。从RESTful角度上看，网络中的所有东西都是资源，每个资源都对应于一个特定的URI，并用它进行标识。资源有多种具体的表现形式，即资源的表述。URI仅代表资源的实体，不能代表其表现形式。</p>
<p>REST的指导原则</p>
<ol>
<li><strong>客户端 - 服务器</strong> 。</li>
<li><strong>无状态</strong>。从客户端到服务器的每个请求都必须包含理解请求所需的所有信息，并且不能利用服务器上任何存储的上下文。因此，会话状态完全保留在客户端上。</li>
<li><strong>可缓存</strong> 。缓存约束要求将对请求的响应中的数据隐式或显式标记为可缓存或不可缓存。如果响应是可缓存的，则客户端缓存有权重用该响应数据以用于以后的等效请求。</li>
<li><strong>统一接口</strong> 。</li>
<li><strong>分层系统</strong>。 分层系统风格允许通过约束组件行为来使体系结构由分层层组成，这样每个组件都不能“看到”超出与它们交互的直接层。</li>
<li><strong>按需编码（可选）</strong>。 REST允许通过以小程序或脚本的形式下载和执行代码来扩展客户端功能。这通过减少预先实现所需的功能数量来简化客户端。</li>
</ol>
<h3 id="WSGI（Web-service-gateway-interface）"><a href="#WSGI（Web-service-gateway-interface）" class="headerlink" title="WSGI（Web service gateway interface）"></a>WSGI（Web service gateway interface）</h3><p>RESTful只是设计风格而不是标准，WEB服务通常使用基于HTTP的符合RESTful的API，而WSGI则是python语言中所定义的WEB服务器和WEB应用程序或框架之间的通用接口标准。</p>
<p>当处理一个WSGI请求时，服务端会为应用端提供上下文信息和一个回调函数，应用端在处理完请求后，会使用服务端所提供的回调函数返回对应请求的响应。</p>
<p>WSGI将WEB组件分成三类：WEB服务器，WEB中间件，WEB应用程序。WEB服务器用于接收HTTP请求，封装一系列环境变量，按照WSGI接口标准调用注册的WSGI应用程序，然后将响应返回给客户端。</p>
<p>WSGI应用程序是一个可被调用的Python对象，只接受两个参数，environ和start_response。</p>
<ul>
<li><p>environ指向一个python字典，要求里面至少包含一些在CGI中定义的变量以及至少包含其他7个WSGI所定义的环境变量。WSGI应用程序会从environ字典中获取相应的请求及其执行上下文中的所有信息。</p>
</li>
<li><p>start_response指向一个回调函数：</p>
<p><code>start_response(status, response_headers,exe_info=None)</code></p>
<p>status是一个响应状态的字符串；response_headers是一个包含了（header_name,header_value）元组的列表，分别表示HTTP相应中的HTTP头和内容；exe_info一般在错误时使用，用来让浏览器显示相关错误信息。</p>
<p>回调函数返回形如write(data)的可被调用的对象。这个对象是为了兼容现有的一些特殊框架而设计的，一般不使用。</p>
</li>
</ul>
<h4 id="Paste-文件"><a href="#Paste-文件" class="headerlink" title="Paste 文件"></a>Paste 文件</h4><p>  Openstack使用Paste的Deploy组件完成WSGI Server和WSGI Application的构建，每个项目源码的etc目录下都有一个Paste文件，如Nova的etc/nova/api-paste.ini，在部署时，这些文件被拷贝到系统/etc/&lt;project&gt;/目录下。</p>
<p>Paste配置文件分为多个section，每个section以type:name命名。</p>
<ul>
<li><p>type = composite</p>
<p>这个section会把URL请求发到对应的应用程序中，并由use指定具体的分发方式。</p>
</li>
<li><p>type = app</p>
<p>一个app就是一个具体的WSGI 应用程序，这个app对应的python代码可以由use来指定。另一种指定方法是明确指定对应的python代码，这时必须给出代码应该符合的格式。</p>
</li>
<li><p>type = filter-app</p>
<p>在接收到一个请求后，会先调用fliter-app中的use所指定的app进行过滤，如果请求没有被过滤，就会被转发到next所指定的app上进行下一步的处理。</p>
</li>
<li><p>type = filter</p>
<p>跟上一个的区别是没有next。</p>
</li>
<li><p>type = pipeline</p>
<p>由一系列filter组成，filter链条的末尾是一个app。pipeline类型对filter-app做了简化。</p>
</li>
</ul>
<h4 id="WebOb"><a href="#WebOb" class="headerlink" title="WebOb"></a>WebOb</h4><p>WebOb通过对WSGI的请求与相应进行封装，可以简化WSGI应用的编写。</p>
<p>WebOb重要的对象：</p>
<ul>
<li><p>webob.Request。对WSGI请求的参数environ进行封装；</p>
</li>
<li><p>webob.Response。包含了标准WSGI响应的所有要素；</p>
</li>
<li><p>webob.exc。针对HTTP错误代码进行封装。</p>
</li>
<li><p>webob.dec.wsgify。以便可以不使用原始的WSGI参数和返回格式，而全部使用WebOb替代。</p>
</li>
</ul>
<h4 id="Pecan"><a href="#Pecan" class="headerlink" title="Pecan"></a>Pecan</h4><p>Paste组合框架的REATful API代码过于臃肿，导致项目的可维护性差。一些新项目使用Pecan框架实现RESTful API。Pecan是一个轻量级的WSGI网络框架。其设计思想不是解决Web世界的所有问题，而是主要集中于对象路由和RESTful支持上，并不提供对话和数据库支持。  </p>
<h2 id="Eventlet-与-AsyncIO"><a href="#Eventlet-与-AsyncIO" class="headerlink" title="Eventlet 与 AsyncIO"></a>Eventlet 与 AsyncIO</h2><p>Openstack中的绝大多数项目采用协程模型。协程，是一种比线程更加轻量级的存在，协程拥有自己独立的栈和局部变量，同时与其他协程共享全局变量。</p>
<p>协程与线程的区别是：多个线程可以同时执行，但是同一时间只能有一个协程运行；线程的执行由操作系统控制，协程的执行顺序由程序自己决定。由于协程无需考虑很多有关锁的问题，因此开发和调试比较简单。</p>
<h3 id="Eventlet"><a href="#Eventlet" class="headerlink" title="Eventlet"></a>Eventlet</h3><p>协程来实现并发，将协程称为GreenTread，所谓的并发就是建立多个GreenTread，并对其进行管理。</p>
<h3 id="AsyncIO"><a href="#AsyncIO" class="headerlink" title="AsyncIO"></a>AsyncIO</h3><p>Eventlet具有局部性，如不支持Python3，PyPy，Jython等，只支持CPython。目前Openstack正考虑用AsyncIO替代Eventlet。</p>
]]></content>
      <tags>
        <tag>openstack</tag>
      </tags>
  </entry>
  <entry>
    <title>资源调度算法调研（一）</title>
    <url>/p/bcc3e70e.html</url>
    <content><![CDATA[<h2 id="传统算法-1"><a href="#传统算法-1" class="headerlink" title="传统算法[1]"></a>传统算法<sup>[1]</sup></h2><span id="more"></span>

<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p><font color="#FF0000">metatask</font>: a collection of independent tasks with no intertask data dependencies;</p>
<p><font color="#FF0000">&tau;</font>: The size of the metatask (i.e., the number of tasks to execute);</p>
<p><font color="#FF0000">&mu;</font>: the number of machines in the HC suite;</p>
<p>&tau; and &mu; are static and known beforehand.</p>
<p>It is assumed that an accurate estimate of the expected execution time for each task on each machine is known prior to execution and contained within a &tau;*&mu; ETC (expected time to compute) matrix;</p>
<p>It is also assumed that each machine executes a single task at a time.</p>
<p><font color="#FF0000">Machine availability time, mat(m<sub>j</sub>)</font>：the earliest time machine m<sub>j</sub> can complete the execution of all the tasks that have previously been assigned to it (based on the ETC entries for those tasks). </p>
<p><font color="#FF0000">The completion time for a new task t<sub>i</sub> on machine m<sub>j</sub> , ct(t<sub>i</sub> , m<sub>j</sub>)</font>: the machine availability time for m<sub>j</sub> plus the execution time of task t<sub>i</sub> on machine m<sub>j</sub> , i.e., ct(t<sub>i</sub> , m<sub>j</sub>)= mat(m<sub>j</sub>)+ETC(t<sub>i</sub> , m<sub>j</sub>). </p>
<p>The performance criterion used to compare the results of the heuristics is the maximum value of ct(t<sub>i</sub> , m<sub>j</sub>), for  0 &le; i &lt; &tau; and 0 &le; j &lt; &mu;. The maximum ct(t<sub>i</sub> , m<sub>j</sub>) value, over 0 &le; i &lt; &tau; and 0 &le; j &lt; &mu;, is the metatask execution time, and is called the <font color="#FF0000">makespan</font> . </p>
<p>Each heuristic is attempting to minimize the makespan, i.e., finish execution of the metatask as soon as possible.</p>
<h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><table>
<thead>
<tr>
<th align="center">算法</th>
<th align="left"><p align="middle">描述</p></th>
<th align="left"><p align="middle">优点</p></th>
<th align="left"><p align="middle">缺点</p></th>
</tr>
</thead>
<tbody><tr>
<td align="center">Opportunistic Load Balancing (OLB)</td>
<td align="left">OLB算法会将负载随机交给一个可用的节点，不管任务执行的时间。动机是尽量保持所有的机器忙碌。</td>
<td align="left"><p align="middle">简单</p></td>
<td align="left">poor makespan</td>
</tr>
<tr>
<td align="center">Minimum Execution Time (MET)</td>
<td align="left">MET会将任务分配给对于该任务，有着最小执行时间的机器，不管机器何时可用。动机是尽量将任务分配给最适合它的机器。</td>
<td align="left"></td>
<td align="left">会造成严重的负载不均衡</td>
</tr>
<tr>
<td align="center">Minimum Completion Time (MCT)</td>
<td align="left">MCT会将任务分配给对于该任务，有着最小完成时间的机器。</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="center">Min-min</td>
<td align="left">U：unmapped tasks；M={min<sub>0&le;j&lt;&mu;</sub>(ct(t<sub>i</sub> , m<sub>j</sub>)), for each t<sub>i</sub> &in;U}；M中最小的任务分配给对应的机器，之后将该任务移除，重复该步骤直到U为空。</td>
<td align="left">good makespan</td>
<td align="left">执行长任务而带来延迟。比如：当有很多短任务和一个很长的任务，会由于最后执行长任务而带来极大的开销</td>
</tr>
<tr>
<td align="center">Max-min</td>
<td align="left">U：unmapped tasks；M={min<sub>0&le;j&lt;&mu;</sub>(ct(t<sub>i</sub> , m<sub>j</sub>)), for each t<sub>i</sub> &in;U}；<br>M中最大的任务分配给对应的机器，之后将该任务移除，重复该步骤直到U为空。</td>
<td align="left">最小化由于执行长任务而带来的延迟。比如：当有很多短任务和一个很长的任务，Min-Min会由于最后执行长任务而带来极大的开销，这时Max-Min算法会更优。</td>
<td align="left">其他时候调度策略都不够好。短任务的等待时间过长。</td>
</tr>
<tr>
<td align="center">Duplex</td>
<td align="left">会同时执行Min-Min和Max-Min，然后选择更好的一个</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="center">Round-Robin(RR)</td>
<td align="left">Round-Robin 算法将负载均匀的发放给各个节点。当使用这个算法时，调度器会循环的将VM分配给节点。比如：3个节点，第一个请求到达时，分配给第一个节点，第二个请求到达时，分配给第二个节点，第三个请求到达时分配给第三个节点，第四个请求到达时又分配给第一个节点，以此类推。</td>
<td align="left">能均匀的利用所有的资源，保障了公平性</td>
<td align="left">没有考虑任务的执行时间和资源使用情况。</td>
</tr>
<tr>
<td align="center">Power Save Algorithm</td>
<td align="left">在调度器分配了VM后，检查是否有空闲的节点，有的话就关掉。等到有请求需要分配到该节点时，再打开该节点。</td>
<td align="left">考虑能耗问题</td>
<td align="left"></td>
</tr>
<tr>
<td align="center">Genetic Algorithms (GA)</td>
<td align="left">initial population genetation;<br>evaluation;<br>while(stopping criteria not met){<br>&emsp;selection;<br>&emsp;crossover;<br>&emsp;mutation;<br>&emsp;evaluation;<br>}<br>output best solution;<br>具体算法可以参考<a href="/p/e830ed97.html" title="Genetic Algorithm">Genetic Algorithm</a></td>
<td align="left">Genetic Algorithms (GAs) are a technique used for searching large solution spaces.  GA usually found the best mappings of all 11 heuristics.</td>
<td align="left">调度时间长</td>
</tr>
<tr>
<td align="center">Simulated Annealing (SA)</td>
<td align="left">具体算法可以参考<a href="/p/ba79e3d5.html" title="Simulated Annealing">Simulated Annealing</a></td>
<td align="left"></td>
<td align="left">可能会找到比Min-Min和GA更差的解决办法；调度时间较长</td>
</tr>
<tr>
<td align="center">Genetic Simulated Annealing (GSA)</td>
<td align="left">a combination of the GA and SA techniques . In general, GSA follows procedures similar to the GA outlined above. However, for the selection process, GSA uses the SA cooling schedule and system temperature and a simplified SA decision process for accepting or rejecting a new chromosome.</td>
<td align="left"></td>
<td align="left">调度时间长</td>
</tr>
<tr>
<td align="center">Tabu</td>
<td align="left"><img src="/p/bcc3e70e/tabu.PNG" class title="图1 tabu"><br>具体算法可以参考<a href="/p/5b9a6a68.html" title="Tabu">Tabu</a></td>
<td align="left"></td>
<td align="left">调度时间较长</td>
</tr>
<tr>
<td align="center">A*</td>
<td align="left">具体算法可以参考<a href="/p/7300a56d.html" title="A*">A*</a></td>
<td align="left"></td>
<td align="left">调度时间很长</td>
</tr>
</tbody></table>
<h3 id="总体评价："><a href="#总体评价：" class="headerlink" title="总体评价："></a>总体评价：</h3><ul>
<li>基本没有考虑能耗情况，所有的节点都是一开始就准备好，一直开启；</li>
<li>假设很多也已经不符合现在的情况，比如：现在一个节点都是多线程任务，很少一个机器一个时间只有一个任务执行；</li>
<li>很少考虑节点是否有充足的资源，这可能是因为一个时间一个机器只有一个任务，也就是说，在一个时间，机器所有的资源都会给到该任务，所以不考虑，但是，在多进程的环境下，资源问题也需要考虑；</li>
<li>不支持热迁移</li>
<li>这些算法都是静态的算法，有些还是批处理的，提前会知道很多信息。</li>
</ul>
<h2 id="论文算法"><a href="#论文算法" class="headerlink" title="论文算法"></a>论文算法</h2><h3 id="AN-ADAPTIVE-ALGORITHM-FOR-DYNAMIC-PRIORITY-BASED-VIRTUAL-MACHINE-SCHEDULING-IN-CLOUD-2"><a href="#AN-ADAPTIVE-ALGORITHM-FOR-DYNAMIC-PRIORITY-BASED-VIRTUAL-MACHINE-SCHEDULING-IN-CLOUD-2" class="headerlink" title="AN ADAPTIVE ALGORITHM FOR DYNAMIC PRIORITY BASED VIRTUAL MACHINE SCHEDULING IN CLOUD[2]"></a>AN ADAPTIVE ALGORITHM FOR DYNAMIC PRIORITY BASED VIRTUAL MACHINE SCHEDULING IN CLOUD<sup>[2]</sup></h3><h4 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: None</span><br><span class="line">Output: None</span><br><span class="line">Algorithm sched_priority</span><br><span class="line">&#123; </span><br><span class="line">	If(P1 is not set)</span><br><span class="line">		P1&#x3D;max available resource node</span><br><span class="line">		If(P1 is turned OFF)</span><br><span class="line">			Turn P1 ON</span><br><span class="line">	If(load factor of P1&lt;0.8)</span><br><span class="line">		Assign VM to P1</span><br><span class="line">	Else if(P2 is set AND load factor of P2&lt;0.8)</span><br><span class="line">		Swap P1 and P2;</span><br><span class="line">		Assign VM to P1;</span><br><span class="line">	Else</span><br><span class="line">		P2&#x3D;P1</span><br><span class="line">		P1&#x3D;current max available resource node </span><br><span class="line"> </span><br><span class="line">		If(P1 is turned OFF)</span><br><span class="line">			Turn P1 ON</span><br><span class="line">		Assign VM to P1;</span><br><span class="line">	Turn OFF all unused nodes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><p>在初始状态下，P1和P2都是没有设置的。当一个请求到达时，会判断是否设置了P1，如果没有设置P1，则将P1设置为拥有最多空闲资源的节点，如果此时该节点没有开启，则将该节点开启；之后判断P1的负载因子是否小于0.8，如果小于0.8，说明P1还能够放其他资源，就将资源放入P1对应的节点中；如果P1的负载因子大于0.8，P2被设置了且负载因子小于0.8，则交换P1和P2，将资源交给P1对应的节点；如果P2没有被设置，或者负载因子也大于0.8，则将P2设置为P1的节点，并将P1设置为当前拥有空闲资源最多的节点。最后，关掉那些没有使用的空闲节点。</p>
<h4 id="评析"><a href="#评析" class="headerlink" title="评析"></a>评析</h4><p>优点：考虑了能源问题，在有空闲节点时，能够关闭掉那些空闲的节点；可拓展性较好；给了伪代码；<br>缺点：实验简单，虚拟机的数量过少，只有10个虚拟机，实验过程省略了；缺少热迁移的考虑，即缺少任务整合的部分，那么，是否可以在此基础上增加一个任务整合的模块？即当某个主机的负载低于某个阈值，比如10%时，将主机的内容迁移到其他主机上，并将该主机关闭；资源分很多种，比如：内存，vcpu等等，不同类型一次申请的量可能不同，可能在某一负载下只能满足其中部分，不能满足全部；。</p>
<h3 id="Dynamic-Round-Robin-DRR-3"><a href="#Dynamic-Round-Robin-DRR-3" class="headerlink" title="Dynamic Round-Robin (DRR)[3]"></a>Dynamic Round-Robin (DRR)<sup>[3]</sup></h3><p>DRR是在传统RR的基础上，增加了两条规则：第一，在一个虚拟机结束时，该主机将不会接受新的虚拟机，这种状态称为“退休状态”，等该主机的所有VM都结束，关闭该主机；第二，如果主机在“退休状态”呆了足够长的时间，就将主机的所有VM热迁移到其他主机，然后将主机关闭。</p>
<h4 id="评析-1"><a href="#评析-1" class="headerlink" title="评析"></a>评析</h4><p>优点：考虑了能耗；支持live migration；<br>缺点：没有源代码；实验部分阐述过于简单，没有说明实验的环境，数据量大小，甚至过程都省略了；没有参考文献；如果同时有很多主机的虚拟机都同时结束了，那么这些主机都不能接受新的虚拟机，那么当新的虚拟机到来时，就只能轮询少量的虚拟机，这可能会使少部分的虚拟机过度使用；传统Round-Robin的问题也会发生在这里，比如：故障处理；如果虚拟机退出时，该主机有很多的虚拟机，迁移的开销就会很高。</p>
<h3 id="Power-Aware-Load-Balancing-for-Cloud-Computing（PALB）-4"><a href="#Power-Aware-Load-Balancing-for-Cloud-Computing（PALB）-4" class="headerlink" title="Power Aware Load Balancing for Cloud Computing（PALB）[4]"></a>Power Aware Load Balancing for Cloud Computing（PALB）<sup>[4]</sup></h3><h4 id="伪代码-1"><a href="#伪代码-1" class="headerlink" title="伪代码"></a>伪代码</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">balance:</span><br><span class="line">	for all active compute nodes j ∈ [m] do</span><br><span class="line">		n[j] &#x3D; current utilization of compute node j</span><br><span class="line">	end for</span><br><span class="line">	if all n[j] &gt; 75% utilization &#x2F;&#x2F;all available nodes are active</span><br><span class="line">		boot vm on most underutilized n[j]</span><br><span class="line">	end if</span><br><span class="line">	else</span><br><span class="line">		boot vm on most utilized n[j], which can also fulfill requirements</span><br><span class="line">	end else</span><br><span class="line">upscale:</span><br><span class="line">	if each n[j] &gt; 75% utilization</span><br><span class="line">		if n[j] &lt; m</span><br><span class="line">			boot compute node n[j+1]</span><br><span class="line">		end if</span><br><span class="line">	end if</span><br><span class="line">downscale:</span><br><span class="line">	if vmi idle &gt; 6 hours or user initiated shutdown</span><br><span class="line">		shutdown vmi</span><br><span class="line">	end if</span><br><span class="line">	if n[j] has no active vm</span><br><span class="line">		shutdown n[j]</span><br><span class="line">	end if</span><br></pre></td></tr></table></figure>



<h4 id="说明-1"><a href="#说明-1" class="headerlink" title="说明"></a>说明</h4><p>该算法的目标是在维持节点可用性的同时，降低能耗。该算法主要有三个过程：balance，upscale，downscale。</p>
<ul>
<li>balance过程确定虚拟机应该安装的位置。首先获取当前所有活跃节点的利用率，当所有结点的利用率都大于75%时，将虚拟机分配到利用率最低的节点，否则将虚拟机分配到利用率最高的，且可以满足需求的节点。</li>
<li>upscale过程是当所有虚拟机节点的利用率都大于75%时，创建一个新的虚拟机</li>
<li>downscale过程是当虚拟机长时间闲置时，关闭虚拟机，而当一个主机没有活跃的虚拟机时，关闭主机。</li>
</ul>
<h4 id="评析-2"><a href="#评析-2" class="headerlink" title="评析"></a>评析</h4><p>优点：实验做得比较详细，说明了实验环境和步骤；考虑了能源因素，能够将长时间未使用的虚拟机关掉，将未使用的主机关掉；资源利用率高；考虑了异质的问题<br>缺点：为考虑热迁移，即如果一个主机的负载过低，将主机的虚拟机迁移，之后关闭虚拟机；在虚拟机运行的时候，并不是满负载的，对于申请时要求的资源小于实际使用的资源的情况缺少考虑；实验部分虚拟机个数有点少，只测试了20个和30个虚拟机。</p>
<h3 id="Load-Balanced-Min-Min-Algorithm-LBMM-5"><a href="#Load-Balanced-Min-Min-Algorithm-LBMM-5" class="headerlink" title="Load Balanced Min-Min Algorithm(LBMM)[5]"></a>Load Balanced Min-Min Algorithm(LBMM)<sup>[5]</sup></h3><h4 id="伪代码-2"><a href="#伪代码-2" class="headerlink" title="伪代码"></a>伪代码</h4><p><strong>CT<sub>i</sub><sub>j</sub></strong>: completion time of task i on machines j </p>
<p><strong>ET<sub>i</sub><sub>j</sub></strong>: expected execution time of job i on resource j  </p>
<p><strong>Rj</strong>: ready time or availability time of resource j after  completing the previously assigned jobs.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for all tasks Ti </span><br><span class="line">	for all resources </span><br><span class="line">		Cij&#x3D;Eij+rj </span><br><span class="line">	do until all tasks are mapped </span><br><span class="line"> 		for each task find the earliest completion time and the resource that obtains it </span><br><span class="line">		find the task Tk with the minimum earliest completion time </span><br><span class="line">		assign task Tk to the resource Rl that gives the earliest completion time </span><br><span class="line">		delete task Tk from list</span><br><span class="line">		update ready time of resource Rl</span><br><span class="line">		update Cil for all i </span><br><span class="line">	end do </span><br><span class="line">&#x2F;&#x2F; rescheduling to balance the load</span><br><span class="line">sort the resources in the order of completion time</span><br><span class="line">for all resources R</span><br><span class="line">	Compute makespan &#x3D; max(CT(R))</span><br><span class="line">End for</span><br><span class="line">for all resources</span><br><span class="line">	for all tasks</span><br><span class="line">		find the task Ti that has minimum ET in Rj</span><br><span class="line">		find the MCT of task Ti</span><br><span class="line">		if MCT &lt; makespan</span><br><span class="line">			Reschedule the task Ti to the resource that produces it </span><br><span class="line">			Update the ready time of both resources</span><br><span class="line">		End if</span><br><span class="line">	End for</span><br><span class="line">End for</span><br><span class="line">&#x2F;&#x2F;Where MCT represents Maximum Completion Time</span><br></pre></td></tr></table></figure>

<h4 id="说明-2"><a href="#说明-2" class="headerlink" title="说明"></a>说明</h4><p>这个算法是为了解决在Min-Min算法长任务滞后带来的问题。该算法主要分成两个部分，第一部分使用传统的Min-Min算法得到一般的解决方案；第二部分对第一部分的解决方案进行重新调度，首先将所有的节点根据完成时间进行排序，然后对每个节点中的每个任务进行调度，如果再次调度后可以得到更小的最大完成时间，则将任务进行调度，并更新信息。</p>
<h4 id="评析-3"><a href="#评析-3" class="headerlink" title="评析"></a>评析</h4><p>优点：在原来Min-Min的基础上增加了重新调度的过程，降低了makespan<br>缺点：没有摆脱传统算法的限制，直接使用传统算法的假设，因此，传统算法的缺点这个方法仍然有；实验过于简单，最后资源的实验说的很含糊</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[1] Braun T D ,  Siegel H J ,  Beck N , et al. A Comparison of Eleven Static Heuristics for Mapping a Class of Independent Tasks onto Heterogeneous Distributed Computing Systems[J]. Journal of Parallel &amp; Distributed Computing, 2001, 61(6):810-837.</p>
<p>[2] Subramanian S ,  Krishna N G ,  Kumar K M , et al. An Adaptive Algorithm for Dynamic Priority Based Virtual Machine Scheduling in Cloud[J]. International Journal of Computer Science Issues, 2012, 9(6).</p>
<p>[3] Lin C C ,  Liu P ,  Wu J J . Energy-Aware Virtual Machine Dynamic Provision and Scheduling for Cloud Computing[J]. IEEE, 2011.</p>
<p>[4] Galloway J M ,  Smith K L ,  Vrbsky S S . Power Aware Load Balancing for Cloud Computing[J]. lecture notes in engineering &amp; computer science, 2011.</p>
<p>[5] Kokilavani T ,  Amalarethinam D G . Load Balanced MinMin Algorithm for Static MetaTask Scheduling in Grid Computing[J]. International Journal of Computer Applications, 2011, 20(2):42-48.</p>
]]></content>
      <tags>
        <tag>资源调度</tag>
      </tags>
  </entry>
  <entry>
    <title>sky computing</title>
    <url>/p/ac1fc4f3.html</url>
    <content><![CDATA[<p>Ion Stoica and Scott Shenker. 2021. From Cloud Computing to Sky Computing. In Workshop on Hot Topics in Operating Systems (HotOS ’21), May 31-June 2, 2021, Ann Arbor, MI, USA. ACM, New York, NY, USA, 7 pages. <a href="https://doi.org/10.1145/3458336.3465302">https://doi.org/10.1145/3458336.3465302</a></p>
<span id="more"></span>

<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>云中的服务都是有所有权的，而云服务提供商就是依靠提供这些具有所有权的服务相互区分。但是这些云服务提供商的竞争使得我们远离utility computing。</p>
<h2 id="兼容层"><a href="#兼容层" class="headerlink" title="兼容层"></a>兼容层</h2><p>兼容层把云提供的服务抽象出来，使得上层开发的应用能够在不同的云端上跑而且不需要修改。即应用可以直接调用兼容层的接口，然后应用就可以在任意云上跑。这可以类比网络上的IP层。但是，要更加广泛，更加难以定义，因为云给应用暴露了相当多的服务，因此会更像操作系统。</p>
<p>开源软件可以帮助我们更好的做好兼容层。问题是市场是否会支持这样的工作。</p>
<h2 id="云间交互层"><a href="#云间交互层" class="headerlink" title="云间交互层"></a>云间交互层</h2><p>有了兼容层，用户还需要决定在哪片云上跑应用。网络上有BGP，sky computing应该有一个云间交互层将云服务提供商从用户中抽象出来，也就是说，用户不应该知道应用跑在那一片云上（除非用户想要明确知道）。</p>
<p>The intercloud layer must allow users to specify policies about where their jobs should run, but not require users to make low-level decisions about job placement (but would allow users to do so if they desired). These policies would allow a user to express their preferences about the tradeoff between performance, availability, and cost. In addition, a user might want to avoid their application running on a datacenter operated by a competitor, or stay within certain countries to obey relevant privacy regulations. To make this more precise, a user might specify that this is a Tensorflow job, it involves data that cannot leave Germany, and must be finished within the next two hours for under a certain cost.</p>
<p>问题与挑战：</p>
<ul>
<li>服务命名模式。通过命名确定一个服务实例，元数据管理。</li>
<li>目录服务。寻找一个服务实例。维护元数据和命名信息。</li>
<li>账户和花费。</li>
</ul>
<h2 id="云间对等"><a href="#云间对等" class="headerlink" title="云间对等"></a>云间对等</h2><p>对于大数据集，数据迁移不可避免。数据在不同云提供商间迁移是需要花费的，但是，这部分的花费可能比计算资源更便宜。互惠的数据对等管理会使数据的迁移更加快速有效。</p>
<h2 id="未来"><a href="#未来" class="headerlink" title="未来"></a>未来</h2><p>希望小的云服务提供商能够采用兼容层。</p>
<p>两种类型云服务提供商。</p>
<ul>
<li>stand-alone：专有的接口。更高的margin，专有的接口有更多可以创新提高的地方。</li>
<li>commodity：使用sky computing。更低的margin，有更少可以创新提高的地方。每个云服务提供商可以专精一个方面。</li>
</ul>
]]></content>
      <tags>
        <tag>云计算论文研读</tag>
      </tags>
  </entry>
  <entry>
    <title>查询功耗，负载</title>
    <url>/p/861b9aeb.html</url>
    <content><![CDATA[<h2 id="查看CPU负载"><a href="#查看CPU负载" class="headerlink" title="查看CPU负载"></a>查看CPU负载</h2><span id="more"></span>

<h3 id="uptime"><a href="#uptime" class="headerlink" title="uptime"></a>uptime</h3><img src="/p/861b9aeb/uptime.PNG" class title="图1 uptime">

<p>这些字段显示：当前时间，系统已运行的时间，当前登录用户的数量，相应最近5、10和15分钟内的平均负载。</p>
<h3 id="w"><a href="#w" class="headerlink" title="w"></a>w</h3><img src="/p/861b9aeb/w.PNG" class title="图2 w">

<p>Linux w命令用于显示目前登入系统的用户信息。执行这项指令可得知目前登入系统的用户有哪些人，以及他们正在执行的程序。单独执行 w 指令会显示所有的用户，您也可指定用户名称，仅显示某位用户的相关信息。</p>
<h3 id="top"><a href="#top" class="headerlink" title="top"></a>top</h3><img src="/p/861b9aeb/top.PNG" class title="图3 top">

<img src="/p/861b9aeb/top1.PNG" class title="图4 top1">

<p>top命令的顶部显示与uptime命令相似的输出，这些字段显示：当前时间，系统已运行的时间，当前登录用户的数量，相应最近5、10和15分钟内的平均负载。</p>
<img src="/p/861b9aeb/top2.PNG" class title="图5 top2">

<p>任务（进程），系统现在共有457个进程，其中处于运行中的有1个，456个在休眠（sleep），stoped状态的有0个，zombie状态（僵尸）的有0个。</p>
<img src="/p/861b9aeb/top3.PNG" class title="图6 top3">

<p>这里显示不同模式下所占cpu时间百分比，这些不同的cpu时间表示：</p>
<ul>
<li><p>us, user： 运行(未调整优先级的) 用户进程的CPU时间</p>
</li>
<li><p>sy，system: 运行内核进程的CPU时间</p>
</li>
<li><p>ni，niced：运行已调整优先级的用户进程的CPU时间</p>
</li>
<li><p>wa，IO wait: 用于等待IO完成的CPU时间</p>
</li>
<li><p>hi：处理硬件中断的CPU时间</p>
</li>
<li><p>si: 处理软件中断的CPU时间</p>
</li>
<li><p>st：这个虚拟机被hypervisor偷去的CPU时间（译注：如果当前处于一个hypervisor下的vm，实际上hypervisor也是要消耗一部分CPU处理时间的）。</p>
</li>
</ul>
<img src="/p/861b9aeb/top4.PNG" class title="图6 top4">

<p>接下来两行显示内存使用率。第一行是物理内存，第二行是虚拟内存。物理内存显示如下:全部可用内存、已使用内存、空闲内存、缓冲内存。相似地，交换部分显示的是：全部、已使用、空闲和缓冲交换空间。</p>
<img src="/p/861b9aeb/top5.PNG" class title="图7 top5">

<p>PID：进程ID，进程的唯一标识符</p>
<p>USER：进程所有者的实际用户名。</p>
<p>PR：进程的调度优先级。这个字段的一些值是’rt’。这意味这这些进程运行在实时态。</p>
<p>NI：进程的nice值（优先级）。越小的值意味着越高的优先级。负值表示高优先级，正值表示低优先级</p>
<p>VIRT：进程使用的虚拟内存。进程使用的虚拟内存总量，单位kb。VIRT=SWAP+RES</p>
<p>RES：驻留内存大小。驻留内存是任务使用的非交换物理内存大小。进程使用的、未被换出的物理内存大小，单位kb。RES=CODE+DATA</p>
<p>SHR：SHR是进程使用的共享内存。共享内存大小，单位kb</p>
<p>S：这个是进程的状态。它有以下不同的值:</p>
<ul>
<li>D - 不可中断的睡眠态。</li>
<li>R – 运行态</li>
<li>S – 睡眠态</li>
<li>T – 被跟踪或已停止</li>
<li>Z – 僵尸态</li>
</ul>
<p>%CPU：自从上一次更新时到现在任务所使用的CPU时间百分比。</p>
<p>%MEM：进程使用的可用物理内存百分比。</p>
<p>TIME+：任务启动后到现在所使用的全部CPU时间，精确到百分之一秒。</p>
<p>COMMAND：运行进程所使用的命令。进程名称（命令名/命令行）</p>
<p>更多内容可以查看<a href="https://www.cnblogs.com/zhoug2020/p/6336453.html">https://www.cnblogs.com/zhoug2020/p/6336453.html</a></p>
<h2 id="压力测试工具：stress"><a href="#压力测试工具：stress" class="headerlink" title="压力测试工具：stress"></a>压力测试工具：stress</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install -y epel-release</span><br><span class="line">yum install -y stress</span><br></pre></td></tr></table></figure>

<h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;stress&#39; imposes certain types of compute stress on your system</span><br><span class="line"></span><br><span class="line">Usage: stress [OPTION [ARG]] ...</span><br><span class="line"> -?, --help         show this help statement</span><br><span class="line">     --version      show version statement</span><br><span class="line"> -v, --verbose      be verbose</span><br><span class="line"> -q, --quiet        be quiet	&#x2F;&#x2F;不显示运行信息</span><br><span class="line"> -n, --dry-run      show what would have been done</span><br><span class="line"> -t, --timeout N    timeout after N seconds</span><br><span class="line">     --backoff N    wait factor of N microseconds before work starts</span><br><span class="line"> -c, --cpu N        spawn N workers spinning on sqrt()</span><br><span class="line"> -i, --io N         spawn N workers spinning on sync()</span><br><span class="line"> -m, --vm N         spawn N workers spinning on malloc()&#x2F;free()</span><br><span class="line">     --vm-bytes B   malloc B bytes per vm worker (default is 256MB)</span><br><span class="line">     --vm-stride B  touch a byte every B bytes (default is 4096)</span><br><span class="line">     --vm-hang N    sleep N secs before free (default none, 0 is inf)</span><br><span class="line">     --vm-keep      redirty memory instead of freeing and reallocating</span><br><span class="line"> -d, --hdd N        spawn N workers spinning on write()&#x2F;unlink()</span><br><span class="line">     --hdd-bytes B  write B bytes per hdd worker (default is 1GB)</span><br><span class="line"></span><br><span class="line">Example: stress --cpu 8 --io 4 --vm 2 --vm-bytes 128M --timeout 10s</span><br><span class="line"></span><br><span class="line">Note: Numbers may be suffixed with s,m,h,d,y (time) or B,K,M,G (size).</span><br></pre></td></tr></table></figure>

<h2 id="查看CPU功耗"><a href="#查看CPU功耗" class="headerlink" title="查看CPU功耗"></a>查看CPU功耗</h2><h3 id="方法1：s-tui"><a href="#方法1：s-tui" class="headerlink" title="方法1：s-tui"></a>方法1：s-tui</h3><h4 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install python-pip stress</span><br><span class="line">pip install s-tui	&#x2F;&#x2F;python2.X</span><br><span class="line">pip3 install s-tui	&#x2F;&#x2F;python3.X</span><br></pre></td></tr></table></figure>

<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>需要root权限。需要以下命令启动：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">s-tui</span><br></pre></td></tr></table></figure>

<img src="/p/861b9aeb/s-tui.PNG" class title="图7 s-tui">

<p>s-tui里面包含cpu的功耗，温度，频率，利用率等信息。</p>
<h3 id="方法2：turbostat"><a href="#方法2：turbostat" class="headerlink" title="方法2：turbostat"></a>方法2：turbostat</h3><p>需要root权限。需要以下命令使用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">turbostat</span><br></pre></td></tr></table></figure>

<img src="/p/861b9aeb/turbostat.PNG" class title="图8 turbostat">

<p>一、turboastat可以用来查看CPU核心处在C1 C3 C6 C7状态下时间。<br>在CPU超线程的核心中，如果某个核心处于工作状态，会阻止该超线程的另一个核心进入比C1更加深入的省电模式。</p>
<p>二、turbostat可以查看CPU的温度信息。<br>CoreTmp：每个物理cpu核心的温度。<br>PkgTmp：每个物理CPU的温度。</p>
<p>三、turbostat查看CPU的忙碌状态。<br>AVG_MHz 执行周期数除以经过的时间<br>%Busy 处于“ C0”状态的时间百分比。<br>Bzy_MHz cpu繁忙时的平均时钟频率。 (in “c0” state).<br>TSC_MHz TSC在整个时间间隔内运行的平均MHz。TSC是一个64bit的寄存器，用来记录cpu的cycle个数。</p>
<p>四、查看能耗消耗位置<br>PkgWatt 整个CPU消耗的瓦特数。<br>CorWatt 核心消耗的瓦特数。<br>GFXWatt 图像部分消耗的瓦特数。<br>RAMWatt DRAM DIMMS 部分消耗的瓦特数。</p>
<p>五、查看RAPL信息<br>RAPL是Running Average Power Limit的缩写。<br>PKG_% cpu RAPL节流活动间隔的百分比。<br>RAM_% cpu RAPL节流在DRAM上处于活动状态的时间间隔的百分比。</p>
<h3 id="方法3：powertop"><a href="#方法3：powertop" class="headerlink" title="方法3：powertop"></a>方法3：powertop</h3><h4 id="安装-2"><a href="#安装-2" class="headerlink" title="安装"></a>安装</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install powertop</span><br></pre></td></tr></table></figure>

<h4 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h4><p>Powertop需要root权限。详细可以参考<a href="https://linux.cn/article-10560-1.html%E3%80%82">https://linux.cn/article-10560-1.html。</a></p>
<h3 id="方法4：MSR寄存器"><a href="#方法4：MSR寄存器" class="headerlink" title="方法4：MSR寄存器"></a>方法4：MSR寄存器</h3><p>MSR（Model Specific Register）是x86架构中的概念，指的是在x86架构处理器中，一系列用于控制CPU运行、功能开关、调试、跟踪程序执行、监测CPU性能等方面的寄存器。</p>
<h4 id="RAPL"><a href="#RAPL" class="headerlink" title="RAPL"></a>RAPL</h4><p>RAPL全称为： running average power limit<br>RAPL是x86处理器用于限制功耗、获取功耗的一组工具，rapl提供了一系列的设置接口用于限制和获取cpu的功耗以及CPU的能量消耗，而我们调用这些功能的入口就是学会读写msr寄存器。关于RAPL的操作说明，参考Intel开发者帮助手册第3卷14.9章节。</p>
<p>在RAPL中获取功耗的思路是：</p>
<ul>
<li>首先使用cpuid代码或者lscpu查看cpu是否支持msr （这个一般都支持）</li>
<li>读取MSR_RAPL_POWER_UNIT寄存器的内容，得到能量的基本计算单元。</li>
<li>读取MSR_PKG_ENERGY_STATUS寄存器的内容，用来乘以能量基本计算单元，得到具体的累积能量消耗（单位：焦耳）。</li>
<li>程序暂停一段时间。</li>
<li>再次读取MSR_PKG_ENERGY_STATUS寄存器的内容，乘以能量基本计算单元，得到累积能量消耗。</li>
<li>用第二次得到的累积能量消耗减去第一次的，除以时间，就得到了这段时间的平均功耗。</li>
</ul>
<p>详细可以参考<a href="https://blog.csdn.net/Xiaobai__Lee/article/details/100729269?spm=1001.2101.3001.6650.2&amp;utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-2.no_search_link&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-2.no_search_link">https://blog.csdn.net/Xiaobai__Lee/article/details/100729269?spm=1001.2101.3001.6650.2&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-2.no_search_link&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-2.no_search_link</a></p>
<h2 id="查看服务器功耗"><a href="#查看服务器功耗" class="headerlink" title="查看服务器功耗"></a>查看服务器功耗</h2><h3 id="ipmitool"><a href="#ipmitool" class="headerlink" title="ipmitool"></a>ipmitool</h3><h4 id="安装-3"><a href="#安装-3" class="headerlink" title="安装"></a>安装</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install -y OpenIPMI ipmitool</span><br></pre></td></tr></table></figure>

<h4 id="使用-2"><a href="#使用-2" class="headerlink" title="使用"></a>使用</h4><p>需要root权限。使用命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ipmitool -I open sdr elist</span><br></pre></td></tr></table></figure>



<p>此命令可以获取传感器中的各种监测值和该值的监测阈值，包括（CPU温度，电压，风扇转速，电源调制模块温度，电源电压等信息）。</p>
<p>使用以下命令查看功耗：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ipmitool -I open sdr elist | grep Sys_Total_Power</span><br></pre></td></tr></table></figure>

<img src="/p/861b9aeb/impi2.PNG" class title="图10 ipmi2">

<p>更多ipmitool功能可以参考<a href="https://blog.csdn.net/xinqidian_xiao/article/details/80924897%E3%80%82">https://blog.csdn.net/xinqidian_xiao/article/details/80924897。</a></p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://www.cnblogs.com/zhoug2020/p/6336453.html">https://www.cnblogs.com/zhoug2020/p/6336453.html</a></p>
<p><a href="https://blog.csdn.net/weixin_44793395/article/details/106167831">https://blog.csdn.net/weixin_44793395/article/details/106167831</a></p>
<p><a href="https://linux.cn/article-10560-1.html">https://linux.cn/article-10560-1.html</a></p>
<p><a href="https://blog.csdn.net/xinqidian_xiao/article/details/80924897">https://blog.csdn.net/xinqidian_xiao/article/details/80924897</a></p>
<p><a href="https://blog.csdn.net/Xiaobai__Lee/article/details/100729269?spm=1001.2101.3001.6650.2&amp;utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-2.no_search_link&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-2.no_search_link">https://blog.csdn.net/Xiaobai__Lee/article/details/100729269?spm=1001.2101.3001.6650.2&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-2.no_search_link&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-2.no_search_link</a></p>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Tabu</title>
    <url>/p/5b9a6a68.html</url>
    <content><![CDATA[]]></content>
      <tags>
        <tag>资源调度</tag>
      </tags>
  </entry>
  <entry>
    <title>学习网站</title>
    <url>/p/52e318f2.html</url>
    <content><![CDATA[<h2 id="Go"><a href="#Go" class="headerlink" title="Go"></a>Go</h2><span id="more"></span>

<p>Go语言圣经 <a href="http://gopl.io/">《The Go Programming Language》</a> 中文版本：<a href="http://shouce.jb51.net/gopl-zh/index.html">http://shouce.jb51.net/gopl-zh/index.html</a></p>
<h2 id="课程网站"><a href="#课程网站" class="headerlink" title="课程网站"></a>课程网站</h2><h3 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h3><p>MIT6.824：<a href="https://pdos.csail.mit.edu/6.824/">https://pdos.csail.mit.edu/6.824/</a></p>
<h2 id="benchmark"><a href="#benchmark" class="headerlink" title="benchmark"></a>benchmark</h2><p><a href="https://github.com/giltene/wrk2">wrk2</a>：a HTTP benchmarking tool based mostly on wrk</p>
<p><a href="https://github.com/brianfrankcooper/YCSB/">YCSB</a>：测试在线数据库性能，扩展性的框架</p>
<h2 id="numad"><a href="#numad" class="headerlink" title="numad"></a>numad</h2><p><a href="https://sq.sf.163.com/blog/article/177543269487403008">https://sq.sf.163.com/blog/article/177543269487403008</a></p>
<p><a href="https://sq.sf.163.com/blog/article/177542610675490816">https://sq.sf.163.com/blog/article/177542610675490816</a></p>
<p><a href="https://sq.sf.163.com/blog/article/177545938213986304">https://sq.sf.163.com/blog/article/177545938213986304</a></p>
<p><a href="https://sq.sf.163.com/blog/article/177546699501133824">https://sq.sf.163.com/blog/article/177546699501133824</a></p>
<p>源码：</p>
<h2 id="论文"><a href="#论文" class="headerlink" title="论文"></a>论文</h2><p><a href="https://dl.acm.org/">https://dl.acm.org/</a></p>
<p><a href="https://www.usenix.org/publications/proceedings">https://www.usenix.org/publications/proceedings</a></p>
<h2 id="cluster-trace"><a href="#cluster-trace" class="headerlink" title="cluster trace"></a>cluster trace</h2><p>阿里巴巴：<a href="https://github.com/alibaba/clusterdata">https://github.com/alibaba/clusterdata</a></p>
<p>Google：<a href="https://github.com/google/cluster-data">https://github.com/google/cluster-data</a></p>
]]></content>
      <tags>
        <tag>学习网站</tag>
      </tags>
  </entry>
  <entry>
    <title>Genetic Algorithm</title>
    <url>/p/e830ed97.html</url>
    <content><![CDATA[<h3 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h3><p>Genetic Algorithms 遗传算法</p>
<p>chromosome 染色体</p>
<p>Gene 基因</p>
]]></content>
      <tags>
        <tag>资源调度</tag>
      </tags>
  </entry>
  <entry>
    <title>__builtin_系列函数</title>
    <url>/p/7e0b4172.html</url>
    <content><![CDATA[<p><strong>__builtin_ffs (unsigned int x)</strong><br>返回x的最后一位1的是从后向前第几位，比如8（1000）返回4。</p>
<span id="more"></span>

<p><strong>__builtin_clz (unsigned int x)</strong><br>返回前导的0的个数。<br><strong>__builtin_ctz (unsigned int x)</strong><br>返回后面的0个个数，和__builtin_clz相对。<br><strong>__builtin_popcount (unsigned int x)</strong><br>返回二进制表示中1的个数。<br><strong>__builtin_parity (unsigned int x)</strong><br>返回x的奇偶校验位，也就是x的1的个数模2的结果。</p>
<p>这些函数都有相应的usigned long和usigned long long版本，只需要在函数名后面加上l或ll就可以了，比如 __builtin_clzll。</p>
<p>版权声明：本文为CSDN博主「Yuer-」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/yuer158462008/article/details/46383635">https://blog.csdn.net/yuer158462008/article/details/46383635</a></p>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>频率</title>
    <url>/p/f5e3c4bd.html</url>
    <content><![CDATA[<h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>假设我们需要修改cpu0的频率。</p>
<span id="more"></span>

<h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><p>首先需要进入/sys/devices/system/cpu/cpu0/cpufreq目录。该目录下文件如下图所示：</p>
<img src="/p/f5e3c4bd/cpufreq.PNG" class title="图1 cpufreq">

<p>前缀cpuinfo代表的是cpu硬件上支持的频率，而scaling前缀代表的是可以通过CPUFreq系统用软件进行调节时所支持的频率。cpuinfo_cur_freq代表通过硬件实际上读到的频率值，而scaling_cur_freq则是软件当前的设置值，多数情况下这两个值是一致的，但是也有可能因为硬件的原因，有微小的差异。</p>
<p>从图中不难发现，只有scaling_governor，scaling_max_freq，scaling_min_freq，scaling_setspeed四个文件可以编辑。首先是scaling_governor。它的取值范围在scaling_available_governors中。scaling_available_governors保存了系统支持的电源策略，conservative (保守)，powersave（节能），ondemand（请求），performance（性能），userspace模式。</p>
<img src="/p/f5e3c4bd/governor.PNG" class title="图2 governor">

<p>ondemand策略的主要思想是：只要cpu的负载超过某一个阀值，cpu的频率会立刻提升至最高，然后再根据实际情况降到合适的水平。scaling_driver则会输出当前使用哪一个驱动来设置cpu的工作频率。</p>
<p>当我们选择userspace作为我们的调频governor时，我们可以通过scaling_setspeed手工设置需要的频率。powersave则简单地使用最低的工作频率进行运行，而performance则一直选择最高的频率进行运行。</p>
<p>我们需要设定cpu0的频率，则需要将scaling_governor内写入userspace。</p>
<p>另外，scaling_setspeed是设置频率。可以选择的频率值通过scaling_available_frequencies查看。</p>
<img src="/p/f5e3c4bd/freq.PNG" class title="图3 freq">

<p>我们需要设定cpu0的频率，则需要将scaling_setspeed内写入需要的频率。</p>
<p>所以需要修改cpu0的频率，只需要执行以下指令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo userspace &gt; scaling_governor</span><br><span class="line">echo 1100000 &gt; scaling_setspeed</span><br></pre></td></tr></table></figure>

<p>修改完毕后，执行s-tui查看结果。</p>
<img src="/p/f5e3c4bd/result.PNG" class title="图3 result">

<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://blog.csdn.net/zhangyongfeiyong/article/details/53506362">https://blog.csdn.net/zhangyongfeiyong/article/details/53506362</a></p>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Simulated Annealing</title>
    <url>/p/ba79e3d5.html</url>
    <content><![CDATA[]]></content>
      <tags>
        <tag>资源调度</tag>
      </tags>
  </entry>
  <entry>
    <title>SGX 知识总结（一）</title>
    <url>/p/8cd79317.html</url>
    <content><![CDATA[<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><span id="more"></span>

<a href="/p/ccbadbc2.html" title="SGX创建过程">SGX创建过程</a>
]]></content>
      <tags>
        <tag>SGX</tag>
      </tags>
  </entry>
  <entry>
    <title>SGX创建过程</title>
    <url>/p/ccbadbc2.html</url>
    <content><![CDATA[<span id="more"></span>

<h2 id="ECREATE"><a href="#ECREATE" class="headerlink" title="ECREATE"></a>ECREATE</h2><h2 id="EADD-EXTEND"><a href="#EADD-EXTEND" class="headerlink" title="EADD/EXTEND"></a>EADD/EXTEND</h2><h2 id="EINIT"><a href="#EINIT" class="headerlink" title="EINIT"></a>EINIT</h2>]]></content>
      <tags>
        <tag>SGX</tag>
      </tags>
  </entry>
</search>
