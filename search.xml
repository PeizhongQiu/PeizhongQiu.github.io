<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Dash: Scalable Hashing on Persistent Memory</title>
    <url>/p/6ab0c77.html</url>
    <content><![CDATA[<h2 id="dash-bucket结构"><a href="#dash-bucket结构" class="headerlink" title="dash bucket结构"></a>dash bucket结构</h2><p>Dash的总体结构如图1所示。从图中可以看出，该结构和CCEH同样采取了可拓展的哈希结构，并且同样有三个层次，一个是Directory层，一个是Segment层，一个是Bucket层。不同的是，每个Segment层除了正常的Bucket外，还有Stash buckets用来存储冲突的键值对。根据论文，一个Segment层的Stash buckets数量为2或4。另外，在Directory层有三个主要变量，Lock是锁，Version用来做版本控制，Clean用来判断系统的关闭是否是干净的。</p>
<span id="more"></span>

<img src="/p/6ab0c77/dash_architecture.PNG" class title="图1 Dash总体结构">

<p>图2是bucket层的具体结构。从图中可知，一个bucket就只存储14个键值对，一个键值对16个字节。另外，每个bucket有32字节的元数据，其中包括4字节的版本锁，根据代码可知，最高位是互斥锁，后面31位作为版本号进行版本控制；接着的counter是用来计算bucket中有多少个键值对；membership是一个位图，用来显示那些不是直接索引到该bucket中的键值对；Alloc.bitmap也是一个位图，用来显示该bucket中的全部键值对；接下来是18个fingeprint，每个fingerprint是1字节，所谓的fingerprint是哈希值的后8位，通过fingerprint可以大量减少NVM读的次数，有一点值得注意，一个bucket只有14个键值对，但是却有18个fingerprint，这是stash bucket中在本bucket溢出的键值对的fingerprint；overflow fingerprint bitmap是4位，判断溢出的对应的fingerprint是否被占用；overflow bit用来判断这个bucket是否有溢出的键值对，stash bucket index用来判断fingerprint对应的键值对在哪个bucket；overflow membership用来判断溢出的键值对是否直接索引到该bucket ；overflow count表示直接对应该bucket的键值对却无法插入到该bucket和下一个bucket的键值对数量，注意overcount不包括那些在bucket或下一个bucket有存储fingerprint的键值对。</p>
<img src="/p/6ab0c77/dash_bucket.PNG" class title="图2 bucket结构">

<h2 id="dash实现细节"><a href="#dash实现细节" class="headerlink" title="dash实现细节"></a>dash实现细节</h2><p>每个Segment有64个bucket，因此可以根据6位来确定bucket的位置。哈希值最后8位是作为fingerprint，最后9到14位来确定bucket位置。</p>
<h3 id="dash-insert"><a href="#dash-insert" class="headerlink" title="dash insert"></a>dash insert</h3><p>最上层的伪代码如图3所示。首先，是判断键值是否已经存在，如果存在，则直接返回。其次，如果target_bucket和probing_bucket都未满，为了让两者负载均衡，会插入到两者数量较少的一边；如果两者都满了，则会判断target和probing target中是否有可以移动的键值对，即在target中属于前一个bucket的键值对，且前一个bucket有空余的位置，则将其中一个插入到前一个bucket，或者probe target中属于probe target的键值对，且后一个bucket有空余的位置，则将其中一个插入到前一个bucket。最后，如果没有空闲的位置，则插入到stash中，并设置target的overflow为1，如果stash中也没有空余的位置，则分裂。接下来，对其中的有些细节进行补充。</p>
<img src="/p/6ab0c77/insert_top.PNG" class title="图3 dash insert伪代码">

<h3 id="key-exists"><a href="#key-exists" class="headerlink" title="key exists"></a>key exists</h3><p>根据源代码，首先是在target_bucket和probing_bucket中寻找是否存在相同的键值，这个部分可以利用fingerprint大量减少读的次数，并且，fingerprint可以使用SSE加速，另外，在源代码中，对14位每位进行判断的时候，使用了循环展开的方法降低开销；之后，判断是否需要去stash中查找，判断是否要在stash中查找要依次查看overflow bit是否为0，overcount是否为0，overflowBit与overflow fingerprint与overflow membership的关系，不满足则要对stash进行搜索。</p>
<h3 id="bucket-insert"><a href="#bucket-insert" class="headerlink" title="bucket insert"></a>bucket insert</h3><p>首先找到空闲的键值对，这可以利用bitmap进行位运算得到。接着插入，并设置标志位。由于clflush一次刷新一个cacheline，一个cacheline为64字节，所以所有的元数据都可以在一次刷新中刷入。</p>
<h3 id="split"><a href="#split" class="headerlink" title="split"></a>split</h3><p>Split过程基本与CCEH相似。重点说明几点不同之处：第一，分裂的时候，dash要将所有bucket的锁都上锁，第二，dash在分裂时候的正确性由libpmemobj的事务保障，这保证分裂出去的Segment在程序崩溃之后能够回收成功。</p>
<h3 id="search"><a href="#search" class="headerlink" title="search"></a>search</h3><p>search伪代码如图4所示。从伪代码中，可以看出，在搜索的过程中并没有使用锁。dash采用乐观锁的方式大大提高并行环境下的搜索效率。在搜索之前，判断bucket是否上锁；在搜索完成后，dash通过检查bucket的版本是否与之前读取的一致来判断search的过程中是否有进程对bucket进行修改，如果有，则会重新读取。另外，由于fingerprint的存在，大大减少了读的次数。</p>
<img src="/p/6ab0c77/dash_search.PNG" class title="图4 dash search伪代码">

<h2 id="dash-与-cceh评测"><a href="#dash-与-cceh评测" class="headerlink" title="dash 与 cceh评测"></a>dash 与 cceh评测</h2><h3 id="cceh改写"><a href="#cceh改写" class="headerlink" title="cceh改写"></a>cceh改写</h3><p>dash的作者对cceh进行了改写，首先在insert上，作者增加了判断新增的键值对是否存在的判断，由于cceh没有此方面的实现，所以作者相当于搜索了一次；另外，在split的过程中，作者将cceh的分裂用libpmemobj的事务进行处理。</p>
<h3 id="单线程比较"><a href="#单线程比较" class="headerlink" title="单线程比较"></a>单线程比较</h3><p>对于key大小大于8字节的键值对来说，由于每次读取键值都需要先读指针，再读key，这就体现了fingerprint的优越性，fingerprint大大减少了读的次数。</p>
<img src="/p/6ab0c77/re1.PNG" class title="图5 单线程">

<h3 id="多线程比较"><a href="#多线程比较" class="headerlink" title="多线程比较"></a>多线程比较</h3><img src="/p/6ab0c77/re2.PNG" class title="图6 多线程">

<h3 id="负载因子"><a href="#负载因子" class="headerlink" title="负载因子"></a>负载因子</h3><img src="/p/6ab0c77/re3.PNG" class title="图7 负载因子">

<h2 id="dash代码运行环境要求"><a href="#dash代码运行环境要求" class="headerlink" title="dash代码运行环境要求"></a>dash代码运行环境要求</h2><p>源代码地址 <a href="https://github.com/baotonglu/dash.git">https://github.com/baotonglu/dash.git</a><br>linux 内核版本4.17之后<br>glibc 版本2.29之后</p>
]]></content>
      <tags>
        <tag>NVM论文研读</tag>
      </tags>
  </entry>
  <entry>
    <title>User-Defined Cloud</title>
    <url>/p/aeabe00a.html</url>
    <content><![CDATA[<p>Yiying Zhang, Ardalan Amiri Sani, and Guoqing Harry Xu. 2021. User-Defined Cloud. In Workshop on Hot Topics in Operating Systems (HotOS ’21), May 31–June 2, 2021, Ann Arbor, MI, USA. ACM, New York, NY, USA, 8 pages. <a href="https://doi.org/10.1145/3458336.3465304">https://doi.org/10.1145/3458336.3465304</a></p>
<span id="more"></span>

<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>云使用者问题：</p>
<ul>
<li>多花费35%的前在不需要的计算资源上。因为没有云服务能够匹配他们精确的需求。</li>
<li>部分领域的使用者不能在云上跑他们的负载。</li>
<li>安全问题。</li>
</ul>
<p>云服务提供商问题：</p>
<ul>
<li>新硬件部署和安全功能增加</li>
<li>兼容问题</li>
</ul>
<p>原因就是云提供商定义和管理云去满足用户的需求。</p>
<p>主张用户定义云，云服务提供商创建和管理云。</p>
<p>User-Define Cloud(UDC)，用户可以定义硬件资源，执行环境，安全需要，系统功能。细粒度方式定义</p>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>用户：</p>
<ul>
<li>根据需要，自定义整个从软件到硬件的栈结构。</li>
<li>只需要支付他们需要的资源和功能</li>
<li>安全自定义</li>
</ul>
<p>提供商：</p>
<ul>
<li>独立的增加和删除软硬件功能。</li>
<li>更多的用户</li>
<li>更多的钱</li>
</ul>
<h2 id="UDC提议"><a href="#UDC提议" class="headerlink" title="UDC提议"></a>UDC提议</h2><p>三个原则：</p>
<ul>
<li>Expressing definitions of low-level layers as runtime aspects.  </li>
<li>Decouple specifications from their realization and decouple different aspects.</li>
<li>Fine granularity at each layer.</li>
</ul>
]]></content>
      <tags>
        <tag>云计算论文研读</tag>
      </tags>
  </entry>
  <entry>
    <title>linux 内核参考资料</title>
    <url>/p/f16f5a0d.html</url>
    <content><![CDATA[<h2 id="attribute"><a href="#attribute" class="headerlink" title="__attribute__"></a>__attribute__</h2><span id="more"></span>

<p><a href="https://gcc.gnu.org/onlinedocs/gcc-4.0.0/gcc/Function-Attributes.html#Function-Attributes">https://gcc.gnu.org/onlinedocs/gcc-4.0.0/gcc/Function-Attributes.html#Function-Attributes</a></p>
<p><a href="https://gcc.gnu.org/onlinedocs/gcc-4.0.0/gcc/Type-Attributes.html#Type-Attributes">https://gcc.gnu.org/onlinedocs/gcc-4.0.0/gcc/Type-Attributes.html#Type-Attributes</a></p>
<p><a href="https://gcc.gnu.org/onlinedocs/gcc-4.0.0/gcc/Variable-Attributes.html#Variable-Attributes">https://gcc.gnu.org/onlinedocs/gcc-4.0.0/gcc/Variable-Attributes.html#Variable-Attributes</a></p>
<h2 id="percpu"><a href="#percpu" class="headerlink" title="percpu"></a>percpu</h2><p><a href="https://zhuanlan.zhihu.com/p/260986194">https://zhuanlan.zhihu.com/p/260986194</a></p>
<h2 id="kvm-shared-msrs"><a href="#kvm-shared-msrs" class="headerlink" title="kvm_shared_msrs"></a>kvm_shared_msrs</h2><p><a href="https://oenhan.com/kvm_shared_msrs">https://oenhan.com/kvm_shared_msrs</a></p>
<h2 id="slab-内存分配"><a href="#slab-内存分配" class="headerlink" title="slab 内存分配"></a>slab 内存分配</h2><p><a href="https://zhuanlan.zhihu.com/p/105582468">https://zhuanlan.zhihu.com/p/105582468</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/106106008">https://zhuanlan.zhihu.com/p/106106008</a></p>
<h2 id="CPU-hotplug"><a href="#CPU-hotplug" class="headerlink" title="CPU hotplug"></a>CPU hotplug</h2><p><a href="https://www.kernel.org/doc/html/latest/core-api/cpu_hotplug.html">https://www.kernel.org/doc/html/latest/core-api/cpu_hotplug.html</a></p>
]]></content>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>cpuidle</title>
    <url>/p/e0428171.html</url>
    <content><![CDATA[<h2 id="逻辑-CPU"><a href="#逻辑-CPU" class="headerlink" title="逻辑 CPU"></a>逻辑 CPU</h2><span id="more"></span> 

<p>​        在 CPU 任务调度器看来 CPU 空闲时间管理是直接作用在 CPU 上的。在它看来，CPU 是一个逻辑单元。也就是说，CPU 不必是单独的物理实体，而可能只是一个对软件表现为单独的单核处理器的接口。 换句话说，CPU 是一个实体，它表现为正在从内存中获取属于一个程序的指令并执行它们，但它在物理上不需要以这种方式工作。 一般来说，这里可以考虑三种不同的情况。</p>
<ul>
<li><p>如果整个处理器一次只能执行一个指令序列，那么整个处理器就是一个 CPU。 在这种情况下，如果要求硬件进入空闲状态，整个处理器都将进入空闲状态。</p>
</li>
<li><p>如果处理器是多核的，每个核一次至少能够执行一个程序。核之间不需要完全相互独立（例如，它们可能共享缓存），但大多数时候它们仍然在物理上彼此并行工作，因此如果每一个核只执行一个程序，那么这些程序大部分彼此独立运行。在这种情况下，每个核都是一个 CPU，如果要求硬件进入空闲状态，首先请求它的核将进入空闲状态，但更大的单元也可能进入空闲状态，即，如果较大单元中除一个之外的所有核都已在“核级别”处于空闲状态，当这个核要求处理器进入空闲状态，则可能会将整个较大单元置于空闲状态，这也会影响该单元中的其他核。</p>
</li>
<li><p>如果多核处理器中的每个核能够在同一时间范围内执行多个程序（也就是说，每个核可能能够从内存中的多个位置获取指令并在同一时间范围内执行它们）。在这种情况下，核以“捆绑”的形式呈现给软件，每个“捆绑”由多个单独的单核处理器组成，称为硬件线程（或英特尔硬件上的超线程），每个都可以遵循一个指令序列。然后，从 CPU 空闲时间管理的角度来看，硬件线程是 CPU，如果其中一个请求处理器进入空闲状态，则请求它的硬件线程（或 CPU）将停止，但不会再发生任何事情，除非同一核中的所有其他硬件线程也要求处理器进入空闲状态。在这种情况下，核可能会单独进入空闲状态，或者包含它的较大单元可能会整体进入空闲状态（如果较大单元中的其他核已经处于空闲状态）。</p>
</li>
</ul>
<h2 id="空闲-CPU"><a href="#空闲-CPU" class="headerlink" title="空闲 CPU"></a>空闲 CPU</h2><p>​        当一个 CPU 没有可以运行的任务时，称这个 CPU 是空闲的。换个说法，linux 内核中定义了一系列内部调度类，如果除了空闲类之外，没有任何任务在给定的 CPU 上运行，则该 CPU 就是空闲的。如果硬件不能允许 CPU 上不运行任何指令，则 CPU 必须要运行一些无用的指令直到 CPU 真正被工作需要。但是这浪费电，所以大多数 CPU 支持一些低功耗状态，内核可以将它们置为这些状态，直到需要 CPU 做有用的工作。</p>
<p>​        空闲状态的进入和退出不是没有代价的。进入和退出都需要一些时间，而且，在进入空闲状态，功耗会短暂地略高于空闲状态前的状态的正常值，在退出空闲状态时，功耗也会短暂地略高于退出空闲时的目标状态的正常值。随着空闲状态的不断加深，CPU 消耗越来越少的功耗，但是进入和退出空闲状态的开销也会越来越大。这意味着对于较短的空闲时间，相当浅的空闲状态是系统资源的最佳利用； 对于更长的空闲时间，更深的空闲状态的成本将通过空闲时节省的功率来抵消。 因此，在决定空闲深度之前需要预测 CPU 空闲多长时间。 这是空闲循环的工作。</p>
<h2 id="空闲循环（idle-loop）"><a href="#空闲循环（idle-loop）" class="headerlink" title="空闲循环（idle loop）"></a>空闲循环（idle loop）</h2><p>​        空闲循环在它的每次迭代中都需要两个主要步骤。首先，它调用属于 CPU 空闲时间管理子系统 CPUIdle 的称为 governor 的代码模块，为 CPU 选择一个空闲状态以请求硬件进入。其次，它调用来自 CPUIdle 子系统的另一个代码模块 driver，以实际要求处理器硬件进入由 governor 选择的空闲状态。</p>
<p>​        governor 的作用是找到最适合当前条件的空闲状态。为此，逻辑 CPU 可以要求硬件进入的空闲状态以独立于平台或处理器架构的抽象方式表示，并以一维（线性）数组的形式组织。在内核初始化时，与内核运行平台相匹配的 CPUIdle driver 会准备和提供该数组。这允许 CPUIdle governor 独立于底层硬件并可以与 Linux 内核运行的任何平台一起工作。</p>
<p>​        该数组中的每个空闲状态有两个参数会成为 governor 考虑的对象：目标驻留（target residency）和（最坏情况）退出延迟（exit latency）。目标驻留时间是硬件必须在给定状态中花费的最短时间，包括进入它所需的时间（可能很长）。只有花费比目标驻留时间长，才能比通过进入较浅的空闲状态节省更多的能量。 [空闲状态的“深度”大致对应于处理器在该状态下消耗的功率。] 退出延迟是要求处理器硬件进入空闲状态的 CPU 从空闲状态被唤醒到开始执行第一条指令所需的最长时间。请注意，通常退出延迟还必须包含进入给定状态所需的时间。万一在硬件进入空闲状态时发生唤醒，必须完全进入空闲状态后才能退出。</p>
<p>​        有两种类型的信息可以影响 governor 的决定。首先，governor 知道距离最近的计时器事件的时间。那个时间是确切知道的，因为内核对计时器进行编程，并且它确切知道它们何时会触发，这是给定 CPU 所依赖的硬件可以处于空闲状态的最长时间，包括进入和退出它所需的时间。但是，CPU 可能随时被非定时器事件唤醒（特别是在最近的定时器触发之前），并且通常不知道何时会发生这种情况。governor只能看到 CPU 在被唤醒后实际空闲了多少时间（从现在开始，该时间将被称为空闲持续时间（idle duration）），并且它可以以某种方式使用该信息以及直到最近的计时器的时间估计未来的空闲时间。governor 如何使用该信息取决于它所实现的算法，这是在 CPUIdle 子系统中拥有多个 governor 的主要原因。</p>
<p>​        有四个可用的 CPUIdle governors：menu、TEO、ladder 和 haltpoll。默认情况下使用哪一个取决于内核的配置，特别是空闲循环是否可以停止调度程序 tick。可用的 governor 可以从 available_governors 中读取，并且governor 可以在运行时更改。内核当前使用的 CPUIdle governor的名称可以从 sysfs 中 /sys/devices/system/cpu/cpuidle/ 下的 current_governor_ro 或 current_governor 文件中读取。</p>
<p>​        另一方面，使用哪个 CPUIdle driver 通常取决于内核运行的平台，但有些平台有多个匹配的驱动程序。例如，有两个驱动程序可以与大多数英特尔平台一起使用，intel_idle 和 acpi_idle，一个具有硬编码的空闲状态信息，另一个能够分别从系统的 ACPI 表中读取该信息。尽管如此，即使在这些情况下，在系统初始化时选择的驱动程序也不能在以后替换，因此必须尽早决定使用其中的一个。内核当前使用的CPUIdle driver 的名称可以从sysfs中/sys/devices/system/cpu/cpuidle/下的current_driver文件中读取。</p>
<h2 id="空闲-CPU-和调度器-tick"><a href="#空闲-CPU-和调度器-tick" class="headerlink" title="空闲 CPU 和调度器 tick"></a>空闲 CPU 和调度器 tick</h2><p>​        CPU 调度程序的 tick 使这项工作变得特别困难。这是一个由 CPU 调度器运行的定时器，目的是分时 CPU：如果你要在单个 CPU 上运行多个任务，每个任务只能运行一段时间，然后定期搁置做另一份任务。tick 不需要在空闲的 CPU 上运行，因为没有应该共享 CPU 的任务。此外，如果允许 tick 在原本空闲的 CPU 上运行，它将通过限制 CPU 可能保持空闲的时间来禁止 governor 选择深度空闲状态。所以在内核 4.16 和更早版本中，调度程序在调用 governor 之前禁用 tick。当 CPU 被中断唤醒时，调度程序会决定是否有工作要做，如果有，则重新激活 tick。</p>
<p>​        如果 governor 预测到长时间空闲，并且空闲时间也的确是长，则 governor 获胜：CPU 将进入深度空闲状态并节省电量。但是，如果 governor 预测长时间闲置而空闲时间很短，那么 governor 会失败，因为进入深度空闲状态的成本不会通过短时间空闲状态的节电来弥补。更糟糕的是，如果 governor 预测空闲时间较短，无论实际空闲状态持续时间多长，它都会失败：如果空闲状态实际持续时间很长，则错过了潜在的节能效果；如果时间很短，则停止和重新启动 tick 的成本又被不必要地支付，即因为停止和启动 tick 是有代价的，如果 governor 预测短暂的空闲，停止 tick 是没有意义的。</p>
<p>​        Wysocki 考虑尝试重新设计 governor 来解决这个问题，但得出的结论是，基本问题是在调用 governor 之前停止 tick，即在获得预测的空闲状态之前就停止了 tick。因此，他为内核 4.17 重新设计了空闲循环：governor 预测空闲状态之后再做出停止 tick 的决定。如果预测长时间空闲，则停止 tick，以免过早唤醒 CPU。如果建议是短时间空闲，tick 则保持开启状态以避免关闭它的成本。这意味着 tick 是一个 safety net，如果空闲时间比预期的长，它会唤醒 CPU，并给 governor 另一个机会来让它正确。</p>
<p>​        当空闲的 CPU 被中断唤醒时，无论是从保持运行的 tick 还是其他事件，调度程序立即决定是否有工作要做。如果有，则在需要时重新启动滴答；但如果没有，则立即重新调用 governor。由于现在可以在 tick 运行和停止时调用 governor，因此必须重新设计调控器以考虑到这一点。</p>
<p>​        重新检查之前的赢/输表，Wysocki 预计这次返工会改善情况。如果预测到长时间空闲，tick 仍然停止，所以没有任何变化：如果实际空闲时间长，我们就赢了，如果实际空闲时间短，我们就输了。但是如果预测到短空闲，我们会更好：如果实际空闲很短，我们就节省了停止和重新启动 tick 的成本；如果实际空闲很长，未停止的计时器将唤醒 governor，并再次预测。</p>
<p>​        Wysocki 在许多系统上对此进行了测试。上图是所有测试系统的特征，显示了空闲系统上的功耗与时间的关系。绿线是旧的空闲循环，红线是新的：新方案下的功耗更低，而且比以前更可预测。并非所有测试的 CPU 都显示绿线和红线之间的差距如此之大，但所有 CPU 都在凹凸不平的绿线下方显示了一条平坦的红线。正如 Wysocki 所说，与旧方案相比，这种新方案预测短的空闲时间的频率更低，但它们预测为短空闲时间正确的概率更高。</p>
<p>​        内核可以配置为完全禁止在空闲循环中停止 tick。 这可以通过取消设置 CONFIG_NO_HZ_IDLE 配置选项或通过在命令行中传递 nohz=off 来完成。 在这两种情况下，由于 tick 的停止被禁用，空闲循环代码简单地忽略了governor 的决定，并且 tick 永远不会停止。</p>
<p>​        运行配置为允许在空闲 CPU 上停止 tick 的内核的系统称为 tickless 系统，它们通常被认为比运行无法停止 tick 的内核的系统更节能。 如果给定的系统是 tickless 的，它将默认使用 menu，如果它不是 tickless，则其上的默认 CPUIdle 调控器将是 ladder。</p>
<h2 id="menu-governor"><a href="#menu-governor" class="headerlink" title="menu governor"></a>menu governor</h2><p>​        menu governor 是 tickless 的默认 CPUIdle 系统。它相当复杂，但其设计的基本原理十分直接，当它为 CPU 选择空闲状态时，它会尝试预测空闲持续时间并使用预测值进行空闲状态选择。</p>
<p>​        menu governor 首先获取到最近的计时器事件的时间，并假设调度程序 tick 将停止。该时间，在下文中称为睡眠时长，是下一次 CPU 唤醒前的时间上限。它用于确定睡眠长度范围，进而获得睡眠长度校正因子。</p>
<p>​        menu governor 维护两个睡眠长度校正因子数组。其中一个用于先前在给定 CPU 上运行的任务正在等待某些 I/O 操作完成时使用，而另一个则用在其他情况。每个数组包含多个校正因子值，这些值对应于不同的睡眠长度范围，数组中表示的每个范围都比前一个范围宽大约 10 倍。</p>
<p>​        给定睡眠长度范围的校正因子（在为 CPU 选择空闲状态之前确定）在 CPU 被唤醒后更新，睡眠长度越接近观察到的空闲持续时间，校正因子越接近 1 （它必须介于 0 和 1 之间）。睡眠长度乘以它落入的范围的校正因子以获得预测空闲持续时间的第一近似值。</p>
<p>接下来，调控器使用简单的模式识别算法来改进其空闲时间预测。也就是说，它保存最后 8 个观察到的空闲持续时间值，并在下次预测空闲持续时间时，计算它们的平均值和方差。如果方差较小（小于 400 平方毫秒）或相对于平均值较小（平均值大于标准差的 6 倍），则将平均值视为“典型区间”值。否则，将丢弃保存的最长观察空闲持续时间值，并对剩余的值重复计算。同样，如果它们的方差很小（在上述意义上），则将平均值作为“典型区间”值，依此类推，直到确定“典型区间”或忽略太多数据点，其中假设“典型区间”等于“无穷大”（最大无符号整数值）。以这种方式计算的“典型间隔”与睡眠长度乘以校正因子进行比较，并将两者中的最小值作为预测的空闲持续时间。</p>
<p>然后，调控器计算额外的延迟限制以帮助“交互式”工作负载。它使用观察，如果所选空闲状态的退出延迟与预测的空闲持续时间相当，则在该状态中花费的总时间可能会非常短，并且进入该状态所节省的能量将相对较小，所以可能最好避免与进入该状态和退出该状态相关的开销。因此，选择较浅的状态可能是一个更好的选择。额外延迟限制的第一个近似值是预测的空闲持续时间本身，它另外除以一个值，该值取决于先前在给定 CPU 上运行的任务数，现在它们正在等待 I/O 操作完成。将该划分的结果与来自电源管理服务质量或 PM QoS 框架的延迟限制进行比较，并将两者中的最小值作为空闲状态退出延迟的限制。</p>
<p>现在，governer 已准备好遍历空闲状态列表并选择其中一个。为此，它将每个状态的目标驻留时间与预测的空闲持续时间以及它的退出延迟与计算的延迟限制进行比较。它选择目标驻留时间最接近预测的空闲持续时间但仍低于它的状态，并且退出延迟不超过限制。</p>
<p>在最后一步，如果调控器尚未决定停止调度程序滴答，则调控器可能仍需要细化空闲状态选择。如果它预测的空闲持续时间小于滴答周期并且滴答尚未停止（在空闲循环的先前迭代中），则会发生这种情况。然后，在之前的计算中使用的睡眠长度可能直到最近的计时器事件才反映实时，如果它确实大于那个时间，则调控器可能需要选择一个具有合适目标驻留的较浅状态。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://lwn.net/Articles/767630/">https://lwn.net/Articles/767630/</a></p>
<p><a href="https://www.kernel.org/doc/html/latest/admin-guide/pm/cpuidle.html">https://www.kernel.org/doc/html/latest/admin-guide/pm/cpuidle.html</a></p>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>cpu利用率</title>
    <url>/p/357e56ad.html</url>
    <content><![CDATA[<h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>写一个程序，让用户来决定 Windows 任务管理器的CPU占用率。程序越精简越好，语言不限。比如：</p>
<ul>
<li><p>CPU占用率固定在50%，为一条直线；</p>
</li>
<li><p>CPU占用率为一条直线，但是具体占用率由用户决定（参数范围1-100）；</p>
</li>
<li><p>CPU占用率状态是正弦曲线。</p>
<span id="more"></span></li>
</ul>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>在任务管理器的一个刷新周期里，CPU忙（执行应用程序）的时间和刷新周期总时间比率就是CPU的占用率，也就是说，任务管理器中显示的是每个刷新周期内CPU占用率的统计平均值。因此，可以写一个程序，让他在任务管理器的刷新期间内一会儿忙，一会儿闲，然后通过调节忙/闲的比例，就可以控制任务管理器中显示的CPU占用率。</p>
<h3 id="解法1"><a href="#解法1" class="headerlink" title="解法1"></a>解法1</h3><p>由于现在使用的windows电脑一般是多核，为了能够让程序能够在单个cpu上运行，可以在<font color="#FF0000">任务管理器</font>中<font color="#FF0000">详细信息</font>栏选中运行的程序，右键点击，选择<font color="#FF0000">设置相关性</font>，并在跳出的界面里选择程序运行所在的cpu。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(;;);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>首先查看死循环的CPU资源利用率。从图中可以发现，cpu的利用率达到了100%。</p>
<img src="/p/357e56ad/cpu1.PNG" class title="图1 cpu1">

<p>对上面的代码进行修改。增加sleep函数。现在我使用的电脑的cpu主频是1.60GHz，即每秒1.6*10<sup>9</sup>时钟周期。假设每个时钟周期运行两条代码。循环转换成汇编大约5条指令。于是，cpu一秒就可以运行(1.6*10<sup>9</sup>*2) / 5 = 3.2*10<sup>8</sup>个循环。于是，我们写了第二版代码。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(;;)&#123;</span><br><span class="line">		<span class="keyword">int</span> i;</span><br><span class="line">		<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">320000000</span>; i++);</span><br><span class="line">		Sleep(<span class="number">1000</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>运行结果下图所示。我们可以看到呈现为锯齿状，这是因为CPU工作一秒，休息一秒。而我们的刷新周期是小于一秒的，所以会呈现这样的曲线。</p>
<img src="/p/357e56ad/cpu2.PNG" class title="图2 cpu2">

<p>显然，这不符合我们的要求，我们尝试增加循环的频率，将320000000和1000降低两个数量级。注意，sleep时间不能太小，太小会造成线程频繁挂起和唤醒，无形中增加了内核时间的不确定性因素。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(;;)&#123;</span><br><span class="line">		<span class="keyword">int</span> i;</span><br><span class="line">		<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">3200000</span>; i++);</span><br><span class="line">		Sleep(<span class="number">10</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>从下图中可以看出cpu占用率在60左右浮动。通过不断调整3200000参数，就能在一条指定的机器上获得一条大致稳定的50%CPU占用率曲线。</p>
<img src="/p/357e56ad/cpu3.PNG" class title="图3 cpu3">

<p>经过一番调试之后，最终参数大约为2400000，最终效果图如下图所示。</p>
<img src="/p/357e56ad/cpu4.PNG" class title="图3 cpu4">

<p>使用这种方法，有两点注意：</p>
<ul>
<li><p>尽量减少sleep/awake频率，减少操作系统内核调度程序的干扰。</p>
</li>
<li><p>尽量不要调用system call，因为这也会导致很多不可控的内核运行时间。</p>
</li>
</ul>
<p>该方法有个很严重的问题：不能适应机器差异性。一旦换了CPU，必须要重新评估。</p>
<h3 id="解法2"><a href="#解法2" class="headerlink" title="解法2"></a>解法2</h3><p>GetTickCount()可以获得系统启动到现在所经历时间的毫秒值，最后能够统计到49.7天。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> busyTime = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">int</span> idleTime = busyTime;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> startTime = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(;;)&#123;</span><br><span class="line">		startTime = GetTickCount();</span><br><span class="line">		<span class="keyword">while</span>((GetTickCount() - startTime) &lt;= busyTime);</span><br><span class="line">		Sleep(idleTime);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>注意这两种方法都是假设当前cpu只有当前程序运行，但实际上操作系统中有很多程序会同时执行各种各样的任务，因此，实际运行的效果会如下图所示。</p>
<img src="/p/357e56ad/cpu5.PNG" class title="图5 cpu5">

<p>那么，我们该怎样做呢？这就要运用到另一个工具perfmon.exe。</p>
<p>Perfmon可以获得有关操作系统，应用程序和硬件的各种能效计数器。</p>
]]></content>
      <tags>
        <tag>编程之美读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/p/4a17b156.html</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<span id="more"></span>

<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>WIN10配置hexo</title>
    <url>/p/c7035f77.html</url>
    <content><![CDATA[<p>具体可以参考官方中文文档<a href="https://hexo.io/zh-cn/docs/index.html">https://hexo.io/zh-cn/docs/index.html</a></p>
<span id="more"></span>


<h1 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h1><p><strong>方法一</strong>：官方的安装地址：<a href="https://nodejs.org/en/download/">https://nodejs.org/en/download/</a><br><strong>方法二</strong>：通过 nvs（推荐）或者nvm 安装。nvs安装地址：<a href="https://github.com/jasongin/nvs/">https://github.com/jasongin/nvs/</a></p>
<h1 id="安装git（略）"><a href="#安装git（略）" class="headerlink" title="安装git（略）"></a>安装git（略）</h1><h1 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm install -g hexo-cli</span><br><span class="line">$ npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>
<h1 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo g #完整命令为hexo generate，用于生成静态文件</span><br><span class="line">$ hexo s #完整命令为hexo server，用于启动服务器，主要用来本地预览</span><br><span class="line">$ hexo d #完整命令为hexo deploy，用于将本地文件发布到github上</span><br><span class="line">$ hexo n #完整命令为hexo new，用于新建一篇文章</span><br></pre></td></tr></table></figure>
<h1 id="建站"><a href="#建站" class="headerlink" title="建站"></a>建站</h1><p><strong>1、</strong>安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo init &lt;folder&gt;</span><br><span class="line">$ cd &lt;folder&gt;</span><br><span class="line">$ npm install</span><br></pre></td></tr></table></figure>
<p>接下来说明部分文件的作用。<br><strong>_config.yml</strong><br>网站的 <em>配置</em>  信息，您可以在此配置大部分的参数。</p>
<p><strong>package.json</strong><br><em>应用程序</em> 的信息。EJS, Stylus 和 Markdown renderer 已默认安装，您可以自由移除。</p>
<p><strong>scaffolds</strong><br><em>模版</em> 文件夹。当您新建文章时，Hexo 会根据 scaffold 来建立文件。</p>
<p>Hexo的模板是指在新建的文章文件中默认填充的内容。例如，如果您修改scaffold/post.md中的Front-matter内容，那么每次新建一篇文章时都会包含这个修改。</p>
<p><strong>source</strong><br><em>资源</em> 文件夹是存放用户资源的地方。除 _posts 文件夹之外，开头命名为 _ (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去。</p>
<p><strong>themes</strong><br><em>主题</em> 文件夹。Hexo 会根据主题来生成静态页面。</p>
<p><strong>2、</strong>将hexo和github进行关联<br>首先在github上创建一个仓库，仓库名为***.github.io，接着编辑**_config.yml**文件，在_config.yml最下方，添加如下配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: git@github.com:***&#x2F;***.github.io.git</span><br><span class="line">  branch: main</span><br></pre></td></tr></table></figure>
<p><strong>3、</strong>将本地文件同步到github</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo g</span><br><span class="line">$ hexo d</span><br></pre></td></tr></table></figure>
<p>此时，我们的博客已经搭建起来，并发布到Github上了，这时可以登陆自己的Github查看代码是否已经推送到对应Repository。最后到github的settings的GitHub Pages中查看，可以在那里看到一个网址，点击即可访问查看。</p>
]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>查看时间，磁盘/内存可用空间</title>
    <url>/p/ffafa36b.html</url>
    <content><![CDATA[<h2 id="查看时间"><a href="#查看时间" class="headerlink" title="查看时间"></a>查看时间</h2><span id="more"></span>

<h3 id="date"><a href="#date" class="headerlink" title="date"></a>date</h3><p>date命令显示当前系统时间和日期：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">date</span><br></pre></td></tr></table></figure>

<img src="/p/ffafa36b/date.PNG" class title="图1 date">


<h3 id="cal"><a href="#cal" class="headerlink" title="cal"></a>cal</h3><p>cal命令显示当月的日历：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cal</span><br></pre></td></tr></table></figure>

<img src="/p/ffafa36b/cal.PNG" class title="图2 cal">


<h2 id="查看磁盘-内存可用空间"><a href="#查看磁盘-内存可用空间" class="headerlink" title="查看磁盘/内存可用空间"></a>查看磁盘/内存可用空间</h2><h3 id="df"><a href="#df" class="headerlink" title="df"></a>df</h3><p>df命令显示磁盘驱动器当前的可用空间：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">df</span><br></pre></td></tr></table></figure>

<img src="/p/ffafa36b/df.PNG" class title="图3 df">



<h3 id="free"><a href="#free" class="headerlink" title="free"></a>free</h3><p>free命令显示可用内存：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">free</span><br></pre></td></tr></table></figure>

<img src="/p/ffafa36b/free.PNG" class title="图4 free">



<h2 id="目录操作"><a href="#目录操作" class="headerlink" title="目录操作"></a>目录操作</h2><h3 id="pwd"><a href="#pwd" class="headerlink" title="pwd"></a>pwd</h3><p>pwd命令显示当前工作目录：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pwd</span><br></pre></td></tr></table></figure>

<img src="/p/ffafa36b/pwd.PNG" class title="图5 pwd">

<h3 id="ls"><a href="#ls" class="headerlink" title="ls"></a>ls</h3><p>ls命令列出当前工作目录的文件和目录：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ls</span><br></pre></td></tr></table></figure>

<img src="/p/ffafa36b/ls.PNG" class title="图6 ls">

<h3 id="cd"><a href="#cd" class="headerlink" title="cd"></a>cd</h3><p>cd命令改变工作目录。只需要输入cd命令，然后再输入目标工作目录的路径名即可：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd bin</span><br></pre></td></tr></table></figure>

<img src="/p/ffafa36b/cd.PNG" class title="图7 cd">



]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Makefiles 简介</title>
    <url>/p/c677bb8a.html</url>
    <content><![CDATA[<p>内容摘自《GNU Make》第二章。</p>
<span id="more"></span>

<p>本文将讨论一个简单的 Makefile，这个 Makefile 将描述如何编译和连接 8 个 C 语言源代码文件和 3 个头文件。当 make 重新编译，每一个修改了的 C 语言源代码文件都要重新编译。如果头文件发生了修改，所有包含了该头文件的源代码文件要重新编译。每一次编译都会产生一个目标文件，当发生重新编译时，所有文件都要重新链接成一个新的可执行文件。</p>
<h2 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h2><p>一个简单的 Makefile 由很多规则组成，规则有着以下的模式：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">target ... : prerequisites ...</span><br><span class="line">	recipe</span><br><span class="line">	...</span><br><span class="line">	...</span><br></pre></td></tr></table></figure>

<p>target 一般是程序要生成的文件名字，比如说是可执行文件或目标文件的名字。target 还可能是需要执行的操作的名字，比如 clean。</p>
<p>prerequisites 是被用作创建 target 的依赖文件。target 一般会依赖一些文件。</p>
<p>recipe 是 make 要执行的操作。recipe 可以有超过一条命令。注意，<strong>必须在每个 recipe 行的开始加上 tab。</strong>recipe 一般在有 prerequisites 的规则中，当 prerequisites 中的文件变化时创建 target 文件。但是，一些规则指定了 recipe 就不需要 prerequisites，比如 clean。</p>
<h2 id="简单的例子"><a href="#简单的例子" class="headerlink" title="简单的例子"></a>简单的例子</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">edit : main.o kbd.o command.o display.o \</span><br><span class="line">		insert.o search.o files.o utils.o</span><br><span class="line">		cc -o edit main.o kbd.o command.o display.o \</span><br><span class="line">					insert.o search.o files.o utils.o</span><br><span class="line">					</span><br><span class="line">main.o : main.c defs.h</span><br><span class="line">		cc -c main.c</span><br><span class="line">kbd.o : kbd.c defs.h command.h</span><br><span class="line">		cc -c kbd.c</span><br><span class="line">command.o : command.c defs.h command.h</span><br><span class="line">		cc -c command.c</span><br><span class="line">display.o : display.c defs.h buffer.h</span><br><span class="line">		cc -c display.c</span><br><span class="line">insert.o : insert.c defs.h buffer.h</span><br><span class="line">		cc -c insert.c</span><br><span class="line">search.o : search.c defs.h buffer.h</span><br><span class="line">		cc -c search.c</span><br><span class="line">files.o : files.c defs.h buffer.h command.h</span><br><span class="line">		cc -c files.c</span><br><span class="line">utils.o : utils.c defs.h</span><br><span class="line">		cc -c utils.c</span><br><span class="line">		</span><br><span class="line">clean :</span><br><span class="line">		rm edit main.o kbd.o command.o display.o \</span><br><span class="line">			insert.o search.o files.o utils.o</span><br></pre></td></tr></table></figure>

<p>如果想要创建名为 edit 的可执行文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure>

<p>如果想要删除所有目录下的所有可执行文件和目标文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">make clean</span><br></pre></td></tr></table></figure>

<h2 id="make-执行-Makefile"><a href="#make-执行-Makefile" class="headerlink" title="make 执行 Makefile"></a>make 执行 Makefile</h2><p>在默认情况下，make 从第一个 target 开始执行（不是以 ”.“ 开头 target）。这个被称为 default goal。Goal 是 make 努力更新的最终 targets。上面的例子中，default goal 就是edit，所以是第一个规则。</p>
<p>在执行 make 时，首先读取当前目录下的 makefile 文件然后处理第一个规则。在上面的例子中，这个规则是用来链接 edit，但是在 make 能完全处理这个规则之前，make 必须处理 edit 依赖的文件的规则，在上面这个例子中就是目标文件。每个目标文件都要根据自己的规则进行处理。</p>
<p>如果一个规则不被 goal 依赖，则这个命令就不会被处理，除非你告诉 make 要执行，比如make clean。</p>
<p>当目标文件不存在，或源文件，头文件比目标文件更新时，会进行重新编译。当执行文件不存在，或者执行文件比目标文件更晚时，执行文件会更新。</p>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>在上一个例子中，我们在 edit 规则中枚举所有的目标文件两次，这是很不方便的。如果有新的目标文件加入，可能会导致忘记在所有地方都修改。因此可以使用变量简化。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">objects &#x3D; main.o kbd.o command.o display.o \</span><br><span class="line">		insert.o search.o files.o utils.o</span><br><span class="line">		</span><br><span class="line">edit : $(objects)</span><br><span class="line">		cc -o edit $(objects)</span><br><span class="line">		</span><br><span class="line">main.o : main.c defs.h</span><br><span class="line">		cc -c main.c</span><br><span class="line">kbd.o : kbd.c defs.h command.h</span><br><span class="line">		cc -c kbd.c</span><br><span class="line">command.o : command.c defs.h command.h</span><br><span class="line">		cc -c command.c</span><br><span class="line">display.o : display.c defs.h buffer.h</span><br><span class="line">		cc -c display.c</span><br><span class="line">insert.o : insert.c defs.h buffer.h</span><br><span class="line">		cc -c insert.c</span><br><span class="line">search.o : search.c defs.h buffer.h</span><br><span class="line">		cc -c search.c</span><br><span class="line">files.o : files.c defs.h buffer.h command.h</span><br><span class="line">		cc -c files.c</span><br><span class="line">utils.o : utils.c defs.h</span><br><span class="line">		cc -c utils.c</span><br><span class="line">		</span><br><span class="line">clean :</span><br><span class="line">		rm edit $(objects)</span><br></pre></td></tr></table></figure>

<h2 id="make-推断-recipes"><a href="#make-推断-recipes" class="headerlink" title="make 推断 recipes"></a>make 推断 recipes</h2><p>隐含的规则：默认使用 “cc -c” 命令把 .c 文件编译成 “.o” 文件，所以如果使用该命令，则可以省略。另外，由于.o文件默认会寻找名字相同的 .c 文件作为依赖，所以在 prerequisites 中可以省略名字相同的 .c 文件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">objects &#x3D; main.o kbd.o command.o display.o \</span><br><span class="line">		insert.o search.o files.o utils.o</span><br><span class="line">		</span><br><span class="line">edit : $(objects)</span><br><span class="line">		cc -o edit $(objects)</span><br><span class="line">		</span><br><span class="line">main.o : defs.h</span><br><span class="line">kbd.o : defs.h command.h</span><br><span class="line">command.o : defs.h command.h</span><br><span class="line">display.o : defs.h buffer.h</span><br><span class="line">insert.o : defs.h buffer.h</span><br><span class="line">search.o : defs.h buffer.h</span><br><span class="line">files.o : defs.h buffer.h command.h</span><br><span class="line">utils.o : defs.h</span><br><span class="line"></span><br><span class="line">.PHONY : clean</span><br><span class="line">clean :</span><br><span class="line">		rm edit $(objects)</span><br></pre></td></tr></table></figure>

<h2 id="另一种写法"><a href="#另一种写法" class="headerlink" title="另一种写法"></a>另一种写法</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">objects &#x3D; main.o kbd.o command.o display.o \</span><br><span class="line">		insert.o search.o files.o utils.o</span><br><span class="line">		</span><br><span class="line">edit : $(objects)</span><br><span class="line">		cc -o edit $(objects)</span><br><span class="line">		</span><br><span class="line">$(objects) : defs.h</span><br><span class="line">kbd.o command.o files.o : command.h</span><br><span class="line">display.o insert.o search.o files.o : buffer.h</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>makefile</tag>
      </tags>
  </entry>
  <entry>
    <title>写 Makefile 文件</title>
    <url>/p/dcfc36a.html</url>
    <content><![CDATA[<p>内容摘自《GNU Make》第三章。</p>
<span id="more"></span>

<h2 id="Makefile-内容"><a href="#Makefile-内容" class="headerlink" title="Makefile 内容"></a>Makefile 内容</h2><ul>
<li><p>明确规则。明确的规则表明何时和怎样去 remake 一个或多个文件，这些文件称为规则的 targets。规则会列举 target 依赖的其他文件，这些文件称为 target 的 prerequistes。有些时候还会给出 recipe 用来创建或更新 target。</p>
</li>
<li><p>隐含规则。隐含规则表明基于 target 的名字就可以知道何时和怎样去 remake 一个或多个文件。</p>
</li>
<li><p>变量声明。将文本字符串指定给某一个变量，使得后续可以使用变量替代对应的文本字符串。</p>
</li>
<li><p>指令。指令是让 make 去做一些特殊的事情：</p>
<ul>
<li>读取其他 makefile 文件</li>
<li>决定是使用还是放弃 makefile 的部分内容。</li>
<li>定义一个多行的变量。</li>
</ul>
</li>
<li><p>注释。“#”。不能在变量声明或函数调用中使用注释，在变量声明和函数调用中，“#” 会被当作字面值，而不是注释的开始。</p>
</li>
</ul>
<h2 id="长行切割"><a href="#长行切割" class="headerlink" title="长行切割"></a>长行切割</h2><p>Makefile 使用基于行的语法，每个换行符都是特殊的，标志着声明的结束。虽然GNU对于一行的长度没有限制，但是为了可读性，需要将较长的行分割成多行。这可以使用 ’\‘ 。对于 “\“ + “\n” 的处理要看声明是否是recipe。如果不是，”\“ + “\n” 会被当做空格处理。另外，所有 “\“ + “\n” 附近的空格都会被压缩为一个空格，这包括 “\“ + “\n”  之前的空格，”\“ + “\n”  之后的行开头的空格和连续的 “\“ + “\n” 组合。</p>
<p>如果不想要空格，可以使用 ”$\“ + “\n”。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var :&#x3D; one$\</span><br><span class="line">		word</span><br></pre></td></tr></table></figure>

<p>等价于：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var :&#x3D; oneword</span><br></pre></td></tr></table></figure>

<h2 id="Makefile-文件名"><a href="#Makefile-文件名" class="headerlink" title="Makefile 文件名"></a>Makefile 文件名</h2><p>默认会依次找以下文件名：GNUmakefile，makefile，Makefile。</p>
<p>建议使用 Makefile，因为与 README 这些文件靠的近。除非特殊指定 GNU make，要不然不要使用GNUmakefile。因为其他 make 版本不支持。</p>
<p>如果没有找到以上的文件， make 就不会使用任何 makefile。你必须通过命令行指定 goal，然后 make 会使用隐藏规则 remake。</p>
<p>如果你想给你的 makefile 换一个名字，则要加 -f 或 –file 选项。</p>
]]></content>
      <tags>
        <tag>makefile</tag>
      </tags>
  </entry>
  <entry>
    <title>Nova源码阅读（一） openstack简介</title>
    <url>/p/ecb3c3ec.html</url>
    <content><![CDATA[<p>内容主要摘自于《Openstack设计与实现》。</p>
<h2 id="openstack与AWS"><a href="#openstack与AWS" class="headerlink" title="openstack与AWS"></a>openstack与AWS</h2><p>与AWS相比，openstack只是处于一个追随者的位置。</p>
<span id="more"></span>

<h3 id="AWS架构"><a href="#AWS架构" class="headerlink" title="AWS架构"></a>AWS架构</h3><p>AWS由五层组成，自下而上包括AWS全球基础架构，基础服务，应用平台服务，管理和用户应用程序。</p>
<p>AWS提供六类主要服务：数据库，存储和内容分发，分析，计算和网络，部署管理，应用服务。</p>
<ul>
<li>数据库：NoSQL数据库服务DynamoDB，关系数据库服务RDS，缓存和数据仓库服务Redshift</li>
<li>存储和内容分发：简单存储服务S3，块存储服务EBS，Amazon云前端Cloud Front，Amazon Glacier，AWS存储网关Storage Gateway。</li>
<li>分析：用于大数据的EMR，用于大规模实时流数据处理Kinesis，数据管道Data Pipeline</li>
<li>计算和网络服务：负责虚拟机调度和管理EC2，保证企业在公有云上搭建安全私有云的虚拟私有云服务VPC，负载均衡ELB，虚拟桌面管理服务WorkSpaces，计算资源自动扩容缩容的Auto Scaling，为企业定制的专属网络连接DirectConnect，高可靠性且可扩展的域名系统web服务Route 53</li>
<li>部署管理：建立和管理AWS资源CloudFormation，监控CloudWatch，轻松部署Web应用和服务的Elastic Beanstalk，验证访问管理IAM，日志管理CloudTrail，为运维人员配备的应用管理服务OpsWorks和安全服务CloudHSM</li>
<li>应用服务：云搜索CloudSearch，流媒体转码Elastic Transcoder，简单邮件服务SES，简单队列服务SQS，简单工作流服务SWF，应用程序流AppStream</li>
</ul>
<h3 id="AWS与Openstack相对应的项目"><a href="#AWS与Openstack相对应的项目" class="headerlink" title="AWS与Openstack相对应的项目"></a>AWS与Openstack相对应的项目</h3><table>
<thead>
<tr>
<th align="center">AWS模块</th>
<th align="center">Openstack模块</th>
</tr>
</thead>
<tbody><tr>
<td align="center">EC2</td>
<td align="center">Nova</td>
</tr>
<tr>
<td align="center">S3</td>
<td align="center">Swift</td>
</tr>
<tr>
<td align="center">EBS</td>
<td align="center">Cinder</td>
</tr>
<tr>
<td align="center">IAM</td>
<td align="center">Keystone</td>
</tr>
<tr>
<td align="center">CloudWatch</td>
<td align="center">Ceilometer</td>
</tr>
<tr>
<td align="center">CloudFormation</td>
<td align="center">Heat</td>
</tr>
<tr>
<td align="center">支持RDS, DynamoDB</td>
<td align="center">支持MySQL，PostgreSQL，MongoDB</td>
</tr>
</tbody></table>
<h2 id="openstack-架构"><a href="#openstack-架构" class="headerlink" title="openstack 架构"></a>openstack 架构</h2><img src="/p/ecb3c3ec/openstack%E6%A0%87%E5%87%86%E6%9E%B6%E6%9E%84.jpeg" class title="图1 openstack结构">

<p>OpenStack曾经包含7个核心组件：</p>
<table>
<thead>
<tr>
<th align="center">组件名称</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Nova</td>
<td align="center">提供虚拟机服务</td>
</tr>
<tr>
<td align="center">Swift</td>
<td align="center">存储和检索对象/文件</td>
</tr>
<tr>
<td align="center">KeyStone</td>
<td align="center">身份认证和授权，跟踪用户及他们的权限</td>
</tr>
<tr>
<td align="center">Horizon</td>
<td align="center">提供界面</td>
</tr>
<tr>
<td align="center">Cinder</td>
<td align="center">块存储服务</td>
</tr>
<tr>
<td align="center">Neutron</td>
<td align="center">网络连接服务，允许用户创建自己的虚拟网络并连接各种网络设备接口</td>
</tr>
<tr>
<td align="center">Glance</td>
<td align="center">虚拟机镜像的存储，查询和检索服务</td>
</tr>
</tbody></table>
]]></content>
      <tags>
        <tag>openstack</tag>
      </tags>
  </entry>
  <entry>
    <title>nova-参数</title>
    <url>/p/200ca30a.html</url>
    <content><![CDATA[<p>train版本</p>
<p><a href="https://docs.openstack.org/nova/train/configuration/config.html">https://docs.openstack.org/nova/train/configuration/config.html</a></p>
]]></content>
      <tags>
        <tag>openstack</tag>
      </tags>
  </entry>
  <entry>
    <title>Nova源码阅读（二） openstack通用技术</title>
    <url>/p/7952953b.html</url>
    <content><![CDATA[<p>内容主要摘自于《Openstack设计与实现》。</p>
<span id="more"></span>

<h2 id="消息总线"><a href="#消息总线" class="headerlink" title="消息总线"></a>消息总线</h2><p>Openstack遵循这样的原则：项目之间通过<strong>RESTful API</strong>进行通信，项目内部的不同服务进程之间的通信，则必须通过<strong>消息总线</strong>。oslo.messaging 库实现了以下两种方式来完成项目内部的不同服务进程之间的通信。</p>
<ul>
<li>远程过程调用（RPC）。通过RPC，一个服务进程可以调用其他远程服务进程的方法，并且有两种调用方式：同步和异步。</li>
<li>事件通知（Event Notification）。某个服务进程可以把事件通知发送到消息总线上，该消息总线上的所有对此类事件感兴趣的服务进程，都可以获得此事件通知并进行进一步的处理，但是处理的结果并不会返回给事件的发送者。</li>
</ul>
<h3 id="AMQP-advanced-message-queuing-protocol"><a href="#AMQP-advanced-message-queuing-protocol" class="headerlink" title="AMQP(advanced message queuing protocol)"></a>AMQP(advanced message queuing protocol)</h3><p>在Openstack支持的消息总线类型中，大部分都是基于AMQP的。AMQP是一个异步消息传递所使用的开放的应用层协议，主要包括信息的导向，队列，路由，可靠性和安全性。oslo.messaging中支持的AMQP主要包括两个版本，AMQP 0.9.1和AMQP 1.0，两个版本有较大区别。</p>
<h4 id="AMQP-0-9-1"><a href="#AMQP-0-9-1" class="headerlink" title="AMQP 0.9.1"></a>AMQP 0.9.1</h4><img src="/p/7952953b/AMQP.PNG" class title="图1 AMQP结构">

<p>当不同的消息由生产者（Publisher application）发送到broker时，会根据不同的条件把消息传递给不同的消费者（consumer）。如果消费者无法接收到信息或者接受信息不够快时，会把消息缓存在内存和磁盘上。</p>
<p>生产者将消息发送给Exchange，并由Exchange来决定消息的路由，即消息发送给哪个Queue，然后消费者从Queue中取出消息，进行处理。</p>
<p>每一个消息都有一个routing key，每一个queue有一个binding key，Exchange在收到消息时，会将routing key与每一个queue的binding key进行匹配，匹配成功，则会将信息转发到对应的queue中。</p>
<p>转发的类型有三种：</p>
<ul>
<li><p>direct：routing key与binding key完全一致，不支持通配符；</p>
</li>
<li><p>topic：支持通配符；</p>
</li>
<li><p>fanout：忽略routing key与binding key。消息转发到所有queue中。</p>
</li>
</ul>
<h4 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h4><p>RabbitMQ是一个实现了AMQP的消息中间件服务，支持多种语言的客户端开发，支持用户自定义插件开发的框架及多种插件。</p>
<h4 id="AMQP-1-0"><a href="#AMQP-1-0" class="headerlink" title="AMQP 1.0"></a>AMQP 1.0</h4><p>与AMQP 0.9.1相比，1.0协议更加灵活和复杂。1.0实现了一种消息路由模式：位于调用者和服务器之间的不再是单节点的broker，而是一群互相连接的消息路由组成的路由网；路由不具备queue，没有存储消息的能力，作用只是传递消息；路由节点之间通过使用tcp连接进行通信；调用者可以通过tcp连接连到路由网中的某个路由，从而接入路由网。</p>
<h2 id="SQLAlchemy与数据库"><a href="#SQLAlchemy与数据库" class="headerlink" title="SQLAlchemy与数据库"></a>SQLAlchemy与数据库</h2><img src="/p/7952953b/SQLAlchemy.PNG" class title="图2 SQLAlchemy结构">

<p>SQLAlchemy 主要包括两个部分：SQLAlchemy Core和SQLAlchemy ORM。SQLAlchemy core包括SQL语言表达式，数据引擎，连接池等。所有的实现都是以连接不同类型的后台数据库，提交查询和更新SQL请求，定义数据库数据类型和定义schema等为目的。SQLAlchemy ORM提供数据映射模式，即把程序语言的对象数据映射成数据库的关系数据，或者把关系数据映射为对象数据。另外SQLAlchemy对象关系映射是一个可选模块，开发人员可以完全不使用任何对象模型，直接使用SQLAlchemy操作数据。</p>
<h2 id="RESTful-与-WSGI"><a href="#RESTful-与-WSGI" class="headerlink" title="RESTful 与 WSGI"></a>RESTful 与 WSGI</h2><h3 id="RESTful"><a href="#RESTful" class="headerlink" title="RESTful"></a>RESTful</h3><p>参考文献：</p>
<ol>
<li><a href="https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm">https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm</a></li>
<li><a href="http://restful.p2hp.com/">http://restful.p2hp.com/</a></li>
</ol>
<p>REST（representational state transfer，表述性状态转移）。从RESTful角度上看，网络中的所有东西都是资源，每个资源都对应于一个特定的URI，并用它进行标识。资源有多种具体的表现形式，即资源的表述。URI仅代表资源的实体，不能代表其表现形式。</p>
<p>REST的指导原则</p>
<ol>
<li><strong>客户端 - 服务器</strong> 。</li>
<li><strong>无状态</strong>。从客户端到服务器的每个请求都必须包含理解请求所需的所有信息，并且不能利用服务器上任何存储的上下文。因此，会话状态完全保留在客户端上。</li>
<li><strong>可缓存</strong> 。缓存约束要求将对请求的响应中的数据隐式或显式标记为可缓存或不可缓存。如果响应是可缓存的，则客户端缓存有权重用该响应数据以用于以后的等效请求。</li>
<li><strong>统一接口</strong> 。</li>
<li><strong>分层系统</strong>。 分层系统风格允许通过约束组件行为来使体系结构由分层层组成，这样每个组件都不能“看到”超出与它们交互的直接层。</li>
<li><strong>按需编码（可选）</strong>。 REST允许通过以小程序或脚本的形式下载和执行代码来扩展客户端功能。这通过减少预先实现所需的功能数量来简化客户端。</li>
</ol>
<h3 id="WSGI（Web-service-gateway-interface）"><a href="#WSGI（Web-service-gateway-interface）" class="headerlink" title="WSGI（Web service gateway interface）"></a>WSGI（Web service gateway interface）</h3><p>RESTful只是设计风格而不是标准，WEB服务通常使用基于HTTP的符合RESTful的API，而WSGI则是python语言中所定义的WEB服务器和WEB应用程序或框架之间的通用接口标准。</p>
<p>当处理一个WSGI请求时，服务端会为应用端提供上下文信息和一个回调函数，应用端在处理完请求后，会使用服务端所提供的回调函数返回对应请求的响应。</p>
<p>WSGI将WEB组件分成三类：WEB服务器，WEB中间件，WEB应用程序。WEB服务器用于接收HTTP请求，封装一系列环境变量，按照WSGI接口标准调用注册的WSGI应用程序，然后将响应返回给客户端。</p>
<p>WSGI应用程序是一个可被调用的Python对象，只接受两个参数，environ和start_response。</p>
<ul>
<li><p>environ指向一个python字典，要求里面至少包含一些在CGI中定义的变量以及至少包含其他7个WSGI所定义的环境变量。WSGI应用程序会从environ字典中获取相应的请求及其执行上下文中的所有信息。</p>
</li>
<li><p>start_response指向一个回调函数：</p>
<p><code>start_response(status, response_headers,exe_info=None)</code></p>
<p>status是一个响应状态的字符串；response_headers是一个包含了（header_name,header_value）元组的列表，分别表示HTTP相应中的HTTP头和内容；exe_info一般在错误时使用，用来让浏览器显示相关错误信息。</p>
<p>回调函数返回形如write(data)的可被调用的对象。这个对象是为了兼容现有的一些特殊框架而设计的，一般不使用。</p>
</li>
</ul>
<h4 id="Paste-文件"><a href="#Paste-文件" class="headerlink" title="Paste 文件"></a>Paste 文件</h4><p>  Openstack使用Paste的Deploy组件完成WSGI Server和WSGI Application的构建，每个项目源码的etc目录下都有一个Paste文件，如Nova的etc/nova/api-paste.ini，在部署时，这些文件被拷贝到系统/etc/&lt;project&gt;/目录下。</p>
<p>Paste配置文件分为多个section，每个section以type:name命名。</p>
<ul>
<li><p>type = composite</p>
<p>这个section会把URL请求发到对应的应用程序中，并由use指定具体的分发方式。</p>
</li>
<li><p>type = app</p>
<p>一个app就是一个具体的WSGI 应用程序，这个app对应的python代码可以由use来指定。另一种指定方法是明确指定对应的python代码，这时必须给出代码应该符合的格式。</p>
</li>
<li><p>type = filter-app</p>
<p>在接收到一个请求后，会先调用fliter-app中的use所指定的app进行过滤，如果请求没有被过滤，就会被转发到next所指定的app上进行下一步的处理。</p>
</li>
<li><p>type = filter</p>
<p>跟上一个的区别是没有next。</p>
</li>
<li><p>type = pipeline</p>
<p>由一系列filter组成，filter链条的末尾是一个app。pipeline类型对filter-app做了简化。</p>
</li>
</ul>
<h4 id="WebOb"><a href="#WebOb" class="headerlink" title="WebOb"></a>WebOb</h4><p>WebOb通过对WSGI的请求与相应进行封装，可以简化WSGI应用的编写。</p>
<p>WebOb重要的对象：</p>
<ul>
<li><p>webob.Request。对WSGI请求的参数environ进行封装；</p>
</li>
<li><p>webob.Response。包含了标准WSGI响应的所有要素；</p>
</li>
<li><p>webob.exc。针对HTTP错误代码进行封装。</p>
</li>
<li><p>webob.dec.wsgify。以便可以不使用原始的WSGI参数和返回格式，而全部使用WebOb替代。</p>
</li>
</ul>
<h4 id="Pecan"><a href="#Pecan" class="headerlink" title="Pecan"></a>Pecan</h4><p>Paste组合框架的REATful API代码过于臃肿，导致项目的可维护性差。一些新项目使用Pecan框架实现RESTful API。Pecan是一个轻量级的WSGI网络框架。其设计思想不是解决Web世界的所有问题，而是主要集中于对象路由和RESTful支持上，并不提供对话和数据库支持。  </p>
<h2 id="Eventlet-与-AsyncIO"><a href="#Eventlet-与-AsyncIO" class="headerlink" title="Eventlet 与 AsyncIO"></a>Eventlet 与 AsyncIO</h2><p>Openstack中的绝大多数项目采用协程模型。协程，是一种比线程更加轻量级的存在，协程拥有自己独立的栈和局部变量，同时与其他协程共享全局变量。</p>
<p>协程与线程的区别是：多个线程可以同时执行，但是同一时间只能有一个协程运行；线程的执行由操作系统控制，协程的执行顺序由程序自己决定。由于协程无需考虑很多有关锁的问题，因此开发和调试比较简单。</p>
<h3 id="Eventlet"><a href="#Eventlet" class="headerlink" title="Eventlet"></a>Eventlet</h3><p>协程来实现并发，将协程称为GreenTread，所谓的并发就是建立多个GreenTread，并对其进行管理。</p>
<h3 id="AsyncIO"><a href="#AsyncIO" class="headerlink" title="AsyncIO"></a>AsyncIO</h3><p>Eventlet具有局部性，如不支持Python3，PyPy，Jython等，只支持CPython。目前Openstack正考虑用AsyncIO替代Eventlet。</p>
]]></content>
      <tags>
        <tag>openstack</tag>
      </tags>
  </entry>
  <entry>
    <title>sky computing</title>
    <url>/p/ac1fc4f3.html</url>
    <content><![CDATA[<p>Ion Stoica and Scott Shenker. 2021. From Cloud Computing to Sky Computing. In Workshop on Hot Topics in Operating Systems (HotOS ’21), May 31-June 2, 2021, Ann Arbor, MI, USA. ACM, New York, NY, USA, 7 pages. <a href="https://doi.org/10.1145/3458336.3465302">https://doi.org/10.1145/3458336.3465302</a></p>
<span id="more"></span>

<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>云中的服务都是有所有权的，而云服务提供商就是依靠提供这些具有所有权的服务相互区分。但是这些云服务提供商的竞争使得我们远离utility computing。</p>
<h2 id="兼容层"><a href="#兼容层" class="headerlink" title="兼容层"></a>兼容层</h2><p>兼容层把云提供的服务抽象出来，使得上层开发的应用能够在不同的云端上跑而且不需要修改。即应用可以直接调用兼容层的接口，然后应用就可以在任意云上跑。这可以类比网络上的IP层。但是，要更加广泛，更加难以定义，因为云给应用暴露了相当多的服务，因此会更像操作系统。</p>
<p>开源软件可以帮助我们更好的做好兼容层。问题是市场是否会支持这样的工作。</p>
<h2 id="云间交互层"><a href="#云间交互层" class="headerlink" title="云间交互层"></a>云间交互层</h2><p>有了兼容层，用户还需要决定在哪片云上跑应用。网络上有BGP，sky computing应该有一个云间交互层将云服务提供商从用户中抽象出来，也就是说，用户不应该知道应用跑在那一片云上（除非用户想要明确知道）。</p>
<p>The intercloud layer must allow users to specify policies about where their jobs should run, but not require users to make low-level decisions about job placement (but would allow users to do so if they desired). These policies would allow a user to express their preferences about the tradeoff between performance, availability, and cost. In addition, a user might want to avoid their application running on a datacenter operated by a competitor, or stay within certain countries to obey relevant privacy regulations. To make this more precise, a user might specify that this is a Tensorflow job, it involves data that cannot leave Germany, and must be finished within the next two hours for under a certain cost.</p>
<p>问题与挑战：</p>
<ul>
<li>服务命名模式。通过命名确定一个服务实例，元数据管理。</li>
<li>目录服务。寻找一个服务实例。维护元数据和命名信息。</li>
<li>账户和花费。</li>
</ul>
<h2 id="云间对等"><a href="#云间对等" class="headerlink" title="云间对等"></a>云间对等</h2><p>对于大数据集，数据迁移不可避免。数据在不同云提供商间迁移是需要花费的，但是，这部分的花费可能比计算资源更便宜。互惠的数据对等管理会使数据的迁移更加快速有效。</p>
<h2 id="未来"><a href="#未来" class="headerlink" title="未来"></a>未来</h2><p>希望小的云服务提供商能够采用兼容层。</p>
<p>两种类型云服务提供商。</p>
<ul>
<li>stand-alone：专有的接口。更高的margin，专有的接口有更多可以创新提高的地方。</li>
<li>commodity：使用sky computing。更低的margin，有更少可以创新提高的地方。每个云服务提供商可以专精一个方面。</li>
</ul>
]]></content>
      <tags>
        <tag>云计算论文研读</tag>
      </tags>
  </entry>
  <entry>
    <title>查询功耗，负载</title>
    <url>/p/861b9aeb.html</url>
    <content><![CDATA[<h2 id="查看CPU负载"><a href="#查看CPU负载" class="headerlink" title="查看CPU负载"></a>查看CPU负载</h2><span id="more"></span>

<h3 id="uptime"><a href="#uptime" class="headerlink" title="uptime"></a>uptime</h3><img src="/p/861b9aeb/uptime.PNG" class title="图1 uptime">

<p>这些字段显示：当前时间，系统已运行的时间，当前登录用户的数量，相应最近5、10和15分钟内的平均负载。</p>
<h3 id="w"><a href="#w" class="headerlink" title="w"></a>w</h3><img src="/p/861b9aeb/w.PNG" class title="图2 w">

<p>Linux w命令用于显示目前登入系统的用户信息。执行这项指令可得知目前登入系统的用户有哪些人，以及他们正在执行的程序。单独执行 w 指令会显示所有的用户，您也可指定用户名称，仅显示某位用户的相关信息。</p>
<h3 id="top"><a href="#top" class="headerlink" title="top"></a>top</h3><img src="/p/861b9aeb/top.PNG" class title="图3 top">

<img src="/p/861b9aeb/top1.PNG" class title="图4 top1">

<p>top命令的顶部显示与uptime命令相似的输出，这些字段显示：当前时间，系统已运行的时间，当前登录用户的数量，相应最近5、10和15分钟内的平均负载。</p>
<img src="/p/861b9aeb/top2.PNG" class title="图5 top2">

<p>任务（进程），系统现在共有457个进程，其中处于运行中的有1个，456个在休眠（sleep），stoped状态的有0个，zombie状态（僵尸）的有0个。</p>
<img src="/p/861b9aeb/top3.PNG" class title="图6 top3">

<p>这里显示不同模式下所占cpu时间百分比，这些不同的cpu时间表示：</p>
<ul>
<li><p>us, user： 运行(未调整优先级的) 用户进程的CPU时间</p>
</li>
<li><p>sy，system: 运行内核进程的CPU时间</p>
</li>
<li><p>ni，niced：运行已调整优先级的用户进程的CPU时间</p>
</li>
<li><p>wa，IO wait: 用于等待IO完成的CPU时间</p>
</li>
<li><p>hi：处理硬件中断的CPU时间</p>
</li>
<li><p>si: 处理软件中断的CPU时间</p>
</li>
<li><p>st：这个虚拟机被hypervisor偷去的CPU时间（译注：如果当前处于一个hypervisor下的vm，实际上hypervisor也是要消耗一部分CPU处理时间的）。</p>
</li>
</ul>
<img src="/p/861b9aeb/top4.PNG" class title="图6 top4">

<p>接下来两行显示内存使用率。第一行是物理内存，第二行是虚拟内存。物理内存显示如下:全部可用内存、已使用内存、空闲内存、缓冲内存。相似地，交换部分显示的是：全部、已使用、空闲和缓冲交换空间。</p>
<img src="/p/861b9aeb/top5.PNG" class title="图7 top5">

<p>PID：进程ID，进程的唯一标识符</p>
<p>USER：进程所有者的实际用户名。</p>
<p>PR：进程的调度优先级。这个字段的一些值是’rt’。这意味这这些进程运行在实时态。</p>
<p>NI：进程的nice值（优先级）。越小的值意味着越高的优先级。负值表示高优先级，正值表示低优先级</p>
<p>VIRT：进程使用的虚拟内存。进程使用的虚拟内存总量，单位kb。VIRT=SWAP+RES</p>
<p>RES：驻留内存大小。驻留内存是任务使用的非交换物理内存大小。进程使用的、未被换出的物理内存大小，单位kb。RES=CODE+DATA</p>
<p>SHR：SHR是进程使用的共享内存。共享内存大小，单位kb</p>
<p>S：这个是进程的状态。它有以下不同的值:</p>
<ul>
<li>D - 不可中断的睡眠态。</li>
<li>R – 运行态</li>
<li>S – 睡眠态</li>
<li>T – 被跟踪或已停止</li>
<li>Z – 僵尸态</li>
</ul>
<p>%CPU：自从上一次更新时到现在任务所使用的CPU时间百分比。</p>
<p>%MEM：进程使用的可用物理内存百分比。</p>
<p>TIME+：任务启动后到现在所使用的全部CPU时间，精确到百分之一秒。</p>
<p>COMMAND：运行进程所使用的命令。进程名称（命令名/命令行）</p>
<p>更多内容可以查看<a href="https://www.cnblogs.com/zhoug2020/p/6336453.html">https://www.cnblogs.com/zhoug2020/p/6336453.html</a></p>
<h2 id="压力测试工具：stress"><a href="#压力测试工具：stress" class="headerlink" title="压力测试工具：stress"></a>压力测试工具：stress</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install -y epel-release</span><br><span class="line">yum install -y stress</span><br></pre></td></tr></table></figure>

<h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;stress&#39; imposes certain types of compute stress on your system</span><br><span class="line"></span><br><span class="line">Usage: stress [OPTION [ARG]] ...</span><br><span class="line"> -?, --help         show this help statement</span><br><span class="line">     --version      show version statement</span><br><span class="line"> -v, --verbose      be verbose</span><br><span class="line"> -q, --quiet        be quiet	&#x2F;&#x2F;不显示运行信息</span><br><span class="line"> -n, --dry-run      show what would have been done</span><br><span class="line"> -t, --timeout N    timeout after N seconds</span><br><span class="line">     --backoff N    wait factor of N microseconds before work starts</span><br><span class="line"> -c, --cpu N        spawn N workers spinning on sqrt()</span><br><span class="line"> -i, --io N         spawn N workers spinning on sync()</span><br><span class="line"> -m, --vm N         spawn N workers spinning on malloc()&#x2F;free()</span><br><span class="line">     --vm-bytes B   malloc B bytes per vm worker (default is 256MB)</span><br><span class="line">     --vm-stride B  touch a byte every B bytes (default is 4096)</span><br><span class="line">     --vm-hang N    sleep N secs before free (default none, 0 is inf)</span><br><span class="line">     --vm-keep      redirty memory instead of freeing and reallocating</span><br><span class="line"> -d, --hdd N        spawn N workers spinning on write()&#x2F;unlink()</span><br><span class="line">     --hdd-bytes B  write B bytes per hdd worker (default is 1GB)</span><br><span class="line"></span><br><span class="line">Example: stress --cpu 8 --io 4 --vm 2 --vm-bytes 128M --timeout 10s</span><br><span class="line"></span><br><span class="line">Note: Numbers may be suffixed with s,m,h,d,y (time) or B,K,M,G (size).</span><br></pre></td></tr></table></figure>

<h2 id="查看CPU功耗"><a href="#查看CPU功耗" class="headerlink" title="查看CPU功耗"></a>查看CPU功耗</h2><h3 id="方法1：s-tui"><a href="#方法1：s-tui" class="headerlink" title="方法1：s-tui"></a>方法1：s-tui</h3><h4 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install python-pip stress</span><br><span class="line">pip install s-tui	&#x2F;&#x2F;python2.X</span><br><span class="line">pip3 install s-tui	&#x2F;&#x2F;python3.X</span><br></pre></td></tr></table></figure>

<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>需要root权限。需要以下命令启动：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">s-tui</span><br></pre></td></tr></table></figure>

<img src="/p/861b9aeb/s-tui.PNG" class title="图7 s-tui">

<p>s-tui里面包含cpu的功耗，温度，频率，利用率等信息。</p>
<h3 id="方法2：turbostat"><a href="#方法2：turbostat" class="headerlink" title="方法2：turbostat"></a>方法2：turbostat</h3><p>需要root权限。需要以下命令使用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">turbostat</span><br></pre></td></tr></table></figure>

<img src="/p/861b9aeb/turbostat.PNG" class title="图8 turbostat">

<p>一、turboastat可以用来查看CPU核心处在C1 C3 C6 C7状态下时间。<br>在CPU超线程的核心中，如果某个核心处于工作状态，会阻止该超线程的另一个核心进入比C1更加深入的省电模式。</p>
<p>二、turbostat可以查看CPU的温度信息。<br>CoreTmp：每个物理cpu核心的温度。<br>PkgTmp：每个物理CPU的温度。</p>
<p>三、turbostat查看CPU的忙碌状态。<br>AVG_MHz 执行周期数除以经过的时间<br>%Busy 处于“ C0”状态的时间百分比。<br>Bzy_MHz cpu繁忙时的平均时钟频率。 (in “c0” state).<br>TSC_MHz TSC在整个时间间隔内运行的平均MHz。TSC是一个64bit的寄存器，用来记录cpu的cycle个数。</p>
<p>四、查看能耗消耗位置<br>PkgWatt 整个CPU消耗的瓦特数。<br>CorWatt 核心消耗的瓦特数。<br>GFXWatt 图像部分消耗的瓦特数。<br>RAMWatt DRAM DIMMS 部分消耗的瓦特数。</p>
<p>五、查看RAPL信息<br>RAPL是Running Average Power Limit的缩写。<br>PKG_% cpu RAPL节流活动间隔的百分比。<br>RAM_% cpu RAPL节流在DRAM上处于活动状态的时间间隔的百分比。</p>
<h3 id="方法3：powertop"><a href="#方法3：powertop" class="headerlink" title="方法3：powertop"></a>方法3：powertop</h3><h4 id="安装-2"><a href="#安装-2" class="headerlink" title="安装"></a>安装</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install powertop</span><br></pre></td></tr></table></figure>

<h4 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h4><p>Powertop需要root权限。详细可以参考<a href="https://linux.cn/article-10560-1.html%E3%80%82">https://linux.cn/article-10560-1.html。</a></p>
<h3 id="方法4：MSR寄存器"><a href="#方法4：MSR寄存器" class="headerlink" title="方法4：MSR寄存器"></a>方法4：MSR寄存器</h3><p>MSR（Model Specific Register）是x86架构中的概念，指的是在x86架构处理器中，一系列用于控制CPU运行、功能开关、调试、跟踪程序执行、监测CPU性能等方面的寄存器。</p>
<h4 id="RAPL"><a href="#RAPL" class="headerlink" title="RAPL"></a>RAPL</h4><p>RAPL全称为： running average power limit<br>RAPL是x86处理器用于限制功耗、获取功耗的一组工具，rapl提供了一系列的设置接口用于限制和获取cpu的功耗以及CPU的能量消耗，而我们调用这些功能的入口就是学会读写msr寄存器。关于RAPL的操作说明，参考Intel开发者帮助手册第3卷14.9章节。</p>
<p>在RAPL中获取功耗的思路是：</p>
<ul>
<li>首先使用cpuid代码或者lscpu查看cpu是否支持msr （这个一般都支持）</li>
<li>读取MSR_RAPL_POWER_UNIT寄存器的内容，得到能量的基本计算单元。</li>
<li>读取MSR_PKG_ENERGY_STATUS寄存器的内容，用来乘以能量基本计算单元，得到具体的累积能量消耗（单位：焦耳）。</li>
<li>程序暂停一段时间。</li>
<li>再次读取MSR_PKG_ENERGY_STATUS寄存器的内容，乘以能量基本计算单元，得到累积能量消耗。</li>
<li>用第二次得到的累积能量消耗减去第一次的，除以时间，就得到了这段时间的平均功耗。</li>
</ul>
<p>详细可以参考<a href="https://blog.csdn.net/Xiaobai__Lee/article/details/100729269?spm=1001.2101.3001.6650.2&amp;utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-2.no_search_link&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-2.no_search_link">https://blog.csdn.net/Xiaobai__Lee/article/details/100729269?spm=1001.2101.3001.6650.2&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-2.no_search_link&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-2.no_search_link</a></p>
<h2 id="查看服务器功耗"><a href="#查看服务器功耗" class="headerlink" title="查看服务器功耗"></a>查看服务器功耗</h2><h3 id="ipmitool"><a href="#ipmitool" class="headerlink" title="ipmitool"></a>ipmitool</h3><h4 id="安装-3"><a href="#安装-3" class="headerlink" title="安装"></a>安装</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install -y OpenIPMI ipmitool</span><br></pre></td></tr></table></figure>

<h4 id="使用-2"><a href="#使用-2" class="headerlink" title="使用"></a>使用</h4><p>需要root权限。使用命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ipmitool -I open sdr elist</span><br></pre></td></tr></table></figure>



<p>此命令可以获取传感器中的各种监测值和该值的监测阈值，包括（CPU温度，电压，风扇转速，电源调制模块温度，电源电压等信息）。</p>
<p>使用以下命令查看功耗：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ipmitool -I open sdr elist | grep Sys_Total_Power</span><br></pre></td></tr></table></figure>

<img src="/p/861b9aeb/impi2.PNG" class title="图10 ipmi2">

<p>更多ipmitool功能可以参考<a href="https://blog.csdn.net/xinqidian_xiao/article/details/80924897%E3%80%82">https://blog.csdn.net/xinqidian_xiao/article/details/80924897。</a></p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://www.cnblogs.com/zhoug2020/p/6336453.html">https://www.cnblogs.com/zhoug2020/p/6336453.html</a></p>
<p><a href="https://blog.csdn.net/weixin_44793395/article/details/106167831">https://blog.csdn.net/weixin_44793395/article/details/106167831</a></p>
<p><a href="https://linux.cn/article-10560-1.html">https://linux.cn/article-10560-1.html</a></p>
<p><a href="https://blog.csdn.net/xinqidian_xiao/article/details/80924897">https://blog.csdn.net/xinqidian_xiao/article/details/80924897</a></p>
<p><a href="https://blog.csdn.net/Xiaobai__Lee/article/details/100729269?spm=1001.2101.3001.6650.2&amp;utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-2.no_search_link&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-2.no_search_link">https://blog.csdn.net/Xiaobai__Lee/article/details/100729269?spm=1001.2101.3001.6650.2&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-2.no_search_link&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-2.no_search_link</a></p>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>学习网站</title>
    <url>/p/52e318f2.html</url>
    <content><![CDATA[<h2 id="Go"><a href="#Go" class="headerlink" title="Go"></a>Go</h2><span id="more"></span>

<p>Go语言圣经 <a href="http://gopl.io/">《The Go Programming Language》</a> 中文版本：<a href="http://shouce.jb51.net/gopl-zh/index.html">http://shouce.jb51.net/gopl-zh/index.html</a></p>
<h2 id="课程网站"><a href="#课程网站" class="headerlink" title="课程网站"></a>课程网站</h2><h3 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h3><p>MIT6.824：<a href="https://pdos.csail.mit.edu/6.824/">https://pdos.csail.mit.edu/6.824/</a></p>
<h2 id="benchmark"><a href="#benchmark" class="headerlink" title="benchmark"></a>benchmark</h2><p><a href="https://github.com/giltene/wrk2">wrk2</a>：a HTTP benchmarking tool based mostly on wrk</p>
<p><a href="https://github.com/brianfrankcooper/YCSB/">YCSB</a>：测试在线数据库性能，扩展性的框架</p>
<h2 id="numad"><a href="#numad" class="headerlink" title="numad"></a>numad</h2><p><a href="https://sq.sf.163.com/blog/article/177543269487403008">https://sq.sf.163.com/blog/article/177543269487403008</a></p>
<p><a href="https://sq.sf.163.com/blog/article/177542610675490816">https://sq.sf.163.com/blog/article/177542610675490816</a></p>
<p><a href="https://sq.sf.163.com/blog/article/177545938213986304">https://sq.sf.163.com/blog/article/177545938213986304</a></p>
<p><a href="https://sq.sf.163.com/blog/article/177546699501133824">https://sq.sf.163.com/blog/article/177546699501133824</a></p>
<p>源码：</p>
<h2 id="论文"><a href="#论文" class="headerlink" title="论文"></a>论文</h2><p><a href="https://dl.acm.org/">https://dl.acm.org/</a></p>
<p><a href="https://www.usenix.org/publications/proceedings">https://www.usenix.org/publications/proceedings</a></p>
<h2 id="cluster-trace"><a href="#cluster-trace" class="headerlink" title="cluster trace"></a>cluster trace</h2><p>阿里巴巴：<a href="https://github.com/alibaba/clusterdata">https://github.com/alibaba/clusterdata</a></p>
<p>Google：<a href="https://github.com/google/cluster-data">https://github.com/google/cluster-data</a></p>
]]></content>
      <tags>
        <tag>学习网站</tag>
      </tags>
  </entry>
  <entry>
    <title>__builtin_系列函数</title>
    <url>/p/7e0b4172.html</url>
    <content><![CDATA[<p><strong>__builtin_ffs (unsigned int x)</strong><br>返回x的最后一位1的是从后向前第几位，比如8（1000）返回4。</p>
<span id="more"></span>

<p><strong>__builtin_clz (unsigned int x)</strong><br>返回前导的0的个数。<br><strong>__builtin_ctz (unsigned int x)</strong><br>返回后面的0个个数，和__builtin_clz相对。<br><strong>__builtin_popcount (unsigned int x)</strong><br>返回二进制表示中1的个数。<br><strong>__builtin_parity (unsigned int x)</strong><br>返回x的奇偶校验位，也就是x的1的个数模2的结果。</p>
<p>这些函数都有相应的usigned long和usigned long long版本，只需要在函数名后面加上l或ll就可以了，比如 __builtin_clzll。</p>
<p>版权声明：本文为CSDN博主「Yuer-」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/yuer158462008/article/details/46383635">https://blog.csdn.net/yuer158462008/article/details/46383635</a></p>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>频率</title>
    <url>/p/f5e3c4bd.html</url>
    <content><![CDATA[<h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>假设我们需要修改cpu0的频率。</p>
<span id="more"></span>

<h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><p>首先需要进入/sys/devices/system/cpu/cpu0/cpufreq目录。该目录下文件如下图所示：</p>
<img src="/p/f5e3c4bd/cpufreq.PNG" class title="图1 cpufreq">

<p>前缀cpuinfo代表的是cpu硬件上支持的频率，而scaling前缀代表的是可以通过CPUFreq系统用软件进行调节时所支持的频率。cpuinfo_cur_freq代表通过硬件实际上读到的频率值，而scaling_cur_freq则是软件当前的设置值，多数情况下这两个值是一致的，但是也有可能因为硬件的原因，有微小的差异。</p>
<p>从图中不难发现，只有scaling_governor，scaling_max_freq，scaling_min_freq，scaling_setspeed四个文件可以编辑。首先是scaling_governor。它的取值范围在scaling_available_governors中。scaling_available_governors保存了系统支持的电源策略，conservative (保守)，powersave（节能），ondemand（请求），performance（性能），userspace模式。</p>
<img src="/p/f5e3c4bd/governor.PNG" class title="图2 governor">

<p>ondemand策略的主要思想是：只要cpu的负载超过某一个阀值，cpu的频率会立刻提升至最高，然后再根据实际情况降到合适的水平。scaling_driver则会输出当前使用哪一个驱动来设置cpu的工作频率。</p>
<p>当我们选择userspace作为我们的调频governor时，我们可以通过scaling_setspeed手工设置需要的频率。powersave则简单地使用最低的工作频率进行运行，而performance则一直选择最高的频率进行运行。</p>
<p>我们需要设定cpu0的频率，则需要将scaling_governor内写入userspace。</p>
<p>另外，scaling_setspeed是设置频率。可以选择的频率值通过scaling_available_frequencies查看。</p>
<img src="/p/f5e3c4bd/freq.PNG" class title="图3 freq">

<p>我们需要设定cpu0的频率，则需要将scaling_setspeed内写入需要的频率。</p>
<p>所以需要修改cpu0的频率，只需要执行以下指令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo userspace &gt; scaling_governor</span><br><span class="line">echo 1100000 &gt; scaling_setspeed</span><br></pre></td></tr></table></figure>

<p>修改完毕后，执行s-tui查看结果。</p>
<img src="/p/f5e3c4bd/result.PNG" class title="图3 result">

<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://blog.csdn.net/zhangyongfeiyong/article/details/53506362">https://blog.csdn.net/zhangyongfeiyong/article/details/53506362</a></p>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>SGX创建过程</title>
    <url>/p/ccbadbc2.html</url>
    <content><![CDATA[<p>本文内容源自《Intel Software Developer’s Manual: Volumn 3》2023 年 3 月版本。</p>
<span id="more"></span>

<p>enclave 创建过程主要包括以下步骤：<br></p>
<ol>
<li>应用提交 enclave 内容和创建 enclave 的 API 需要的额外信息给运行在 <font color="#FF0000"> 特权级为0 </font> 的 enclave 创建服务；</li>
<li>运行在 0 特权级的 enclave 创建服务使用 ECREATE 叶函数去初始化环境，声明 enclave 基地址和大小。这个范围是应用地址空间的一部分，称为 ELRANGE。ECREATE 还为 SECS 分配 EPC 页面。<font color="#FF0000"> 注意为 SECS 分配的 EPC 页面不必在 encalve 线性地址空间内，也不需要映射到进程</font>；</li>
<li>Enclave 创建服务使用 EADD 叶函数提交 EPC 页面到 enclave，使用 EEXTEND 计算 enclave 提交页面的测度。对于将要加入 enclave 的每个页面：使用 EADD 将新页面加入到 enclave；如果 enclave 开发人员需要页面的测度作为内容的证明，则使用 EEXTEND 计算页面 256 字节的测度，重复该步骤直到整个页面都被计算；</li>
<li>Enclave 创建服务使用 EINIT 叶函数完成 enclave 的创建过程，结束 enclave 测度计算并创建 enclave 实体。在 EINIT 执行之前，不允许执行 enclave 内部代码。</li>
</ol>
<h2 id="ECREATE"><a href="#ECREATE" class="headerlink" title="ECREATE"></a>ECREATE</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>指令：ENCLS[ECREATE]</p>
<p>参数：EAX = 00H（输入）；RBX: PAGEINFO 地址（输入）；RCX: 目标 SECS 页面地址（输入）</p>
<p>ENCLS[ECREATE] 是 enclave 构建进程执行的第一条指令。ECREATE 拷贝外部的 SECS 到 EPC 页面中，之后内部的 SECS 不能被软件获取。</p>
<p>ECREATE 会初始化受保护的 SECS，并检查未使用的字段是否为0，并将其对应的 EPC 页面设置为 VALID 状态。 </p>
<p>应用提交的源 SECS 需要设置以下字段：BASEADDR，SIZE，ATTRIBUTES，CONFIGID，CONFIGSVN。SIZE 至少两个页面，BASEADDR 与 SIZE 边界对齐。</p>
<p>RBX 参数包含 PAGEINFO 的有效地址，PAGEINFO 包含源 SECS 的地址（SRCPAGE 字段）和 SECINFO 地址。PAGEINFO 的 SECS 字段未使用。SECINFO 字段必须指定 EPC 页面为 SECS 页面类型。</p>
<p>RCX 参数是目标 SECS 页面地址，该地址指向一个空白的 EPC 页面。</p>
<h3 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h3><table>
    <tr>
        <th>PAGEINFO</th><th>PAGEINFO.SRCPGE</th><th>PAGEINFO.SECINFO</th><th>EPCPAGE</th>
    </tr>
    <tr>
        <td> 允许 non-enclave 读 </td> <td> 允许 non-enclave 读 </td> <td> 允许 non-enclave 读 </td> <td> 允许 enclave 写 </td>
    </tr>
</table>

<h3 id="并发限制"><a href="#并发限制" class="headerlink" title="并发限制"></a>并发限制</h3><table>
    <tr>
        <th rowspan="2">Leaf function</th><th rowspan="2">Parameter</th><th colspan="3">Base Concurrency Restrictions</th>
    </tr>
    <tr>
        <th> Access</th><th>On Conflict</th><th>SGX_CONFLICT VM Exit Qualification</th>
    </tr>
    <tr>
        <td>ECREATE</td><td>SECS[DS:RCX]</td><td>Exclusive</td><td>#GP</td><td>EPC_PAGE_CONFLICT_EXCEPTION</td>
    </tr>
</table>

<table>
    <th rowspan="3">Leaf function</th><th rowspan="3">Parameter</th><th colspan="6">Additional Concurrency Restrictions</th>
    
    <tr>
        <th colspan="2">vs. EACCEPT, EACCEPTCOPY, EMODPE, EMODPR, EMODT </th><th colspan="2">vs. EADD, EEXTEND, EINIT</th><th colspan="2">vs. ETRACK, ETRACKC</th>
    </tr>
    <th> Access</th><th>On Conflict</th><th> Access</th><th>On Conflict</th><th> Access</th><th>On Conflict</th>
    <tr>
        <td>ECREATE</td><td>SECS[DS:RCX]</td><td>Concurrent</td><td></td><td>Concurrent</td><td></td><td>Concurrent</td><td></td>
    </tr>
<table>

<h3 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h3><ol>
<li>检查 DS:RBX 是否 32 字节对齐，DS:ECX 是否 4K 字节对齐，不是则 #GP(0)；</li>
<li>检查 DS:RCX 是否指向一个 EPC，不是则 #PF(DS:RCX)；</li>
<li>检查 DS:RBX.SRCPGE 是否 4K 字节对齐, DS:RBX.SECINFO 是否 64 字节对齐，不是则 #GP(0)；</li>
<li>检查 DS:RBX.LINADDR 是否为 0，不是则 #GP(0)；检查 DS:RBX.SECS 是否为 0，不是则 #GP(0)；</li>
<li>检查 DS:RBX.SECINFO 保留字段是否为 0，不是则 #GP(0)；检查 DS:RBX.SECINFO.FLAG.PT 是否为 PT_SECS，不是则 #GP(0)；</li>
<li>如果 DS:RCX 指向的 EPC 页面正在使用，且正在进行 VMX non-root 操作，且 ENABLE_EPC_VIRTUALIZATION_EXTENSIONS，则：
    

<pre><code>VMCS.Exit_reason := SGX_CONFLICT; 
VMCS.Exit_qualification.code := EPC_PAGE_CONFLICT_EXCEPTION;  
VMCS.Exit_qualification.error := 0; 
VMCS.Guest-physical_address := &lt;&lt; translation of DS:RCX produced by paging &gt;&gt;;  
VMCS.Guest-linear_address := DS:RCX;  
Deliver VMEXIT;
</code></pre>
</li>
<li>如果 DS:RCX 指向的 EPC 页面正在使用，是则 #GP(0)；</li>
<li>检查 EPCM(DS:RCX).VALID 是否为 1，是则 #PF(DS:RCX)；</li>
<li><font color="#FF0000"> DS:RCX[32767:0] := DS:RBX.SRCPGE[32767:0]; </font> 注解：将 PAGEINFO 中 SRCPAGE 指向的页面拷贝到目标 SECS 中；</li>
<li>检查 XFRM 是否合法，且 DS:RCX.ATTRIBUTES.XFRM 最后两位为 3，不是则 #GP(0)；</li>
<li>检查 CET_ATTRIBUTES 是否合法，不是则 #GP(0)；判断伪代码如下（TMP_SECS 即 ECX）：

<pre><code>IF ((DS:TMP_SECS.ATTRIBUTES.CET = 0 and DS:TMP_SECS.CET_ATTRIBUTES ≠ 0) ||
(DS:TMP_SECS.ATTRIBUTES.CET = 0 and DS:TMP_SECS.CET_LEG_BITMAP_OFFSET ≠ 0) || 
(CPUID.(EAX=7, ECX=0):EDX[CET_IBT] = 0 and DS:TMP_SECS.CET_LEG_BITMAP_OFFSET ≠ 0) || 
(CPUID.(EAX=7, ECX=0):EDX[CET_IBT] = 0 and DS:TMP_SECS.CET_ATTRIBUTES[5:2] ≠ 0) || 
(CPUID.(EAX=7, ECX=0):ECX[CET_SS] = 0 and DS:TMP_SECS.CET_ATTRIBUTES[1:0] ≠ 0) || 
(DS:TMP_SECS.ATTRIBUTES.MODE64BIT = 1 and
(DS:TMP_SECS.BASEADDR + DS:TMP_SECS.CET_LEG_BITMAP_OFFSET) not canonical) || 
(DS:TMP_SECS.ATTRIBUTES.MODE64BIT = 0 and
(DS:TMP_SECS.BASEADDR + DS:TMP_SECS.CET_LEG_BITMAP_OFFSET) &amp; 0xFFFFFFFF00000000) || 
(DS:TMP_SECS.CET_ATTRIBUTES.reserved fields not 0) or
(DS:TMP_SECS.CET_LEG_BITMAP_OFFSET) is not page aligned)) 
THEN
    #GP(0); 
FI;
</code></pre>
</li>
<li>通过 CPUID.(EAX=12H, ECX=0):EBX[31:0] 判断 DS:RCX.MISCSELECT[31:0] 中的功能是不是全部支持，不支持则 #GP(0)；</li>
<li>计算当发生 AEX 时，enclave 需要保存的状态大小 TMP_XSIZE，并检查 TMP_XSIZE 是否大于 <font color="#FF0000"> DS:RCX.SSAFRAMESIZE*4096</font>，是则 #GP(0)；注解：DS:RCX.SSAFRAMESIZE 单位为 1 个页面；</li>
<li>检查 DS:RCX.BASEADDR 和 DS:RCX.SIZE 是否合法，不合法则 #GP(0)；<font color="#FF0000">注解：SIZE 至少两页面，且大小必须为 2 的幂，单位为字节；</font></li>
<li>检查 DS:RCX.ATTRIBUTES 中不包含 CR_SGX_ATTRIBUTES_MASK 不支持的属性；</li>
<li>检查 CONFIGID 和 CONFIGSVN 是否为 0 或 DS:TMP_SECS.ATTRIBUTES.KSS 不为 0，是则 #GP(0)；</li>
<li><font color="#FF0000">将 DS:RCX 设置为 Uninitialized，初始化 DS:RCX，计算 DS:RCX.MRENCLAVE；伪代码如下：</font>


<pre><code>Clear DS:TMP_SECS to Uninitialized;
DS:TMP_SECS.MRENCLAVE := SHA256INITIALIZE(DS:TMP_SECS.MRENCLAVE); 
DS:TMP_SECS.ISVSVN := 0;
DS:TMP_SECS.ISVPRODID := 0;
(* Initialize hash updates etc*)
Initialize enclave’s MRENCLAVE update counter;
(* Add “ECREATE” string and SECS fields to MRENCLAVE *) 
TMPUPDATEFIELD[63:0] := 0045544145524345H; // “ECREATE” 
TMPUPDATEFIELD[95:64] := DS:TMP_SECS.SSAFRAMESIZE; 
TMPUPDATEFIELD[159:96] := DS:TMP_SECS.SIZE;
IF (CPUID.(EAX=7, ECX=0):EDX[CET_IBT] = 1) 
    THEN
        TMPUPDATEFIELD[223:160] := DS:TMP_SECS.CET_LEG_BITMAP_OFFSET; 
    ELSE
        TMPUPDATEFIELD[223:160] := 0;
FI;
TMPUPDATEFIELD[511:160] := 0;
DS:TMP_SECS.MRENCLAVE := SHA256UPDATE(DS:TMP_SECS.MRENCLAVE, TMPUPDATEFIELD) 
INC enclave’s MRENCLAVE update counter;
(* Set EID *)
DS:TMP_SECS.EID := LockedXAdd(CR_NEXT_EID, 1);
(* Initialize the virtual child count to zero *) 
DS:TMP_SECS.VIRTCHILDCNT := 0;
(* Load ENCLAVECONTEXT with Address out of paging of SECS *)
&lt;&lt; store translation of DS:RCX produced by paging in SECS(DS:RCX).ENCLAVECONTEXT &gt;&gt;
</code></pre>
</li>
<li><font color="#FF0000">更新 EPCM(DS:RCX)，注意 RWX 字段都为 0，说明 SECS 页面不能被应用直接读/写/执行；伪代码如下：</font>
    

<pre><code>EPCM(DS:TMP_SECS).PT := PT_SECS;
EPCM(DS:TMP_SECS).ENCLAVEADDRESS := 0;
EPCM(DS:TMP_SECS).R := 0;
EPCM(DS:TMP_SECS).W := 0; 
EPCM(DS:TMP_SECS).X := 0;
(* Set EPCM entry fields *) 
EPCM(DS:RCX).BLOCKED := 0; 
EPCM(DS:RCX).PENDING := 0; 
EPCM(DS:RCX).MODIFIED := 0; 
EPCM(DS:RCX).PR := 0; 
EPCM(DS:RCX).VALID := 1;
</code></pre>
</li>
</ol>

<h2 id="EADD"><a href="#EADD" class="headerlink" title="EADD"></a>EADD</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>指令：ENCLS[ECREATE]</p>
<p>参数：EAX = 00H（输入）；RBX: PAGEINFO 地址（输入）；RCX: 目标 SECS 页面地址（输入）</p>
<p>当 SECS 被成功创建，enclave 页面通过 EADD 加入到 enclave。这包括将空闲的 EPC 页面转为 PT_REG 或 PT_TCS 类型。当调用 EADD 后，处理器会更新 EPCM 条目中的页面类型，enclave 访问页面的线性地址，页面的访问权限。它会将页面链接到输入的 SECS。EPCM 条目信息会被硬件利用去管理页面的访问控制。EADD 会记录 EPCM 的信息到 SECS 中存储的加密日志，并从 non-enclave 内存页面拷贝 4KB 数据到分配的 EPC 页面。</p>
<p>该函数从 non-enclave 内存页面拷贝数据到 EPC 页面，将 EPC 页面链接到 SECS 页面，最后存储线性地址和安全属性到 EPCM。enclave 偏移和安全属性会被计算测度并扩展到 SECS.MRENCLAVE。该指令只能在特权级为 0 时执行。</p>
<h3 id="权限-1"><a href="#权限-1" class="headerlink" title="权限"></a>权限</h3><h3 id="并发限制-1"><a href="#并发限制-1" class="headerlink" title="并发限制"></a>并发限制</h3><h3 id="算法描述-1"><a href="#算法描述-1" class="headerlink" title="算法描述"></a>算法描述</h3><h2 id="EEXTEND"><a href="#EEXTEND" class="headerlink" title="EEXTEND"></a>EEXTEND</h2><h3 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h3><h3 id="权限-2"><a href="#权限-2" class="headerlink" title="权限"></a>权限</h3><h3 id="并发限制-2"><a href="#并发限制-2" class="headerlink" title="并发限制"></a>并发限制</h3><h3 id="算法描述-2"><a href="#算法描述-2" class="headerlink" title="算法描述"></a>算法描述</h3><h2 id="EINIT"><a href="#EINIT" class="headerlink" title="EINIT"></a>EINIT</h2><h3 id="简介-3"><a href="#简介-3" class="headerlink" title="简介"></a>简介</h3><h3 id="权限-3"><a href="#权限-3" class="headerlink" title="权限"></a>权限</h3><h3 id="并发限制-3"><a href="#并发限制-3" class="headerlink" title="并发限制"></a>并发限制</h3><h3 id="算法描述-3"><a href="#算法描述-3" class="headerlink" title="算法描述"></a>算法描述</h3></table></table>]]></content>
      <tags>
        <tag>SGX</tag>
      </tags>
  </entry>
  <entry>
    <title>SGX访问控制</title>
    <url>/p/69e7e367.html</url>
    <content><![CDATA[<p>本文内容源自《Intel Software Developer’s Manual: Volumn 3》2023 年 3 月版本。</p>
<span id="more"></span>

<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>每个 enclave 都有一段 ELRANGE 地址空间，该地址空间采用增强的访问控制。另外，ELRANGE 中的每个线性地址都必须映射到一个 EPC 页面，否则当 enclave 访问该线性地址时会产生错误。EPC 页面在物理上不必连续。系统软件负责分配 EPC 页面到各个 enclave 中。</p>
<p>Enclave 必须遵守 OS/VMM 的段页式策略。enclave 访问内存时，会使用已有的 IA32 段页式结构。OS/VMM 管理的页表和扩展页表为 enclave 页面提供地址转换。</p>
<p>进入 enclave 必须使用以下两条指令：ENCLU[EENTER]，ENCLU[ERESUME]；<br>退出 enclave 必须使用以下命令或事件：ENCLU[EEXIT]，AEX。</p>
<p>当 non-enclave 尝试访问映射到 EPC 页面的线性地址时，处理器会为了保护 enclave 的保密性和完整性做出一些行动，但是具体的行为在不同的执行中可能不同。比如说读取 enclave 页面可能返回一个值或者缓存行中的密文；写 enclave 页面可能会造成写丢弃。</p>
<h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><p>直接 enclave 访问（Direct EA）：enclave 内部执行的指令获取 ELRANGE 内存。<br>间接 enclave 访问（Indirect EA）：由特定的 SGX leaf function 访问 EPC 页面。<br>Enclave Access：Direct EA 和 Indirect Access 统称 EA。<br>Non-enclave Access：不是 EA 的内存访问。</p>
<h2 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h2><p>enclave 访问需要遵循以下访问控制：</p>
<ol>
<li>所有的内存访问都要遵循段页式保护措施；</li>
<li>从 enclave 内部获取线性地址在 enclave 外部的代码会报 #GP(0)；</li>
<li>从 enclave 内部对在 enclave 外部的线性地址使用 shadow-stack-load 和 shadow-stack-store 会报 #GP(0)；</li>
<li>对 EPC 页面的 non-enclave 访问会造成未定义的错误；</li>
<li>当使用 ENCLS[ADD]，ENCLS[EAUG] 分配 EPC 页面时，如果 EPC 的类型为 PT_REG，PT_TCS，PT_TRIM，则 EPC 页面必须映射到 ELRANGE 的指定位置。当 PFEC.SGX 位设置时，通过其他线性地址访问 enclave 会产生 #PF。</li>
<li>直接 enclave 访问必须遵循 EPC 在 EPCM 中设置的安全属性。这些属性可以在 enclave 创建时定义，也可以使用 SGX2 相关指令修改。当 PFEC.SGX 位被设置时，检查失败会造成 #PF。直接 enclave 访问检查如下：<ul>
<li>目标页面必须属于当前执行的 enclave；</li>
<li>如果 EPCM 中设置 EPC 页面有读/写权限，则 EPC 的数据可读/写；</li>
<li>如果 EPCM 中设置 EPC 页面有执行权限，则可以从 EPC 页面中执行指令；</li>
<li>只有当页面类型是 PT_SS_FIRST 和 PT_SS_REST 时，才能对 EPC 页面使用 Shadow-stack-load和 Shadow-stack-store；</li>
<li>当页面类型是 PT_SS_FIRST 和 PT_SS_REST 时，不允许对 EPC 页面执行非 Shadow-stack-store 的写数据操作；</li>
<li>目标页面不允许是 PT_SECS，PT_TCS，PT_VA，PT_TRIM 类型；</li>
<li>EPC 页面的状态不能为 BLOCKED，PENDING，MODIFIED。</li>
</ul>
</li>
</ol>
<h2 id="基于段的访问控制"><a href="#基于段的访问控制" class="headerlink" title="基于段的访问控制"></a>基于段的访问控制</h2><p>SGX 架构不会更改逻辑 CPU 执行的段检查。为了保证外面的实体不会以一种未知的行为修改逻辑地址到线性地址的映射，ENCLU[ENTER] 和 ENCLU[ERESUME] 会检查 CS，DS，ES 和 SS 的段基地址为 0。非 0 的段基地址会产生 #GP(0)。</p>
<p>在进入 enclave 时，处理器会保存 FS 和 GS 的内容，并读取 TCS 中存放的这些寄存器的值。后续就可以通过这些寄存器获取 TCS 中本地线程的数据。在退出 enclave 时，进入 enclave 时保存的内容会被恢复。</p>
<h2 id="基于页的访问控制"><a href="#基于页的访问控制" class="headerlink" title="基于页的访问控制"></a>基于页的访问控制</h2><p>当处理器在 enclave 内部执行时，内存数据访问可以跨 ELRANGE，即访问的数据部分在 ELRANGE，部分在 ELRANGE 外。此时，该访问会分成两次访问，一次是 ELRANGE 内访问，一次是 ELRANGE 外访问。内次访问会单独测评。但是获取代码不能跨 ELRANGE，会造成 #GP。</p>
<h3 id="显式访问（Explicit-Access）和隐式访问（Implicit-Access）"><a href="#显式访问（Explicit-Access）和隐式访问（Implicit-Access）" class="headerlink" title="显式访问（Explicit Access）和隐式访问（Implicit Access）"></a>显式访问（Explicit Access）和隐式访问（Implicit Access）</h3><p>显式访问：SGX 指令的参数有显式声明获取的内存地址或链接的数据结构。<br>显式访问一般使用逻辑地址。它们的获取受限于分段，分页，扩展分页等，可能会触发检查相关的错误/退出。</p>
<p>隐式访问：访问在处理器中缓存物理地址的数据结构。<br>这些地址不会在指令中当作参数传递，而是在指令使用时暗示。</p>
<p>这些访问不会触发访问相关的错误/退出/断点。下图列举了 SGX 指令的内存对象是显式访问还是隐式访问。显式访问对象的地址一般通过寄存器传递：RBX，RCX，RDX。<br>隐式访问用到的物理地址被不同的物理地址缓存，且存在不同的周期。当EPC 页面被 ENCLS[EADD] 或 ENCLS[EAUG] 加入到 enclave，或被 ENCLS[ELDB] 或 ENCLS[ELDU] 读取时，每个 EPC 页面关联的 SECS 的物理地址会被缓存。当 EPC 页面被 ENCLS[EREMOVE] 或 ENCLS[EWB] 删除时，相关的 SECS 缓存会被刷新。在进入 enclave 时，TCS 和 SSA 的物理地址会被缓存。在退出时，刷新缓存。</p>
<p>隐式访问的物理地址会在逻辑地址检查完后访问。在处理器缓存前，需要有数据结构的逻辑地址，这个地址会触发检查，但是在处理器缓存后，物理地址就不会触发检查。</p>
<img src="/p/69e7e367/2.png" class title="图1 SGX 指令的显式访问和隐式访问">

<img src="/p/69e7e367/1.png" class title="图2 SGX 指令的显式访问和隐式访问">]]></content>
  </entry>
  <entry>
    <title>SGX数据结构</title>
    <url>/p/43899435.html</url>
    <content><![CDATA[<p>本文内容源自《Intel Software Developer’s Manual: Volumn 3》2023 年 3 月版本。</p>
<span id="more"></span>

<h2 id="SECS"><a href="#SECS" class="headerlink" title="SECS"></a>SECS</h2>]]></content>
      <tags>
        <tag>SGX</tag>
      </tags>
  </entry>
  <entry>
    <title>SGX 知识总结（一）</title>
    <url>/p/8cd79317.html</url>
    <content><![CDATA[<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><span id="more"></span>

<a href="#">Post not found: SGX访问控制 SGX访问控制</a>
<a href="#">Post not found: SGX数据结构 SGX数据结构</a>
<a href="#">Post not found: SGX创建过程 SGX创建过程</a>
]]></content>
      <tags>
        <tag>SGX</tag>
      </tags>
  </entry>
  <entry>
    <title>Genetic Algorithm</title>
    <url>/p/e830ed97.html</url>
    <content><![CDATA[<h3 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h3><p>Genetic Algorithms 遗传算法</p>
<p>chromosome 染色体</p>
<p>Gene 基因</p>
]]></content>
      <tags>
        <tag>资源调度</tag>
      </tags>
  </entry>
  <entry>
    <title>A*</title>
    <url>/p/7300a56d.html</url>
    <content><![CDATA[]]></content>
      <tags>
        <tag>资源调度</tag>
      </tags>
  </entry>
  <entry>
    <title>资源调度算法调研（一）</title>
    <url>/p/bcc3e70e.html</url>
    <content><![CDATA[<h2 id="传统算法-1"><a href="#传统算法-1" class="headerlink" title="传统算法[1]"></a>传统算法<sup>[1]</sup></h2><span id="more"></span>

<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p><font color="#FF0000">metatask</font>: a collection of independent tasks with no intertask data dependencies;</p>
<p><font color="#FF0000">&tau;</font>: The size of the metatask (i.e., the number of tasks to execute);</p>
<p><font color="#FF0000">&mu;</font>: the number of machines in the HC suite;</p>
<p>&tau; and &mu; are static and known beforehand.</p>
<p>It is assumed that an accurate estimate of the expected execution time for each task on each machine is known prior to execution and contained within a &tau;*&mu; ETC (expected time to compute) matrix;</p>
<p>It is also assumed that each machine executes a single task at a time.</p>
<p><font color="#FF0000">Machine availability time, mat(m<sub>j</sub>)</font>：the earliest time machine m<sub>j</sub> can complete the execution of all the tasks that have previously been assigned to it (based on the ETC entries for those tasks). </p>
<p><font color="#FF0000">The completion time for a new task t<sub>i</sub> on machine m<sub>j</sub> , ct(t<sub>i</sub> , m<sub>j</sub>)</font>: the machine availability time for m<sub>j</sub> plus the execution time of task t<sub>i</sub> on machine m<sub>j</sub> , i.e., ct(t<sub>i</sub> , m<sub>j</sub>)= mat(m<sub>j</sub>)+ETC(t<sub>i</sub> , m<sub>j</sub>). </p>
<p>The performance criterion used to compare the results of the heuristics is the maximum value of ct(t<sub>i</sub> , m<sub>j</sub>), for  0 &le; i &lt; &tau; and 0 &le; j &lt; &mu;. The maximum ct(t<sub>i</sub> , m<sub>j</sub>) value, over 0 &le; i &lt; &tau; and 0 &le; j &lt; &mu;, is the metatask execution time, and is called the <font color="#FF0000">makespan</font> . </p>
<p>Each heuristic is attempting to minimize the makespan, i.e., finish execution of the metatask as soon as possible.</p>
<h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><table>
<thead>
<tr>
<th align="center">算法</th>
<th align="left"><p align="middle">描述</p></th>
<th align="left"><p align="middle">优点</p></th>
<th align="left"><p align="middle">缺点</p></th>
</tr>
</thead>
<tbody><tr>
<td align="center">Opportunistic Load Balancing (OLB)</td>
<td align="left">OLB算法会将负载随机交给一个可用的节点，不管任务执行的时间。动机是尽量保持所有的机器忙碌。</td>
<td align="left"><p align="middle">简单</p></td>
<td align="left">poor makespan</td>
</tr>
<tr>
<td align="center">Minimum Execution Time (MET)</td>
<td align="left">MET会将任务分配给对于该任务，有着最小执行时间的机器，不管机器何时可用。动机是尽量将任务分配给最适合它的机器。</td>
<td align="left"></td>
<td align="left">会造成严重的负载不均衡</td>
</tr>
<tr>
<td align="center">Minimum Completion Time (MCT)</td>
<td align="left">MCT会将任务分配给对于该任务，有着最小完成时间的机器。</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="center">Min-min</td>
<td align="left">U：unmapped tasks；M={min<sub>0&le;j&lt;&mu;</sub>(ct(t<sub>i</sub> , m<sub>j</sub>)), for each t<sub>i</sub> &in;U}；M中最小的任务分配给对应的机器，之后将该任务移除，重复该步骤直到U为空。</td>
<td align="left">good makespan</td>
<td align="left">执行长任务而带来延迟。比如：当有很多短任务和一个很长的任务，会由于最后执行长任务而带来极大的开销</td>
</tr>
<tr>
<td align="center">Max-min</td>
<td align="left">U：unmapped tasks；M={min<sub>0&le;j&lt;&mu;</sub>(ct(t<sub>i</sub> , m<sub>j</sub>)), for each t<sub>i</sub> &in;U}；<br>M中最大的任务分配给对应的机器，之后将该任务移除，重复该步骤直到U为空。</td>
<td align="left">最小化由于执行长任务而带来的延迟。比如：当有很多短任务和一个很长的任务，Min-Min会由于最后执行长任务而带来极大的开销，这时Max-Min算法会更优。</td>
<td align="left">其他时候调度策略都不够好。短任务的等待时间过长。</td>
</tr>
<tr>
<td align="center">Duplex</td>
<td align="left">会同时执行Min-Min和Max-Min，然后选择更好的一个</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="center">Round-Robin(RR)</td>
<td align="left">Round-Robin 算法将负载均匀的发放给各个节点。当使用这个算法时，调度器会循环的将VM分配给节点。比如：3个节点，第一个请求到达时，分配给第一个节点，第二个请求到达时，分配给第二个节点，第三个请求到达时分配给第三个节点，第四个请求到达时又分配给第一个节点，以此类推。</td>
<td align="left">能均匀的利用所有的资源，保障了公平性</td>
<td align="left">没有考虑任务的执行时间和资源使用情况。</td>
</tr>
<tr>
<td align="center">Power Save Algorithm</td>
<td align="left">在调度器分配了VM后，检查是否有空闲的节点，有的话就关掉。等到有请求需要分配到该节点时，再打开该节点。</td>
<td align="left">考虑能耗问题</td>
<td align="left"></td>
</tr>
<tr>
<td align="center">Genetic Algorithms (GA)</td>
<td align="left">initial population genetation;<br>evaluation;<br>while(stopping criteria not met){<br>&emsp;selection;<br>&emsp;crossover;<br>&emsp;mutation;<br>&emsp;evaluation;<br>}<br>output best solution;<br>具体算法可以参考<a href="#">Post not found: 遗传算法 Genetic Algorithm</a></td>
<td align="left">Genetic Algorithms (GAs) are a technique used for searching large solution spaces.  GA usually found the best mappings of all 11 heuristics.</td>
<td align="left">调度时间长</td>
</tr>
<tr>
<td align="center">Simulated Annealing (SA)</td>
<td align="left">具体算法可以参考<a href="/p/ba79e3d5.html" title="Simulated Annealing">Simulated Annealing</a></td>
<td align="left"></td>
<td align="left">可能会找到比Min-Min和GA更差的解决办法；调度时间较长</td>
</tr>
<tr>
<td align="center">Genetic Simulated Annealing (GSA)</td>
<td align="left">a combination of the GA and SA techniques . In general, GSA follows procedures similar to the GA outlined above. However, for the selection process, GSA uses the SA cooling schedule and system temperature and a simplified SA decision process for accepting or rejecting a new chromosome.</td>
<td align="left"></td>
<td align="left">调度时间长</td>
</tr>
<tr>
<td align="center">Tabu</td>
<td align="left"><img src="/p/bcc3e70e/tabu.PNG" class title="图1 tabu"><br>具体算法可以参考<a href="/p/5b9a6a68.html" title="Tabu">Tabu</a></td>
<td align="left"></td>
<td align="left">调度时间较长</td>
</tr>
<tr>
<td align="center">A*</td>
<td align="left">具体算法可以参考<a href="#">Post not found: A-算法 A*</a></td>
<td align="left"></td>
<td align="left">调度时间很长</td>
</tr>
</tbody></table>
<h3 id="总体评价："><a href="#总体评价：" class="headerlink" title="总体评价："></a>总体评价：</h3><ul>
<li>基本没有考虑能耗情况，所有的节点都是一开始就准备好，一直开启；</li>
<li>假设很多也已经不符合现在的情况，比如：现在一个节点都是多线程任务，很少一个机器一个时间只有一个任务执行；</li>
<li>很少考虑节点是否有充足的资源，这可能是因为一个时间一个机器只有一个任务，也就是说，在一个时间，机器所有的资源都会给到该任务，所以不考虑，但是，在多进程的环境下，资源问题也需要考虑；</li>
<li>不支持热迁移</li>
<li>这些算法都是静态的算法，有些还是批处理的，提前会知道很多信息。</li>
</ul>
<h2 id="论文算法"><a href="#论文算法" class="headerlink" title="论文算法"></a>论文算法</h2><h3 id="AN-ADAPTIVE-ALGORITHM-FOR-DYNAMIC-PRIORITY-BASED-VIRTUAL-MACHINE-SCHEDULING-IN-CLOUD-2"><a href="#AN-ADAPTIVE-ALGORITHM-FOR-DYNAMIC-PRIORITY-BASED-VIRTUAL-MACHINE-SCHEDULING-IN-CLOUD-2" class="headerlink" title="AN ADAPTIVE ALGORITHM FOR DYNAMIC PRIORITY BASED VIRTUAL MACHINE SCHEDULING IN CLOUD[2]"></a>AN ADAPTIVE ALGORITHM FOR DYNAMIC PRIORITY BASED VIRTUAL MACHINE SCHEDULING IN CLOUD<sup>[2]</sup></h3><h4 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: None</span><br><span class="line">Output: None</span><br><span class="line">Algorithm sched_priority</span><br><span class="line">&#123; </span><br><span class="line">	If(P1 is not set)</span><br><span class="line">		P1&#x3D;max available resource node</span><br><span class="line">		If(P1 is turned OFF)</span><br><span class="line">			Turn P1 ON</span><br><span class="line">	If(load factor of P1&lt;0.8)</span><br><span class="line">		Assign VM to P1</span><br><span class="line">	Else if(P2 is set AND load factor of P2&lt;0.8)</span><br><span class="line">		Swap P1 and P2;</span><br><span class="line">		Assign VM to P1;</span><br><span class="line">	Else</span><br><span class="line">		P2&#x3D;P1</span><br><span class="line">		P1&#x3D;current max available resource node </span><br><span class="line"> </span><br><span class="line">		If(P1 is turned OFF)</span><br><span class="line">			Turn P1 ON</span><br><span class="line">		Assign VM to P1;</span><br><span class="line">	Turn OFF all unused nodes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><p>在初始状态下，P1和P2都是没有设置的。当一个请求到达时，会判断是否设置了P1，如果没有设置P1，则将P1设置为拥有最多空闲资源的节点，如果此时该节点没有开启，则将该节点开启；之后判断P1的负载因子是否小于0.8，如果小于0.8，说明P1还能够放其他资源，就将资源放入P1对应的节点中；如果P1的负载因子大于0.8，P2被设置了且负载因子小于0.8，则交换P1和P2，将资源交给P1对应的节点；如果P2没有被设置，或者负载因子也大于0.8，则将P2设置为P1的节点，并将P1设置为当前拥有空闲资源最多的节点。最后，关掉那些没有使用的空闲节点。</p>
<h4 id="评析"><a href="#评析" class="headerlink" title="评析"></a>评析</h4><p>优点：考虑了能源问题，在有空闲节点时，能够关闭掉那些空闲的节点；可拓展性较好；给了伪代码；<br>缺点：实验简单，虚拟机的数量过少，只有10个虚拟机，实验过程省略了；缺少热迁移的考虑，即缺少任务整合的部分，那么，是否可以在此基础上增加一个任务整合的模块？即当某个主机的负载低于某个阈值，比如10%时，将主机的内容迁移到其他主机上，并将该主机关闭；资源分很多种，比如：内存，vcpu等等，不同类型一次申请的量可能不同，可能在某一负载下只能满足其中部分，不能满足全部；。</p>
<h3 id="Dynamic-Round-Robin-DRR-3"><a href="#Dynamic-Round-Robin-DRR-3" class="headerlink" title="Dynamic Round-Robin (DRR)[3]"></a>Dynamic Round-Robin (DRR)<sup>[3]</sup></h3><p>DRR是在传统RR的基础上，增加了两条规则：第一，在一个虚拟机结束时，该主机将不会接受新的虚拟机，这种状态称为“退休状态”，等该主机的所有VM都结束，关闭该主机；第二，如果主机在“退休状态”呆了足够长的时间，就将主机的所有VM热迁移到其他主机，然后将主机关闭。</p>
<h4 id="评析-1"><a href="#评析-1" class="headerlink" title="评析"></a>评析</h4><p>优点：考虑了能耗；支持live migration；<br>缺点：没有源代码；实验部分阐述过于简单，没有说明实验的环境，数据量大小，甚至过程都省略了；没有参考文献；如果同时有很多主机的虚拟机都同时结束了，那么这些主机都不能接受新的虚拟机，那么当新的虚拟机到来时，就只能轮询少量的虚拟机，这可能会使少部分的虚拟机过度使用；传统Round-Robin的问题也会发生在这里，比如：故障处理；如果虚拟机退出时，该主机有很多的虚拟机，迁移的开销就会很高。</p>
<h3 id="Power-Aware-Load-Balancing-for-Cloud-Computing（PALB）-4"><a href="#Power-Aware-Load-Balancing-for-Cloud-Computing（PALB）-4" class="headerlink" title="Power Aware Load Balancing for Cloud Computing（PALB）[4]"></a>Power Aware Load Balancing for Cloud Computing（PALB）<sup>[4]</sup></h3><h4 id="伪代码-1"><a href="#伪代码-1" class="headerlink" title="伪代码"></a>伪代码</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">balance:</span><br><span class="line">	for all active compute nodes j ∈ [m] do</span><br><span class="line">		n[j] &#x3D; current utilization of compute node j</span><br><span class="line">	end for</span><br><span class="line">	if all n[j] &gt; 75% utilization &#x2F;&#x2F;all available nodes are active</span><br><span class="line">		boot vm on most underutilized n[j]</span><br><span class="line">	end if</span><br><span class="line">	else</span><br><span class="line">		boot vm on most utilized n[j], which can also fulfill requirements</span><br><span class="line">	end else</span><br><span class="line">upscale:</span><br><span class="line">	if each n[j] &gt; 75% utilization</span><br><span class="line">		if n[j] &lt; m</span><br><span class="line">			boot compute node n[j+1]</span><br><span class="line">		end if</span><br><span class="line">	end if</span><br><span class="line">downscale:</span><br><span class="line">	if vmi idle &gt; 6 hours or user initiated shutdown</span><br><span class="line">		shutdown vmi</span><br><span class="line">	end if</span><br><span class="line">	if n[j] has no active vm</span><br><span class="line">		shutdown n[j]</span><br><span class="line">	end if</span><br></pre></td></tr></table></figure>



<h4 id="说明-1"><a href="#说明-1" class="headerlink" title="说明"></a>说明</h4><p>该算法的目标是在维持节点可用性的同时，降低能耗。该算法主要有三个过程：balance，upscale，downscale。</p>
<ul>
<li>balance过程确定虚拟机应该安装的位置。首先获取当前所有活跃节点的利用率，当所有结点的利用率都大于75%时，将虚拟机分配到利用率最低的节点，否则将虚拟机分配到利用率最高的，且可以满足需求的节点。</li>
<li>upscale过程是当所有虚拟机节点的利用率都大于75%时，创建一个新的虚拟机</li>
<li>downscale过程是当虚拟机长时间闲置时，关闭虚拟机，而当一个主机没有活跃的虚拟机时，关闭主机。</li>
</ul>
<h4 id="评析-2"><a href="#评析-2" class="headerlink" title="评析"></a>评析</h4><p>优点：实验做得比较详细，说明了实验环境和步骤；考虑了能源因素，能够将长时间未使用的虚拟机关掉，将未使用的主机关掉；资源利用率高；考虑了异质的问题<br>缺点：为考虑热迁移，即如果一个主机的负载过低，将主机的虚拟机迁移，之后关闭虚拟机；在虚拟机运行的时候，并不是满负载的，对于申请时要求的资源小于实际使用的资源的情况缺少考虑；实验部分虚拟机个数有点少，只测试了20个和30个虚拟机。</p>
<h3 id="Load-Balanced-Min-Min-Algorithm-LBMM-5"><a href="#Load-Balanced-Min-Min-Algorithm-LBMM-5" class="headerlink" title="Load Balanced Min-Min Algorithm(LBMM)[5]"></a>Load Balanced Min-Min Algorithm(LBMM)<sup>[5]</sup></h3><h4 id="伪代码-2"><a href="#伪代码-2" class="headerlink" title="伪代码"></a>伪代码</h4><p><strong>CT<sub>i</sub><sub>j</sub></strong>: completion time of task i on machines j </p>
<p><strong>ET<sub>i</sub><sub>j</sub></strong>: expected execution time of job i on resource j  </p>
<p><strong>Rj</strong>: ready time or availability time of resource j after  completing the previously assigned jobs.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for all tasks Ti </span><br><span class="line">	for all resources </span><br><span class="line">		Cij&#x3D;Eij+rj </span><br><span class="line">	do until all tasks are mapped </span><br><span class="line"> 		for each task find the earliest completion time and the resource that obtains it </span><br><span class="line">		find the task Tk with the minimum earliest completion time </span><br><span class="line">		assign task Tk to the resource Rl that gives the earliest completion time </span><br><span class="line">		delete task Tk from list</span><br><span class="line">		update ready time of resource Rl</span><br><span class="line">		update Cil for all i </span><br><span class="line">	end do </span><br><span class="line">&#x2F;&#x2F; rescheduling to balance the load</span><br><span class="line">sort the resources in the order of completion time</span><br><span class="line">for all resources R</span><br><span class="line">	Compute makespan &#x3D; max(CT(R))</span><br><span class="line">End for</span><br><span class="line">for all resources</span><br><span class="line">	for all tasks</span><br><span class="line">		find the task Ti that has minimum ET in Rj</span><br><span class="line">		find the MCT of task Ti</span><br><span class="line">		if MCT &lt; makespan</span><br><span class="line">			Reschedule the task Ti to the resource that produces it </span><br><span class="line">			Update the ready time of both resources</span><br><span class="line">		End if</span><br><span class="line">	End for</span><br><span class="line">End for</span><br><span class="line">&#x2F;&#x2F;Where MCT represents Maximum Completion Time</span><br></pre></td></tr></table></figure>

<h4 id="说明-2"><a href="#说明-2" class="headerlink" title="说明"></a>说明</h4><p>这个算法是为了解决在Min-Min算法长任务滞后带来的问题。该算法主要分成两个部分，第一部分使用传统的Min-Min算法得到一般的解决方案；第二部分对第一部分的解决方案进行重新调度，首先将所有的节点根据完成时间进行排序，然后对每个节点中的每个任务进行调度，如果再次调度后可以得到更小的最大完成时间，则将任务进行调度，并更新信息。</p>
<h4 id="评析-3"><a href="#评析-3" class="headerlink" title="评析"></a>评析</h4><p>优点：在原来Min-Min的基础上增加了重新调度的过程，降低了makespan<br>缺点：没有摆脱传统算法的限制，直接使用传统算法的假设，因此，传统算法的缺点这个方法仍然有；实验过于简单，最后资源的实验说的很含糊</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[1] Braun T D ,  Siegel H J ,  Beck N , et al. A Comparison of Eleven Static Heuristics for Mapping a Class of Independent Tasks onto Heterogeneous Distributed Computing Systems[J]. Journal of Parallel &amp; Distributed Computing, 2001, 61(6):810-837.</p>
<p>[2] Subramanian S ,  Krishna N G ,  Kumar K M , et al. An Adaptive Algorithm for Dynamic Priority Based Virtual Machine Scheduling in Cloud[J]. International Journal of Computer Science Issues, 2012, 9(6).</p>
<p>[3] Lin C C ,  Liu P ,  Wu J J . Energy-Aware Virtual Machine Dynamic Provision and Scheduling for Cloud Computing[J]. IEEE, 2011.</p>
<p>[4] Galloway J M ,  Smith K L ,  Vrbsky S S . Power Aware Load Balancing for Cloud Computing[J]. lecture notes in engineering &amp; computer science, 2011.</p>
<p>[5] Kokilavani T ,  Amalarethinam D G . Load Balanced MinMin Algorithm for Static MetaTask Scheduling in Grid Computing[J]. International Journal of Computer Applications, 2011, 20(2):42-48.</p>
]]></content>
      <tags>
        <tag>资源调度</tag>
      </tags>
  </entry>
  <entry>
    <title>Tabu</title>
    <url>/p/5b9a6a68.html</url>
    <content><![CDATA[]]></content>
      <tags>
        <tag>资源调度</tag>
      </tags>
  </entry>
  <entry>
    <title>Simulated Annealing</title>
    <url>/p/ba79e3d5.html</url>
    <content><![CDATA[]]></content>
      <tags>
        <tag>资源调度</tag>
      </tags>
  </entry>
  <entry>
    <title>Unikernel简述</title>
    <url>/p/486c1af5.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>unikernel知识总结</title>
    <url>/p/c8f61804.html</url>
    <content><![CDATA[<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><span id="more"></span>

<a href="#">Post not found: Unikernel简述 Unikernel简述</a>

<a href="#">Post not found: Unikraft Unikraft</a>]]></content>
      <tags>
        <tag>unikernel</tag>
      </tags>
  </entry>
  <entry>
    <title>Unikraft</title>
    <url>/p/8e98bdb9.html</url>
    <content><![CDATA[<h1 id="什么是-Unikraft"><a href="#什么是-Unikraft" class="headerlink" title="什么是 Unikraft"></a>什么是 Unikraft</h1><span id="more"></span>
<p>参考文献：</p>
<h1 id="Unikraft-安装"><a href="#Unikraft-安装" class="headerlink" title="Unikraft 安装"></a>Unikraft 安装</h1><p>源代码地址：<br><a href="https://github.com/unikraft/unikraft">https://github.com/unikraft/unikraft</a></p>
<p>安装 kraft： </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl --proto &#39;&#x3D;https&#39; --tlsv1.2 -sSf https:&#x2F;&#x2F;get.kraftkit.sh | sh</span><br></pre></td></tr></table></figure>

<p>参考网页：<br><a href="https://github.com/unikraft/kraftkit">https://github.com/unikraft/kraftkit</a><br><a href="https://unikraft.org/docs/getting-started">https://unikraft.org/docs/getting-started</a></p>
<h1 id="Unikraft-调试"><a href="#Unikraft-调试" class="headerlink" title="Unikraft 调试"></a>Unikraft 调试</h1><p><a href="https://www.youtube.com/watch?v=ANm0diPrWUE">https://www.youtube.com/watch?v=ANm0diPrWUE</a><br><a href="https://users.ece.utexas.edu/~adnan/gdb-refcard.pdf">https://users.ece.utexas.edu/~adnan/gdb-refcard.pdf</a></p>
<p>qemu-system-x86_64  -s -S -kernel build/helloworld_qemu-x86_64 -nographic</p>
<p>gdb –eval-command=”target remote :1234” build/helloworld_qemu-x86_64.dbg</p>
<h1 id="Unikraft-qemu-x86-64启动流程"><a href="#Unikraft-qemu-x86-64启动流程" class="headerlink" title="Unikraft qemu-x86-64启动流程"></a>Unikraft qemu-x86-64启动流程</h1><p>源码版本：0.14.0</p>
<h2 id="寻找入口函数"><a href="#寻找入口函数" class="headerlink" title="寻找入口函数"></a>寻找入口函数</h2><p>方法 1：阅读 plat/kvm/Linker.uk：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ifeq (x86_64,$(CONFIG_UK_ARCH))</span><br><span class="line">ifeq ($(CONFIG_KVM_BOOT_PROTO_MULTIBOOT),y)</span><br><span class="line">KVM_LDFLAGS-y +&#x3D; -Wl,-m,elf_x86_64</span><br><span class="line">KVM_LDFLAGS-y +&#x3D; -Wl,--entry&#x3D;_multiboot_entry</span><br><span class="line">ELF64_TO_32 &#x3D; y</span><br><span class="line">else ifeq ($(CONFIG_KVM_BOOT_PROTO_LXBOOT),y)</span><br><span class="line">KVM_LDFLAGS-y +&#x3D; -Wl,--entry&#x3D;_lxboot_entry</span><br><span class="line">else ifeq ($(CONFIG_KVM_BOOT_PROTO_EFI_STUB),y)</span><br><span class="line">KVM_LDFLAGS-y +&#x3D; -Wl,--entry&#x3D;uk_efi_entry64</span><br><span class="line">KVM_LDFLAGS-y +&#x3D; -Wl,-m,elf_x86_64</span><br><span class="line">endif</span><br></pre></td></tr></table></figure>

<p>从这里可以看出，当使用 multiboot 作为启动协议时，入口函数为 _multiboot_entry。</p>
<p>方法 2：阅读 elf 文件。<br>以 helloworld 为例，使用以下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">readelf -a build&#x2F;helloworld_qemu-x86_64.dbg</span><br></pre></td></tr></table></figure>
<p>查看 Entry point address 选项：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Entry point address:               0x125f88</span><br></pre></td></tr></table></figure>
<p>可知入口地址为 0x125f88。再进行反汇编：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">objdump -ld -C -S build&#x2F;helloworld_qemu-x86_64.dbg &gt; helloworld.txt</span><br></pre></td></tr></table></figure>
<p>查看 helloworld.txt 文件，并找到地址为 0x125f88 的函数：_multiboot_entry。</p>
<h2 id="multiboot"><a href="#multiboot" class="headerlink" title="multiboot"></a>multiboot</h2><p><a href="https://www.gnu.org/software/grub/manual/multiboot/multiboot.html">https://www.gnu.org/software/grub/manual/multiboot/multiboot.html</a></p>
<h2 id="qemu-x86-64-启动源码阅读"><a href="#qemu-x86-64-启动源码阅读" class="headerlink" title="qemu-x86-64 启动源码阅读"></a>qemu-x86-64 启动源码阅读</h2><p>由于使用 multiboot 启动，所以启动时的状态为：</p>
<ul>
<li>EAX包含一个魔数；</li>
<li>EBX包含 multiboot 信息的32位物理地址；</li>
<li>Flat 4GiB CS 和 DS 段，其中 ES、FS、GS 和 SS 设置为 DS；</li>
<li>A20 已启用，启用保护模式，禁用分页，禁用中断。</li>
</ul>
<h3 id="multiboot-entry"><a href="#multiboot-entry" class="headerlink" title="_multiboot_entry"></a>_multiboot_entry</h3><p>从 plat/kvm/x86/multiboot.S 的 _multiboot_entry 开始阅读。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;* 与 multiboot 协议相关。*&#x2F;</span><br><span class="line">#define MULTIBOOT_FLAGS (MULTIBOOT_PAGE_ALIGN | MULTIBOOT_MEMORY_INFO)</span><br><span class="line"></span><br><span class="line">.section .data.boot</span><br><span class="line"></span><br><span class="line">.align 4</span><br><span class="line">multiboot_header:</span><br><span class="line">	.long MULTIBOOT_HEADER_MAGIC</span><br><span class="line">	.long MULTIBOOT_FLAGS</span><br><span class="line">	.long -(MULTIBOOT_HEADER_MAGIC+MULTIBOOT_FLAGS) &#x2F;* checksum *&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line">* Stack and entry function to use during CPU initialization</span><br><span class="line">*&#x2F;</span><br><span class="line">.section .bss</span><br><span class="line">.space 4096 &#x2F;* bss 段大小 *&#x2F;</span><br><span class="line">lcpu_bootstack:</span><br><span class="line"></span><br><span class="line">.section .rodata</span><br><span class="line">lcpu_boot_startup_args:</span><br><span class="line">	ur_data quad, multiboot_entry, 8 &#x2F;* multiboot_entry 作为完成 lcpu_start64 后的初始化函数 *&#x2F;</span><br><span class="line">	ur_data quad, lcpu_bootstack, 8</span><br><span class="line"></span><br><span class="line">.code32</span><br><span class="line">.section .text.32.boot</span><br><span class="line">ENTRY(_multiboot_entry)</span><br><span class="line"></span><br><span class="line">	&#x2F;* only multiboot is supported for now *&#x2F;</span><br><span class="line">	cmpl $MULTIBOOT_BOOTLOADER_MAGIC, %eax &#x2F;* 判断是否是 multiboot 启动，不是则直接退出。*&#x2F;</span><br><span class="line">	jne no_multiboot</span><br><span class="line"></span><br><span class="line">	&#x2F;* Hardcoding for now I guess... *&#x2F;</span><br><span class="line">	movl $0x00100000, %edi</span><br><span class="line">	movl $0x00000000, %esi</span><br><span class="line">	movl $0x00100000, %edx</span><br><span class="line">	do_uk_reloc32 0</span><br><span class="line">	</span><br><span class="line">	&#x2F;* startup args for boot CPU *&#x2F;</span><br><span class="line">	ur_mov lcpu_boot_startup_args, %edi, 4, _phys &#x2F;* 为后续完成 lcpu_start64 后跳转做准备 *&#x2F;</span><br><span class="line">	movl %ebx, %esi &#x2F;* multiboot info *&#x2F;</span><br><span class="line">	ur_mov lcpu_start32, %ebx, 4, _phys</span><br><span class="line">	jmp *%ebx &#x2F;* 执行 lcpu_start32 *&#x2F;</span><br><span class="line"></span><br><span class="line">no_multiboot:</span><br><span class="line">	cli</span><br><span class="line">1:</span><br><span class="line">	hlt</span><br><span class="line">	jmp 1b</span><br><span class="line">END(_multiboot_entry)</span><br></pre></td></tr></table></figure>
<p>注意在执行完  _multiboot_entry 之后，esi 里存储的是包含 multiboot 信息的32位物理地址，edi 里存储的是 lcpu_boot_startup_args 的地址，ebx 里存储的是 lcpu_start32 的函数地址。所以函数会跳转到 lcpu_start32。</p>
<h3 id="lcpu-start32"><a href="#lcpu-start32" class="headerlink" title="lcpu_start32"></a>lcpu_start32</h3><p>lcpu_start32 打开 PAE，IA-32e，设置页表，cr0，GDT，将程序跳转到 64 位环境执行。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.code32</span><br><span class="line">.section .text.boot.32</span><br><span class="line">ENTRY(lcpu_start32) &#x2F;* 打开 PAE，IA-32e，设置页表，cr0，GDT *&#x2F;</span><br><span class="line">	&#x2F;* Enable physical address extension (PAE) *&#x2F;</span><br><span class="line">	movl $CR4_BOOT32_SETTINGS, %eax</span><br><span class="line">	movl %eax, %cr4</span><br><span class="line">	</span><br><span class="line">	&#x2F;* Switch to IA-32e mode (long mode) *&#x2F; &#x2F;* IA-32e 是 64 位*&#x2F;</span><br><span class="line">	xorl %edx, %edx</span><br><span class="line">	movl $EFER_BOOT32_SETTINGS, %eax</span><br><span class="line">	movl $X86_MSR_EFER, %ecx</span><br><span class="line">	wrmsr</span><br><span class="line">	&#x2F;* 页表采用的是 4 级分页，需要提前设置 CR0.PG，CR4.PAE，IA32_EFER.LME 为 1，CR4.LA57 为 0.*&#x2F;</span><br><span class="line">	&#x2F;* Set boot page table and enable paging *&#x2F; &#x2F;* x86_bpt_pml4 里面是页表 *&#x2F;</span><br><span class="line">	ur_mov x86_bpt_pml4, %eax, 4, _phys</span><br><span class="line">	movl %eax, %cr3</span><br><span class="line">	</span><br><span class="line">	&#x2F;* Protected mode, Write Protect, Paging *&#x2F;</span><br><span class="line">	movl $CR0_BOOT32_SETTINGS, %eax</span><br><span class="line">	movl %eax, %cr0</span><br><span class="line"></span><br><span class="line">	&#x2F;* Load 64-bit GDT and jump to 64-bit code segment *&#x2F;</span><br><span class="line">	ur_mov gdt64_ptr, %eax, 4</span><br><span class="line">	lgdt (%eax)</span><br><span class="line"></span><br><span class="line">	&#x2F;* Again, we use the same strategy, only this time we generate an actual</span><br><span class="line">	* uk_reloc entry to be automatically resolved by the early relocator,</span><br><span class="line">	* instead of relying on the code that relocates the start16 section</span><br><span class="line">	* before starting the Application Processors, since execution of</span><br><span class="line">	* lcpu_start32 comes before that.</span><br><span class="line">	*&#x2F;</span><br><span class="line">	ur_mov jump_to64, %eax, 4</span><br><span class="line">	movl %eax, -6(%eax)</span><br><span class="line">	ljmp $(gdt64_cs - gdt64), $START32_PLACEHOLDER</span><br><span class="line">.code64</span><br><span class="line">jump_to64:</span><br><span class="line">	&#x2F;* Set up remaining segment registers *&#x2F;</span><br><span class="line">	movl $(gdt64_ds - gdt64), %eax</span><br><span class="line">	movl %eax, %es</span><br><span class="line">	movl %eax, %ss</span><br><span class="line">	movl %eax, %ds</span><br><span class="line">	xorl %eax, %eax</span><br><span class="line">	movl %eax, %fs</span><br><span class="line">	movl %eax, %gs</span><br><span class="line">	leaq lcpu_start64(%rip), %rcx</span><br><span class="line">	jmp *%rcx</span><br><span class="line">END(lcpu_start32)</span><br></pre></td></tr></table></figure>
<p>分析页表 x86_bpt_pml4。<br>首先需要了解 64 位内存分页。该部分采用的是 4 级分页。转换过程参考：<a href="https://zhuanlan.zhihu.com/p/652983618%E3%80%82">https://zhuanlan.zhihu.com/p/652983618。</a></p>
<p>通过阅读 x86_bpt_pml4 源码，可以得到页表的示意图如下图所示。</p>
<img src="/p/8e98bdb9/%E9%A1%B5%E8%A1%A8.jpg" class title="图1 页表">

<h3 id="lcpu-start64"><a href="#lcpu-start64" class="headerlink" title="lcpu_start64"></a>lcpu_start64</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.code64</span><br><span class="line">.section .text.boot.64</span><br><span class="line">ENTRY(lcpu_start64) &#x2F;* 将 lcpu 状态设为 init，设置栈，打开 FPU，SSE，XSAVE，AVX，FS，GS，PKU，跳转到 multiboot_entry *&#x2F;</span><br><span class="line">	&#x2F;* Save the startup args pointer *&#x2F;</span><br><span class="line">	movq	%rdi, %r8	&#x2F;* r8 存储的是 lcpu_boot_startup_args 地址。*&#x2F;</span><br><span class="line"></span><br><span class="line">	&#x2F;* Request basic CPU features and APIC ID</span><br><span class="line">	 * TODO: This APIC ID is limited to 256. Better get from leaf 0x1f</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	movl	$1, %eax</span><br><span class="line">	cpuid</span><br><span class="line">	shrl	$24, %ebx</span><br><span class="line"></span><br><span class="line">	&#x2F;* Use APIC_ID * LCPU_SIZE for indexing the cpu structure *&#x2F;</span><br><span class="line">	movl	$LCPU_SIZE, %eax</span><br><span class="line">	imul	%ebx, %eax</span><br><span class="line"></span><br><span class="line">	&#x2F;* Compute pointer into CPU struct array and store it in RBP</span><br><span class="line">	 * We do not use the frame pointer, yet</span><br><span class="line">	 *&#x2F;&#x2F;* lcpus 为数组，用来存储所有逻辑 cpu 的元数据。*&#x2F;</span><br><span class="line">	leaq	lcpus(%rip), %rbp</span><br><span class="line">	addq	%rax, %rbp</span><br><span class="line"></span><br><span class="line">	&#x2F;* Put CPU into init state *&#x2F; &#x2F;* lcpu 状态设为 init 状态*&#x2F;</span><br><span class="line">	movl	$LCPU_STATE_INIT, LCPU_STATE_OFFSET(%rbp)</span><br><span class="line"></span><br><span class="line">	&#x2F;* Enable FPU, SSE, (XSAVE feature), (AVX), FS and GS base, (memory protection keys (PKU)). Request extended CPU features.()表示需要配置相应启动参数。*&#x2F;</span><br><span class="line">	......</span><br><span class="line"></span><br><span class="line">	&#x2F;* Check if we have startup arguments supplied *&#x2F;</span><br><span class="line">	test	%r8, %r8</span><br><span class="line">	jz	no_args</span><br><span class="line"></span><br><span class="line">	&#x2F;* Initialize the CPU configuration with the supplied startup args *&#x2F;</span><br><span class="line">	movq	LCPU_SARGS_ENTRY_OFFSET(%r8), %rax	&#x2F;* 将函数跳转地址设为 multiboot_entry 函数地址 *&#x2F;</span><br><span class="line">	movq	LCPU_SARGS_STACKP_OFFSET(%r8), %rsp &#x2F;*将栈地址设为 bss 段地址*&#x2F;</span><br><span class="line"></span><br><span class="line">	jmp	jump_to_entry</span><br><span class="line"></span><br><span class="line">no_args:</span><br><span class="line">	&#x2F;* Load the stack pointer and the entry address from the CPU struct *&#x2F;</span><br><span class="line">	movq	LCPU_ENTRY_OFFSET(%rbp), %rax</span><br><span class="line">	movq	LCPU_STACKP_OFFSET(%rbp), %rsp</span><br><span class="line"></span><br><span class="line">jump_to_entry:</span><br><span class="line">	&#x2F;* According to System V AMD64 the stack pointer must be aligned to</span><br><span class="line">	 * 16-bytes. In other words, the value (RSP+8) must be a multiple of</span><br><span class="line">	 * 16 when control is transferred to the function entry point (i.e.,</span><br><span class="line">	 * the compiler expects a misalignment due to the return address having</span><br><span class="line">	 * been pushed onto the stack).</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	andq	$~0xf, %rsp</span><br><span class="line">	subq	$0x8, %rsp</span><br><span class="line"></span><br><span class="line">	movq	%rbp, %rdi	&#x2F;*rdi 为第一个参数，即 rbp，rbp 存储的为该逻辑 cpu 在 lcpus 数组中的地址*&#x2F;</span><br><span class="line">#if !__OMIT_FRAMEPOINTER__</span><br><span class="line">	&#x2F;* Reset frame pointer *&#x2F;</span><br><span class="line">	xorq	%rbp, %rbp</span><br><span class="line">#endif &#x2F;* !__OMIT_FRAMEPOINTER__ *&#x2F;</span><br><span class="line"></span><br><span class="line">	&#x2F;* Arguments for entry function</span><br><span class="line">	 * arg0 @ RDI &#x3D; this CPU, arg1 @ RSI &#x3D; boot parameters (if available)</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	jmp	*%rax	&#x2F;* 转移到 multiboot_entry*&#x2F;</span><br><span class="line">	&#x2F;* rsi 在 multiboot.S 中赋值*&#x2F;</span><br><span class="line">fail:</span><br><span class="line">	movl	$LCPU_STATE_HALTED, LCPU_STATE_OFFSET(%rbp)</span><br><span class="line"></span><br><span class="line">fail_loop:</span><br><span class="line">	cli</span><br><span class="line">1:</span><br><span class="line">	hlt</span><br><span class="line">	jmp	1b</span><br><span class="line">END(lcpu_start64)</span><br></pre></td></tr></table></figure>

<p>执行完 lcpu_start64，转向 multiboot_entry 执行。</p>
<h3 id="multiboot-entry-1"><a href="#multiboot-entry-1" class="headerlink" title="multiboot_entry"></a>multiboot_entry</h3><p>当执行 hello-world 程序时，参数 mi 的值如下所示。mi 各个参数的含义与 multiboot 协议有关，注意在 _multiboot_entry 定义的 MULTIBOOT_FLAGS 值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) p&#x2F;x *mi</span><br><span class="line">$1 &#x3D; &#123;flags &#x3D; 0x24f, mem_lower &#x3D; 0x27f, mem_upper &#x3D; 0x1fb80, boot_device &#x3D; 0x8000ffff, cmdline &#x3D; 0x185000, mods_count &#x3D; 0x0, mods_addr &#x3D; 0x185000,</span><br><span class="line">  u &#x3D; &#123;aout_sym &#x3D; &#123;tabsize &#x3D; 0x0, strsize &#x3D; 0x0, addr &#x3D; 0x0, reserved &#x3D; 0x0&#125;, elf_sec &#x3D; &#123;num &#x3D; 0x0, size &#x3D; 0x0, addr &#x3D; 0x0, shndx &#x3D; 0x0&#125;&#125;,</span><br><span class="line">  mmap_length &#x3D; 0x90, mmap_addr &#x3D; 0x9000, drives_length &#x3D; 0x0, drives_addr &#x3D; 0x0, config_table &#x3D; 0x0, boot_loader_name &#x3D; 0x18501e, apm_table &#x3D; 0x0,</span><br><span class="line">  vbe_control_info &#x3D; 0x0, vbe_mode_info &#x3D; 0x0, vbe_mode &#x3D; 0x0, vbe_interface_seg &#x3D; 0x0, vbe_interface_off &#x3D; 0x0, vbe_interface_len &#x3D; 0x0,</span><br><span class="line">  framebuffer_addr &#x3D; 0x0, framebuffer_pitch &#x3D; 0x0, framebuffer_width &#x3D; 0x0, framebuffer_height &#x3D; 0x0, framebuffer_bpp &#x3D; 0x0, framebuffer_type &#x3D; 0x0, &#123;&#123;</span><br><span class="line">      framebuffer_palette_addr &#x3D; 0x0, framebuffer_palette_num_colors &#x3D; 0x0&#125;, &#123;framebuffer_red_field_position &#x3D; 0x0, framebuffer_red_mask_size &#x3D; 0x0,</span><br><span class="line">      framebuffer_green_field_position &#x3D; 0x0, framebuffer_green_mask_size &#x3D; 0x0, framebuffer_blue_field_position &#x3D; 0x0,</span><br><span class="line">      framebuffer_blue_mask_size &#x3D; 0x0&#125;&#125;&#125;</span><br><span class="line"></span><br><span class="line">(gdb) p (char*)mi-&gt;cmdline</span><br><span class="line">$2 &#x3D; 0x185000 &quot;build&#x2F;helloworld_qemu-x86_64 &quot;</span><br><span class="line"></span><br><span class="line">(gdb) p (char*)mi-&gt;boot_loader_name</span><br><span class="line">$3 &#x3D; 0x18501e &quot;qemu&quot;</span><br></pre></td></tr></table></figure>
<p>参数 lcpu 值如下所示。其中，idx 表示逻辑 cpu 的顺序索引，id 表示逻辑 cpu 的物理 id。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) p&#x2F;x *lcpu</span><br><span class="line">$4 &#x3D; &#123;state &#x3D; 0x1, idx &#x3D; 0x0, id &#x3D; 0x0, &#123;s_args &#x3D; &#123;entry &#x3D; 0x0, stackp &#x3D; 0x0&#125;, error_code &#x3D; 0x0&#125;, arch &#x3D; &#123;&lt;No data fields&gt;&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>lcpu 的状态变化如下图所示。</p>
<img src="/p/8e98bdb9/lcpu.png" class title="图2 lcpu">

<p>下面阅读 multiboot_entry 函数，调试信息为执行 hello-world 程序的信息。<br>bi-&gt;mrds.mrds 的 type 和 flags 取值如下所示。另外，bi-&gt;mrds.mrds 按照 pbase 大小有序排列。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;* Memory region types *&#x2F;</span><br><span class="line">#define UKPLAT_MEMRT_ANY		0xffff</span><br><span class="line"></span><br><span class="line">#define UKPLAT_MEMRT_FREE		0x0001	&#x2F;* Uninitialized memory *&#x2F;</span><br><span class="line">#define UKPLAT_MEMRT_RESERVED		0x0002	&#x2F;* In use by platform *&#x2F;</span><br><span class="line">#define UKPLAT_MEMRT_KERNEL		0x0004	&#x2F;* Kernel binary segment *&#x2F;</span><br><span class="line">#define UKPLAT_MEMRT_INITRD		0x0008	&#x2F;* Initramdisk *&#x2F;</span><br><span class="line">#define UKPLAT_MEMRT_CMDLINE		0x0010	&#x2F;* Command line *&#x2F;</span><br><span class="line">#define UKPLAT_MEMRT_DEVICETREE		0x0020	&#x2F;* Device tree *&#x2F;</span><br><span class="line">#define UKPLAT_MEMRT_STACK		0x0040	&#x2F;* Thread stack *&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;* Memory region flags *&#x2F;</span><br><span class="line">#define UKPLAT_MEMRF_ALL		0xffff</span><br><span class="line"></span><br><span class="line">#define UKPLAT_MEMRF_PERMS		0x0007</span><br><span class="line">#define UKPLAT_MEMRF_READ		0x0001	&#x2F;* Region is readable *&#x2F;</span><br><span class="line">#define UKPLAT_MEMRF_WRITE		0x0002	&#x2F;* Region is writable *&#x2F;</span><br><span class="line">#define UKPLAT_MEMRF_EXECUTE		0x0004	&#x2F;* Region is executable *&#x2F;</span><br><span class="line"></span><br><span class="line">#define UKPLAT_MEMRF_UNMAP		0x0010	&#x2F;* Must be unmapped at boot *&#x2F;</span><br><span class="line">#define UKPLAT_MEMRF_MAP		0x0020	&#x2F;* Must be mapped at boot *&#x2F;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void multiboot_entry(struct lcpu *lcpu, struct multiboot_info *mi)</span><br><span class="line">&#123;</span><br><span class="line">	struct ukplat_bootinfo *bi;</span><br><span class="line">	struct ukplat_memregion_desc mrd &#x3D; &#123;0&#125;;</span><br><span class="line">	multiboot_memory_map_t *m;</span><br><span class="line">	multiboot_module_t *mods;</span><br><span class="line">	__sz offset, cmdline_len;</span><br><span class="line">	__paddr_t start, end;</span><br><span class="line">	__u32 i;</span><br><span class="line">	int rc;</span><br><span class="line">	&#x2F;* uk_boootinfo 节内容通过 support&#x2F;scripts&#x2F;mkbootinfo.py（91-101行）完成初始化。*&#x2F;</span><br><span class="line">	bi &#x3D; ukplat_bootinfo_get();</span><br><span class="line">	&#x2F;**</span><br><span class="line">	(gdb) p&#x2F;x *bi</span><br><span class="line">	$1 &#x3D; &#123;magic &#x3D; 0xb007b0b0, version &#x3D; 0x1, _pad0 &#x3D; &#123;0x0, 0x0, 0x0&#125;, bootloader &#x3D; &#123;0x0 &lt;repeats 16 times&gt;&#125;, bootprotocol &#x3D; &#123;</span><br><span class="line">    0x0 &lt;repeats 16 times&gt;&#125;, cmdline &#x3D; 0x0, cmdline_len &#x3D; 0x0, dtb &#x3D; 0x0, efi_st &#x3D; 0x0, mrds &#x3D; &#123;capacity &#x3D; 0x80, count &#x3D; 0x4,</span><br><span class="line">    mrds &#x3D; 0x12f2e8 &lt;bi_bootinfo_sec+80&gt;&#125;&#125;</span><br><span class="line">	(gdb) p&#x2F;x *(bi-&gt;mrds.mrds)@4</span><br><span class="line">	$2 &#x3D; &#123;&#123;pbase &#x3D; 0x100000, vbase &#x3D; 0x100000, len &#x3D; 0x27000, type &#x3D; 0x4, flags &#x3D; 0x5&#125;, &#123;pbase &#x3D; 0x127000, vbase &#x3D; 0x127000,</span><br><span class="line">    len &#x3D; 0x8000, type &#x3D; 0x4, flags &#x3D; 0x1&#125;, &#123;pbase &#x3D; 0x12f000, vbase &#x3D; 0x12f000, len &#x3D; 0x56000, type &#x3D; 0x4, flags &#x3D; 0x3&#125;, &#123;</span><br><span class="line">    pbase &#x3D; 0x12f000, vbase &#x3D; 0x12f000, len &#x3D; 0x0, type &#x3D; 0x4, flags &#x3D; 0x3&#125;&#125;</span><br><span class="line">	*&#x2F;</span><br><span class="line">	if (unlikely(!bi))</span><br><span class="line">		multiboot_crash(&quot;Incompatible or corrupted bootinfo&quot;, -EINVAL);</span><br><span class="line"></span><br><span class="line">	&#x2F;* We have to call this here as the very early do_uk_reloc32 relocator</span><br><span class="line">	 * does not also relocate the UKPLAT_MEMRT_KERNEL mrd&#39;s like its C</span><br><span class="line">	 * equivalent, do_uk_reloc, does.</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	do_uk_reloc_kmrds(0, 0);</span><br><span class="line"></span><br><span class="line">	&#x2F;* Ensure that the memory map contains the legacy high mem area *&#x2F;&#x2F;* bi-&gt;mrds 中插入 HI_MEM 和 BIOS_ROM。*&#x2F;</span><br><span class="line">	rc &#x3D; ukplat_memregion_list_insert_legacy_hi_mem(&amp;bi-&gt;mrds);</span><br><span class="line">	&#x2F;*</span><br><span class="line">  	(gdb) p&#x2F;x bi-&gt;mrds</span><br><span class="line">	$3 &#x3D; &#123;capacity &#x3D; 0x80, count &#x3D; 0x6, mrds &#x3D; 0x12f2e8 &lt;bi_bootinfo_sec+80&gt;&#125;</span><br><span class="line">	(gdb) p&#x2F;x *(bi-&gt;mrds.mrds)@6</span><br><span class="line">	$4 &#x3D; &#123;&#123;pbase &#x3D; 0xa0000, vbase &#x3D; 0xa0000, len &#x3D; 0x40000, type &#x3D; 0x2, flags &#x3D; 0x23&#125;, &#123;pbase &#x3D; 0xe0000, vbase &#x3D; 0xe0000,</span><br><span class="line">      len &#x3D; 0x20000, type &#x3D; 0x2, flags &#x3D; 0x21&#125;, &#123;pbase &#x3D; 0x100000, vbase &#x3D; 0x100000, len &#x3D; 0x27000, type &#x3D; 0x4, flags &#x3D; 0x5&#125;, &#123;</span><br><span class="line">      pbase &#x3D; 0x127000, vbase &#x3D; 0x127000, len &#x3D; 0x8000, type &#x3D; 0x4, flags &#x3D; 0x1&#125;, &#123;pbase &#x3D; 0x12f000, vbase &#x3D; 0x12f000, len &#x3D; 0x56000,</span><br><span class="line">      type &#x3D; 0x4, flags &#x3D; 0x3&#125;, &#123;pbase &#x3D; 0x12f000, vbase &#x3D; 0x12f000, len &#x3D; 0x0, type &#x3D; 0x4, flags &#x3D; 0x3&#125;&#125;</span><br><span class="line">	*&#x2F;</span><br><span class="line">	if (unlikely(rc))</span><br><span class="line">		multiboot_crash(&quot;Could not insert legacy memory region&quot;, rc);</span><br><span class="line"></span><br><span class="line">	&#x2F;* Add the cmdline *&#x2F; &#x2F;* 将 mi-&gt;cmdline 相关信息存到 bi-&gt;mrds，bi-&gt;cmdline 和 bi-&gt;cmdline_len。*&#x2F;</span><br><span class="line">	if (mi-&gt;flags &amp; MULTIBOOT_INFO_CMDLINE) &#123;</span><br><span class="line">		if (mi-&gt;cmdline) &#123; &#x2F;* 当使用 hellowaorld 时，mi-&gt;cmdline 为 build&#x2F;helloworld_qemu-x86_64 *&#x2F;</span><br><span class="line">			cmdline_len &#x3D; strlen((const char *)(__uptr)mi-&gt;cmdline);</span><br><span class="line">			mrd.pbase &#x3D; mi-&gt;cmdline;</span><br><span class="line">			mrd.vbase &#x3D; mi-&gt;cmdline; &#x2F;* 1:1 mapping *&#x2F;</span><br><span class="line">			mrd.len   &#x3D; cmdline_len;</span><br><span class="line">			mrd.type  &#x3D; UKPLAT_MEMRT_CMDLINE;</span><br><span class="line">			mrd.flags &#x3D; UKPLAT_MEMRF_READ | UKPLAT_MEMRF_MAP;</span><br><span class="line"></span><br><span class="line">			mrd_insert(bi, &amp;mrd);</span><br><span class="line"></span><br><span class="line">			bi-&gt;cmdline &#x3D; mi-&gt;cmdline;</span><br><span class="line">			bi-&gt;cmdline_len &#x3D; cmdline_len;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;*</span><br><span class="line">	(gdb) p (char *)(bi-&gt;cmdline)</span><br><span class="line">	$8 &#x3D; 0x185000 &quot;build&#x2F;helloworld_qemu-x86_64 &quot;</span><br><span class="line">	(gdb) p&#x2F;x (bi-&gt;cmdline_len)</span><br><span class="line">	$9 &#x3D; 0x1d</span><br><span class="line">	(gdb) p&#x2F;x bi-&gt;mrds</span><br><span class="line">	$10 &#x3D; &#123;capacity &#x3D; 0x80, count &#x3D; 0x7, mrds &#x3D; 0x12f2e8 &lt;bi_bootinfo_sec+80&gt;&#125;</span><br><span class="line">	(gdb) p&#x2F;x *(bi-&gt;mrds.mrds)@7</span><br><span class="line">	$11 &#x3D; &#123;&#123;pbase &#x3D; 0xa0000, vbase &#x3D; 0xa0000, len &#x3D; 0x40000, type &#x3D; 0x2, flags &#x3D; 0x23&#125;, &#123;pbase &#x3D; 0xe0000, vbase &#x3D; 0xe0000,</span><br><span class="line">    	len &#x3D; 0x20000, type &#x3D; 0x2, flags &#x3D; 0x21&#125;, &#123;pbase &#x3D; 0x100000, vbase &#x3D; 0x100000, len &#x3D; 0x27000, type &#x3D; 0x4, flags &#x3D; 0x5&#125;, &#123;</span><br><span class="line">    	pbase &#x3D; 0x127000, vbase &#x3D; 0x127000, len &#x3D; 0x8000, type &#x3D; 0x4, flags &#x3D; 0x1&#125;, &#123;pbase &#x3D; 0x12f000, vbase &#x3D; 0x12f000, len &#x3D; 0x56000,</span><br><span class="line">    	type &#x3D; 0x4, flags &#x3D; 0x3&#125;, &#123;pbase &#x3D; 0x12f000, vbase &#x3D; 0x12f000, len &#x3D; 0x0, type &#x3D; 0x4, flags &#x3D; 0x3&#125;, &#123;pbase &#x3D; 0x185000,</span><br><span class="line">    	vbase &#x3D; 0x185000, len &#x3D; 0x1d, type &#x3D; 0x10, flags &#x3D; 0x21&#125;&#125;</span><br><span class="line">	*&#x2F;</span><br><span class="line"></span><br><span class="line">	&#x2F;* Copy boot loader *&#x2F; &#x2F;*更新 bi-&gt;bootloader，bi-&gt;bootprotocol。*&#x2F;</span><br><span class="line">	if (mi-&gt;flags &amp; MULTIBOOT_INFO_BOOT_LOADER_NAME) &#123;</span><br><span class="line">		if (mi-&gt;boot_loader_name) &#123; &#x2F;* 当使用 build&#x2F;helloworld_qemu-x86_64 时，mi-&gt;boot_loader_name 为 qemu。*&#x2F;</span><br><span class="line">			strncpy(bi-&gt;bootloader,</span><br><span class="line">				(const char *)(__uptr)mi-&gt;boot_loader_name,</span><br><span class="line">				sizeof(bi-&gt;bootloader) - 1);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;*</span><br><span class="line">	(gdb) p (char*)(bi-&gt;bootloader)</span><br><span class="line">	$12 &#x3D; 0x12f2a0 &lt;bi_bootinfo_sec+8&gt; &quot;qemu&quot;</span><br><span class="line">	*&#x2F;</span><br><span class="line">	memcpy(bi-&gt;bootprotocol, &quot;multiboot&quot;, sizeof(&quot;multiboot&quot;));</span><br><span class="line">	&#x2F;*</span><br><span class="line">	(gdb) p (char*)(bi-&gt;bootprotocol)</span><br><span class="line">	$14 &#x3D; 0x12f2b0 &lt;bi_bootinfo_sec+24&gt; &quot;multiboot&quot;</span><br><span class="line">	*&#x2F;</span><br><span class="line"></span><br><span class="line">	&#x2F;* Add modules from the multiboot info to the memory region list *&#x2F; &#x2F;* 将 mod 相关信息加载到 bi-&gt;mrds。*&#x2F;</span><br><span class="line">	if (mi-&gt;flags &amp; MULTIBOOT_INFO_MODS) &#123;</span><br><span class="line">		mods &#x3D; (multiboot_module_t *)(__uptr)mi-&gt;mods_addr;</span><br><span class="line">		for (i &#x3D; 0; i &lt; mi-&gt;mods_count; i++) &#123;</span><br><span class="line">			mrd.pbase &#x3D; mods[i].mod_start;</span><br><span class="line">			mrd.vbase &#x3D; mods[i].mod_start; &#x2F;* 1:1 mapping *&#x2F;</span><br><span class="line">			mrd.len   &#x3D; mods[i].mod_end - mods[i].mod_start;</span><br><span class="line">			mrd.type  &#x3D; UKPLAT_MEMRT_INITRD;</span><br><span class="line">			mrd.flags &#x3D; UKPLAT_MEMRF_READ | UKPLAT_MEMRF_MAP;</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_UKPLAT_MEMRNAME</span><br><span class="line">			strncpy(mrd.name, (char *)(__uptr)mods[i].cmdline,</span><br><span class="line">				sizeof(mrd.name) - 1);</span><br><span class="line">#endif &#x2F;* CONFIG_UKPLAT_MEMRNAME *&#x2F;</span><br><span class="line"></span><br><span class="line">			mrd_insert(bi, &amp;mrd);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_UKPLAT_MEMRNAME</span><br><span class="line">	memset(mrd.name, 0, sizeof(mrd.name));</span><br><span class="line">#endif &#x2F;* CONFIG_UKPLAT_MEMRNAME *&#x2F;</span><br><span class="line"></span><br><span class="line">	&#x2F;* Add map ranges from the multiboot info to the memory region list</span><br><span class="line">	 * CAUTION: These could generally overlap with regions already in the</span><br><span class="line">	 * list. We thus split new free regions accordingly to remove allocated</span><br><span class="line">	 * ranges. For all other ranges, we assume RESERVED type and that they</span><br><span class="line">	 * do NOT overlap with other allocated ranges (e.g., modules).</span><br><span class="line">	 *&#x2F; &#x2F;*将 multiboot info 映射加入到 bi-&gt;mrds。multiboot info 信息从第二页开始。*&#x2F;</span><br><span class="line">	&#x2F;*</span><br><span class="line">	(gdb) p&#x2F;x *(multiboot_memory_map_t*)(mi-&gt;mmap_addr)@6</span><br><span class="line">	$20 &#x3D; &#123;&#123;size &#x3D; 0x14, addr &#x3D; 0x0, len &#x3D; 0x9fc00, type &#x3D; 0x1&#125;, &#123;size &#x3D; 0x14, addr &#x3D; 0x9fc00, len &#x3D; 0x400, type &#x3D; 0x2&#125;, &#123;size &#x3D; 0x14,</span><br><span class="line">    addr &#x3D; 0xf0000, len &#x3D; 0x10000, type &#x3D; 0x2&#125;, &#123;size &#x3D; 0x14, addr &#x3D; 0x100000, len &#x3D; 0x7ee0000, type &#x3D; 0x1&#125;, &#123;size &#x3D; 0x14,</span><br><span class="line">    addr &#x3D; 0x7fe0000, len &#x3D; 0x20000, type &#x3D; 0x2&#125;, &#123;size &#x3D; 0x14, addr &#x3D; 0xfffc0000, len &#x3D; 0x40000, type &#x3D; 0x2&#125;&#125;</span><br><span class="line">	*&#x2F;</span><br><span class="line">	if (mi-&gt;flags &amp; MULTIBOOT_INFO_MEM_MAP) &#123;</span><br><span class="line">		for (offset &#x3D; 0; offset &lt; mi-&gt;mmap_length;</span><br><span class="line">		     offset +&#x3D; m-&gt;size + sizeof(m-&gt;size)) &#123;</span><br><span class="line">			m &#x3D; (void *)(__uptr)(mi-&gt;mmap_addr + offset);</span><br><span class="line"></span><br><span class="line">			start &#x3D; MAX(m-&gt;addr, __PAGE_SIZE);</span><br><span class="line">			end   &#x3D; m-&gt;addr + m-&gt;len;</span><br><span class="line">			if (unlikely(end &lt;&#x3D; start || end - start &lt; PAGE_SIZE))</span><br><span class="line">				continue;</span><br><span class="line"></span><br><span class="line">			mrd.pbase &#x3D; start;</span><br><span class="line">			mrd.vbase &#x3D; start; &#x2F;* 1:1 mapping *&#x2F;</span><br><span class="line">			mrd.len   &#x3D; end - start;</span><br><span class="line"></span><br><span class="line">			if (m-&gt;type &#x3D;&#x3D; MULTIBOOT_MEMORY_AVAILABLE) &#123;</span><br><span class="line">				mrd.type  &#x3D; UKPLAT_MEMRT_FREE;</span><br><span class="line">				mrd.flags &#x3D; UKPLAT_MEMRF_READ |</span><br><span class="line">					    UKPLAT_MEMRF_WRITE;</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				mrd.type  &#x3D; UKPLAT_MEMRT_RESERVED;</span><br><span class="line">				mrd.flags &#x3D; UKPLAT_MEMRF_READ |</span><br><span class="line">					    UKPLAT_MEMRF_MAP;</span><br><span class="line"></span><br><span class="line">				&#x2F;* We assume that reserved regions cannot</span><br><span class="line">				 * overlap with loaded modules.</span><br><span class="line">				 *&#x2F;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			mrd_insert(bi, &amp;mrd);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;*</span><br><span class="line">	(gdb) p&#x2F;x bi-&gt;mrds</span><br><span class="line">	$22 &#x3D; &#123;capacity &#x3D; 0x80, count &#x3D; 0xc, mrds &#x3D; 0x12f2e8 &lt;bi_bootinfo_sec+80&gt;&#125;</span><br><span class="line">	(gdb) p&#x2F;x *(bi-&gt;mrds.mrds)@12</span><br><span class="line">	$24 &#x3D; &#123;&#123;pbase &#x3D; 0x1000, vbase &#x3D; 0x1000, len &#x3D; 0x9ec00, type &#x3D; 0x1, flags &#x3D; 0x3&#125;, &#123;pbase &#x3D; 0xa0000, vbase &#x3D; 0xa0000, len &#x3D; 0x40000,</span><br><span class="line">    type &#x3D; 0x2, flags &#x3D; 0x23&#125;, &#123;pbase &#x3D; 0xf0000, vbase &#x3D; 0xf0000, len &#x3D; 0x10000, type &#x3D; 0x2, flags &#x3D; 0x21&#125;, &#123;pbase &#x3D; 0xe0000,</span><br><span class="line">    vbase &#x3D; 0xe0000, len &#x3D; 0x20000, type &#x3D; 0x2, flags &#x3D; 0x21&#125;, &#123;pbase &#x3D; 0x100000, vbase &#x3D; 0x100000, len &#x3D; 0x7ee0000, type &#x3D; 0x1,</span><br><span class="line">    flags &#x3D; 0x3&#125;, &#123;pbase &#x3D; 0x100000, vbase &#x3D; 0x100000, len &#x3D; 0x27000, type &#x3D; 0x4, flags &#x3D; 0x5&#125;, &#123;pbase &#x3D; 0x127000,</span><br><span class="line">    vbase &#x3D; 0x127000, len &#x3D; 0x8000, type &#x3D; 0x4, flags &#x3D; 0x1&#125;, &#123;pbase &#x3D; 0x12f000, vbase &#x3D; 0x12f000, len &#x3D; 0x56000, type &#x3D; 0x4,</span><br><span class="line">    flags &#x3D; 0x3&#125;, &#123;pbase &#x3D; 0x12f000, vbase &#x3D; 0x12f000, len &#x3D; 0x0, type &#x3D; 0x4, flags &#x3D; 0x3&#125;, &#123;pbase &#x3D; 0x185000, vbase &#x3D; 0x185000,</span><br><span class="line">    len &#x3D; 0x1d, type &#x3D; 0x10, flags &#x3D; 0x21&#125;, &#123;pbase &#x3D; 0x7fe0000, vbase &#x3D; 0x7fe0000, len &#x3D; 0x20000, type &#x3D; 0x2, flags &#x3D; 0x21&#125;, &#123;</span><br><span class="line">    pbase &#x3D; 0xfffc0000, vbase &#x3D; 0xfffc0000, len &#x3D; 0x40000, type &#x3D; 0x2, flags &#x3D; 0x21&#125;&#125;</span><br><span class="line">	*&#x2F;</span><br><span class="line">	&#x2F;* 对 bi-&gt;mrds 进行整理，合并*&#x2F;</span><br><span class="line">	rc &#x3D; ukplat_memregion_list_coalesce(&amp;bi-&gt;mrds);</span><br><span class="line">	&#x2F;*</span><br><span class="line">	(gdb) p&#x2F;x bi-&gt;mrds</span><br><span class="line">	$25 &#x3D; &#123;capacity &#x3D; 0x80, count &#x3D; 0xb, mrds &#x3D; 0x12f2e8 &lt;bi_bootinfo_sec+80&gt;&#125;</span><br><span class="line">	(gdb) p&#x2F;x *(bi-&gt;mrds.mrds)@11</span><br><span class="line">	$26 &#x3D; &#123;&#123;pbase &#x3D; 0x1000, vbase &#x3D; 0x1000, len &#x3D; 0x9ec00, type &#x3D; 0x1, flags &#x3D; 0x3&#125;, &#123;pbase &#x3D; 0xa0000, vbase &#x3D; 0xa0000, len &#x3D; 0x40000,</span><br><span class="line">    type &#x3D; 0x2, flags &#x3D; 0x23&#125;, &#123;pbase &#x3D; 0xe0000, vbase &#x3D; 0xe0000, len &#x3D; 0x20000, type &#x3D; 0x2, flags &#x3D; 0x21&#125;, &#123;pbase &#x3D; 0x100000,</span><br><span class="line">    vbase &#x3D; 0x100000, len &#x3D; 0x27000, type &#x3D; 0x4, flags &#x3D; 0x5&#125;, &#123;pbase &#x3D; 0x127000, vbase &#x3D; 0x127000, len &#x3D; 0x8000, type &#x3D; 0x4,</span><br><span class="line">    flags &#x3D; 0x1&#125;, &#123;pbase &#x3D; 0x12f000, vbase &#x3D; 0x12f000, len &#x3D; 0x56000, type &#x3D; 0x4, flags &#x3D; 0x3&#125;, &#123;pbase &#x3D; 0x12f000,</span><br><span class="line">    vbase &#x3D; 0x12f000, len &#x3D; 0x0, type &#x3D; 0x4, flags &#x3D; 0x3&#125;, &#123;pbase &#x3D; 0x185000, vbase &#x3D; 0x185000, len &#x3D; 0x1d, type &#x3D; 0x10,</span><br><span class="line">    flags &#x3D; 0x21&#125;, &#123;pbase &#x3D; 0x18501d, vbase &#x3D; 0x18501d, len &#x3D; 0x7e5afe3, type &#x3D; 0x1, flags &#x3D; 0x3&#125;, &#123;pbase &#x3D; 0x7fe0000,</span><br><span class="line">    vbase &#x3D; 0x7fe0000, len &#x3D; 0x20000, type &#x3D; 0x2, flags &#x3D; 0x21&#125;, &#123;pbase &#x3D; 0xfffc0000, vbase &#x3D; 0xfffc0000, len &#x3D; 0x40000,</span><br><span class="line">    type &#x3D; 0x2, flags &#x3D; 0x21&#125;&#125;</span><br><span class="line">	*&#x2F;</span><br><span class="line">	if (unlikely(rc))</span><br><span class="line">		multiboot_crash(&quot;Could not coalesce memory regions&quot;, rc);</span><br><span class="line"></span><br><span class="line">	rc &#x3D; ukplat_memregion_alloc_sipi_vect();</span><br><span class="line">	if (unlikely(rc))</span><br><span class="line">		multiboot_crash(&quot;Could not insert SIPI vector region&quot;, rc);</span><br><span class="line"></span><br><span class="line">	_ukplat_entry(lcpu, bi);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>综上所述，multiboot_entry 完成了 bi 初始化，并转到 _ukplat_entry 执行。</p>
<h3 id="ukplat-entry"><a href="#ukplat-entry" class="headerlink" title="_ukplat_entry"></a>_ukplat_entry</h3><p>下面阅读 _ukplat_entry 函数，调试信息为执行 hello-world 程序的信息。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void _ukplat_entry(struct lcpu *lcpu, struct ukplat_bootinfo *bi)</span><br><span class="line">&#123;</span><br><span class="line">	int rc;</span><br><span class="line">	void *bstack;</span><br><span class="line"></span><br><span class="line">	_libkvmplat_init_console();</span><br><span class="line"></span><br><span class="line">	&#x2F;* Initialize trap vector table *&#x2F;</span><br><span class="line">	traps_table_init();</span><br><span class="line"></span><br><span class="line">	&#x2F;* Initialize LCPU of bootstrap processor *&#x2F;</span><br><span class="line">	rc &#x3D; lcpu_init(lcpu);</span><br><span class="line">	&#x2F;*</span><br><span class="line">	(gdb) p&#x2F;x *lcpu</span><br><span class="line">	$1 &#x3D; &#123;state &#x3D; 0x3, idx &#x3D; 0x0, id &#x3D; 0x0, &#123;s_args &#x3D; &#123;entry &#x3D; 0x0, stackp &#x3D; 0x0&#125;, error_code &#x3D; 0x0&#125;, arch &#x3D; &#123;&lt;No data fields&gt;&#125;&#125;</span><br><span class="line">	*&#x2F;</span><br><span class="line">	if (unlikely(rc))</span><br><span class="line">		UK_CRASH(&quot;Bootstrap processor init failed: %d\n&quot;, rc);</span><br><span class="line"></span><br><span class="line">	&#x2F;* Initialize IRQ controller *&#x2F;</span><br><span class="line">	intctrl_init();</span><br><span class="line"></span><br><span class="line">	&#x2F;* Initialize command line *&#x2F;&#x2F;* 将 bi-&gt;cmdline 加入到 bi-&gt;mrds*&#x2F;</span><br><span class="line">	rc &#x3D; cmdline_init(bi);</span><br><span class="line">	&#x2F;*</span><br><span class="line">	(gdb) p&#x2F;x bi-&gt;mrds</span><br><span class="line">	$2 &#x3D; &#123;capacity &#x3D; 0x80, count &#x3D; 0xc, mrds &#x3D; 0x12f2e8 &lt;bi_bootinfo_sec+80&gt;&#125;</span><br><span class="line">	(gdb) p&#x2F;x *(bi-&gt;mrds.mrds)@12</span><br><span class="line">	$3 &#x3D; &#123;&#123;pbase &#x3D; 0x1000, vbase &#x3D; 0x1000, len &#x3D; 0x1000, type &#x3D; 0x4, flags &#x3D; 0x23&#125;, &#123;pbase &#x3D; 0x2000, vbase &#x3D; 0x2000, len &#x3D; 0x9dc00,</span><br><span class="line">    type &#x3D; 0x1, flags &#x3D; 0x3&#125;, &#123;pbase &#x3D; 0xa0000, vbase &#x3D; 0xa0000, len &#x3D; 0x40000, type &#x3D; 0x2, flags &#x3D; 0x23&#125;, &#123;pbase &#x3D; 0xe0000,</span><br><span class="line">    vbase &#x3D; 0xe0000, len &#x3D; 0x20000, type &#x3D; 0x2, flags &#x3D; 0x21&#125;, &#123;pbase &#x3D; 0x100000, vbase &#x3D; 0x100000, len &#x3D; 0x27000, type &#x3D; 0x4,</span><br><span class="line">    flags &#x3D; 0x5&#125;, &#123;pbase &#x3D; 0x127000, vbase &#x3D; 0x127000, len &#x3D; 0x8000, type &#x3D; 0x4, flags &#x3D; 0x1&#125;, &#123;pbase &#x3D; 0x12f000, vbase &#x3D; 0x12f000,</span><br><span class="line">    len &#x3D; 0x56000, type &#x3D; 0x4, flags &#x3D; 0x3&#125;, &#123;pbase &#x3D; 0x12f000, vbase &#x3D; 0x12f000, len &#x3D; 0x0, type &#x3D; 0x4, flags &#x3D; 0x3&#125;, &#123;</span><br><span class="line">    pbase &#x3D; 0x185000, vbase &#x3D; 0x185000, len &#x3D; 0x1d, type &#x3D; 0x10, flags &#x3D; 0x21&#125;, &#123;pbase &#x3D; 0x18501d, vbase &#x3D; 0x18501d,</span><br><span class="line">    len &#x3D; 0x7e5afe3, type &#x3D; 0x1, flags &#x3D; 0x3&#125;, &#123;pbase &#x3D; 0x7fe0000, vbase &#x3D; 0x7fe0000, len &#x3D; 0x20000, type &#x3D; 0x2, flags &#x3D; 0x21&#125;, &#123;</span><br><span class="line">    pbase &#x3D; 0xfffc0000, vbase &#x3D; 0xfffc0000, len &#x3D; 0x40000, type &#x3D; 0x2, flags &#x3D; 0x21&#125;&#125;</span><br><span class="line">	*&#x2F;</span><br><span class="line">	if (unlikely(rc))</span><br><span class="line">		UK_CRASH(&quot;Cmdline init failed: %d\n&quot;, rc);</span><br><span class="line"></span><br><span class="line">	&#x2F;* Allocate boot stack *&#x2F;</span><br><span class="line">	bstack &#x3D; ukplat_memregion_alloc(__STACK_SIZE, UKPLAT_MEMRT_STACK,</span><br><span class="line">					UKPLAT_MEMRF_READ |</span><br><span class="line">					UKPLAT_MEMRF_WRITE |</span><br><span class="line">					UKPLAT_MEMRF_MAP);</span><br><span class="line">	&#x2F;*</span><br><span class="line">	(gdb) p&#x2F;x bi-&gt;mrds</span><br><span class="line">	$4 &#x3D; &#123;capacity &#x3D; 0x80, count &#x3D; 0xd, mrds &#x3D; 0x12f2e8 &lt;bi_bootinfo_sec+80&gt;&#125;</span><br><span class="line">	(gdb) p&#x2F;x *(bi-&gt;mrds.mrds)@13</span><br><span class="line">	$5 &#x3D; &#123;&#123;pbase &#x3D; 0x1000, vbase &#x3D; 0x1000, len &#x3D; 0x1000, type &#x3D; 0x4, flags &#x3D; 0x23&#125;, &#123;pbase &#x3D; 0x2000, vbase &#x3D; 0x2000, len &#x3D; 0x10000,</span><br><span class="line">    type &#x3D; 0x40, flags &#x3D; 0x23&#125;, &#123;pbase &#x3D; 0x12000, vbase &#x3D; 0x12000, len &#x3D; 0x8dc00, type &#x3D; 0x1, flags &#x3D; 0x3&#125;, &#123;pbase &#x3D; 0xa0000,</span><br><span class="line">    vbase &#x3D; 0xa0000, len &#x3D; 0x40000, type &#x3D; 0x2, flags &#x3D; 0x23&#125;, &#123;pbase &#x3D; 0xe0000, vbase &#x3D; 0xe0000, len &#x3D; 0x20000, type &#x3D; 0x2,</span><br><span class="line">    flags &#x3D; 0x21&#125;, &#123;pbase &#x3D; 0x100000, vbase &#x3D; 0x100000, len &#x3D; 0x27000, type &#x3D; 0x4, flags &#x3D; 0x5&#125;, &#123;pbase &#x3D; 0x127000,</span><br><span class="line">    vbase &#x3D; 0x127000, len &#x3D; 0x8000, type &#x3D; 0x4, flags &#x3D; 0x1&#125;, &#123;pbase &#x3D; 0x12f000, vbase &#x3D; 0x12f000, len &#x3D; 0x56000, type &#x3D; 0x4,</span><br><span class="line">    flags &#x3D; 0x3&#125;, &#123;pbase &#x3D; 0x12f000, vbase &#x3D; 0x12f000, len &#x3D; 0x0, type &#x3D; 0x4, flags &#x3D; 0x3&#125;, &#123;pbase &#x3D; 0x185000, vbase &#x3D; 0x185000,</span><br><span class="line">    len &#x3D; 0x1d, type &#x3D; 0x10, flags &#x3D; 0x21&#125;, &#123;pbase &#x3D; 0x18501d, vbase &#x3D; 0x18501d, len &#x3D; 0x7e5afe3, type &#x3D; 0x1, flags &#x3D; 0x3&#125;, &#123;</span><br><span class="line">    pbase &#x3D; 0x7fe0000, vbase &#x3D; 0x7fe0000, len &#x3D; 0x20000, type &#x3D; 0x2, flags &#x3D; 0x21&#125;, &#123;pbase &#x3D; 0xfffc0000, vbase &#x3D; 0xfffc0000,</span><br><span class="line">    len &#x3D; 0x40000, type &#x3D; 0x2, flags &#x3D; 0x21&#125;&#125;</span><br><span class="line">	*&#x2F;</span><br><span class="line">	if (unlikely(!bstack))</span><br><span class="line">		UK_CRASH(&quot;Boot stack alloc failed\n&quot;);</span><br><span class="line"></span><br><span class="line">	bstack &#x3D; (void *)((__uptr)bstack + __STACK_SIZE);</span><br><span class="line"></span><br><span class="line">	&#x2F;* Initialize memory *&#x2F; &#x2F;* 保证 bi-&gt;mrds 中的数据全部都在 bpt_unmap_mrd 的映射范围内。*&#x2F;</span><br><span class="line">	rc &#x3D; ukplat_mem_init();</span><br><span class="line">	if (unlikely(rc))</span><br><span class="line">		UK_CRASH(&quot;Mem init failed: %d\n&quot;, rc);</span><br><span class="line"></span><br><span class="line">	&#x2F;* Print boot information *&#x2F;</span><br><span class="line">	ukplat_bootinfo_print();</span><br><span class="line"></span><br><span class="line">#if defined(CONFIG_HAVE_SMP) &amp;&amp; defined(CONFIG_UKPLAT_ACPI)</span><br><span class="line">	rc &#x3D; acpi_init();</span><br><span class="line">	if (likely(rc &#x3D;&#x3D; 0)) &#123;</span><br><span class="line">		rc &#x3D; lcpu_mp_init(CONFIG_UKPLAT_LCPU_RUN_IRQ,</span><br><span class="line">				  CONFIG_UKPLAT_LCPU_WAKEUP_IRQ,</span><br><span class="line">				  NULL);</span><br><span class="line">		if (unlikely(rc))</span><br><span class="line">			uk_pr_err(&quot;SMP init failed: %d\n&quot;, rc);</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		uk_pr_err(&quot;ACPI init failed: %d\n&quot;, rc);</span><br><span class="line">	&#125;</span><br><span class="line">#endif &#x2F;* CONFIG_HAVE_SMP &amp;&amp; CONFIG_UKPLAT_ACPI *&#x2F;</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_HAVE_SYSCALL</span><br><span class="line">	_init_syscall();</span><br><span class="line">#endif &#x2F;* CONFIG_HAVE_SYSCALL *&#x2F;</span><br><span class="line"></span><br><span class="line">#if CONFIG_HAVE_X86PKU</span><br><span class="line">	_check_ospke();</span><br><span class="line">#endif &#x2F;* CONFIG_HAVE_X86PKU *&#x2F;</span><br><span class="line"></span><br><span class="line">	&#x2F;* Switch away from the bootstrap stack *&#x2F;</span><br><span class="line">	uk_pr_info(&quot;Switch from bootstrap stack to stack @%p\n&quot;, bstack);</span><br><span class="line">	&#x2F;*更换栈为 bstack，并执行 _ukplat_entry2。*&#x2F;</span><br><span class="line">	lcpu_arch_jump_to(bstack, _ukplat_entry2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static void __noreturn _ukplat_entry2(void)</span><br><span class="line">&#123;</span><br><span class="line">	&#x2F;* It&#39;s not possible to unwind past this function, because the stack</span><br><span class="line">	 * pointer was overwritten in lcpu_arch_jump_to. Therefore, mark the</span><br><span class="line">	 * previous instruction pointer as undefined, so that debuggers or</span><br><span class="line">	 * profilers stop unwinding here.</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	ukarch_cfi_unwind_end();</span><br><span class="line"></span><br><span class="line">	ukplat_entry_argp(NULL, cmdline, cmdline_len);</span><br><span class="line"></span><br><span class="line">	ukplat_lcpu_halt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>_ukplat_entry2 转到 ukplat_entry_argp 运行。</p>
<h3 id="ukplat-entry-argp-和-ukplat-entry"><a href="#ukplat-entry-argp-和-ukplat-entry" class="headerlink" title="ukplat_entry_argp 和 ukplat_entry"></a>ukplat_entry_argp 和 ukplat_entry</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;* defined in &lt;uk&#x2F;plat.h&gt; *&#x2F;</span><br><span class="line">void ukplat_entry_argp(char *arg0, char *argb, __sz argb_len)</span><br><span class="line">&#123;</span><br><span class="line">	static char *argv[CONFIG_LIBUKBOOT_MAXNBARGS];</span><br><span class="line">	int argc &#x3D; 0;</span><br><span class="line"></span><br><span class="line">	if (arg0) &#123;</span><br><span class="line">		argv[0] &#x3D; arg0;</span><br><span class="line">		argc +&#x3D; 1;</span><br><span class="line">	&#125;</span><br><span class="line">	if (argb &amp;&amp; argb_len) &#123;</span><br><span class="line">		argc +&#x3D; uk_argnparse(argb, argb_len, arg0 ? &amp;argv[1] : &amp;argv[0],</span><br><span class="line">				     arg0 ? (CONFIG_LIBUKBOOT_MAXNBARGS - 1)</span><br><span class="line">					  : CONFIG_LIBUKBOOT_MAXNBARGS);</span><br><span class="line">	&#125;</span><br><span class="line">	ukplat_entry(argc, argv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>转到 ukplat_entry 运行。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void ukplat_entry(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">#if CONFIG_LIBPOSIX_ENVIRON</span><br><span class="line">	char **envp;</span><br><span class="line">#endif &#x2F;* CONFIG_LIBPOSIX_ENVIRON *&#x2F;</span><br><span class="line">	int rc &#x3D; 0;</span><br><span class="line">#if CONFIG_LIBUKALLOC</span><br><span class="line">	struct uk_alloc *a &#x3D; NULL;</span><br><span class="line">#endif</span><br><span class="line">#if !CONFIG_LIBUKBOOT_NOALLOC</span><br><span class="line">	void *tls &#x3D; NULL;</span><br><span class="line">#endif</span><br><span class="line">#if CONFIG_LIBUKSCHED</span><br><span class="line">	struct uk_sched *s &#x3D; NULL;</span><br><span class="line">#endif</span><br><span class="line">	uk_ctor_func_t *ctorfn;</span><br><span class="line">	uk_init_func_t *initfn;</span><br><span class="line">	int i;</span><br><span class="line"></span><br><span class="line">	uk_pr_info(&quot;Unikraft constructor table at %p - %p\n&quot;,</span><br><span class="line">		   &amp;uk_ctortab_start[0], &amp;uk_ctortab_end);</span><br><span class="line">	</span><br><span class="line">	uk_ctortab_foreach(ctorfn, uk_ctortab_start, uk_ctortab_end) &#123;</span><br><span class="line">		UK_ASSERT(*ctorfn);</span><br><span class="line">		uk_pr_debug(&quot;Call constructor: %p())...\n&quot;, *ctorfn);</span><br><span class="line">		(*ctorfn)();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	......</span><br><span class="line"></span><br><span class="line">#if !CONFIG_LIBUKBOOT_NOALLOC</span><br><span class="line">	uk_pr_info(&quot;Initialize memory allocator...\n&quot;);</span><br><span class="line">	&#x2F;* 初始化内存分配器。并将 bi-&gt;mrds 中的内存区域加入到内存分配中管理。*&#x2F;</span><br><span class="line">	a &#x3D; heap_init();</span><br><span class="line">	if (unlikely(!a))</span><br><span class="line">		UK_CRASH(&quot;Failed to initialize memory allocator\n&quot;);</span><br><span class="line">	else &#123;</span><br><span class="line">		&#x2F;* 将 a 设置为默认内存分配器。*&#x2F;</span><br><span class="line">		rc &#x3D; ukplat_memallocator_set(a);</span><br><span class="line">		if (unlikely(rc !&#x3D; 0))</span><br><span class="line">			UK_CRASH(&quot;Could not set the platform memory allocator\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;* Allocate a TLS for this execution context *&#x2F;</span><br><span class="line">	tls &#x3D; uk_memalign(a,</span><br><span class="line">			  ukarch_tls_area_align(),</span><br><span class="line">			  ukarch_tls_area_size());</span><br><span class="line">	if (!tls)</span><br><span class="line">		UK_CRASH(&quot;Failed to allocate and initialize TLS\n&quot;);</span><br><span class="line"></span><br><span class="line">	&#x2F;* Copy from TLS master template *&#x2F;</span><br><span class="line">	ukarch_tls_area_init(tls);</span><br><span class="line">	&#x2F;* Activate TLS *&#x2F;</span><br><span class="line">	ukplat_tlsp_set(ukarch_tls_tlsp(tls));</span><br><span class="line">#endif &#x2F;* !CONFIG_LIBUKBOOT_NOALLOC *&#x2F;</span><br><span class="line"></span><br><span class="line">#if CONFIG_LIBUKALLOC</span><br><span class="line">	uk_pr_info(&quot;Initialize IRQ subsystem...\n&quot;);</span><br><span class="line">	&#x2F;* 关闭 IRQ。*&#x2F;</span><br><span class="line">	rc &#x3D; ukplat_irq_init(a);</span><br><span class="line">	if (unlikely(rc !&#x3D; 0))</span><br><span class="line">		UK_CRASH(&quot;Could not initialize the platform IRQ subsystem\n&quot;);</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">	&#x2F;* On most platforms the timer depend on an initialized IRQ subsystem *&#x2F;</span><br><span class="line">	uk_pr_info(&quot;Initialize platform time...\n&quot;);</span><br><span class="line">	ukplat_time_init();</span><br><span class="line"></span><br><span class="line">#if !CONFIG_LIBUKBOOT_NOSCHED</span><br><span class="line">	uk_pr_info(&quot;Initialize scheduling...\n&quot;);</span><br><span class="line">#if CONFIG_LIBUKBOOT_INITSCHEDCOOP</span><br><span class="line">	s &#x3D; uk_schedcoop_create(a);&#x2F;*创建 idle 线程。*&#x2F;</span><br><span class="line">#endif</span><br><span class="line">	if (unlikely(!s))</span><br><span class="line">		UK_CRASH(&quot;Failed to initialize scheduling\n&quot;);</span><br><span class="line">	uk_sched_start(s); &#x2F;* 创建 init 线程。*&#x2F;</span><br><span class="line">#endif &#x2F;* !CONFIG_LIBUKBOOT_NOSCHED *&#x2F;</span><br><span class="line"></span><br><span class="line">	&#x2F;* Enable interrupts before starting the application *&#x2F;</span><br><span class="line">	ukplat_lcpu_enable_irq();</span><br><span class="line"></span><br><span class="line">	&#x2F;**</span><br><span class="line">	 * Run init table</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	&#x2F;** init.h 中定义了相关宏。</span><br><span class="line">	 * uk_initcall_class_prio(uk_bus_lib_init, UK_BUS_INIT_CLASS, UK_BUS_INIT_PRIO);</span><br><span class="line">	*&#x2F;</span><br><span class="line">	uk_pr_info(&quot;Init Table @ %p - %p\n&quot;,</span><br><span class="line">		   &amp;uk_inittab_start[0], &amp;uk_inittab_end);</span><br><span class="line">	uk_inittab_foreach(initfn, uk_inittab_start, uk_inittab_end) &#123;</span><br><span class="line">		UK_ASSERT(*initfn);</span><br><span class="line">		uk_pr_debug(&quot;Call init function: %p()...\n&quot;, *initfn);</span><br><span class="line">		rc &#x3D; (*initfn)();</span><br><span class="line">		if (rc &lt; 0) &#123;</span><br><span class="line">			uk_pr_err(&quot;Init function at %p returned error %d\n&quot;,</span><br><span class="line">				  *initfn, rc);</span><br><span class="line">			rc &#x3D; UKPLAT_CRASH;</span><br><span class="line">			goto exit;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_LIBUKSP</span><br><span class="line">	uk_stack_chk_guard_setup();</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">	print_banner(stdout);</span><br><span class="line">	fflush(stdout);</span><br><span class="line"></span><br><span class="line">	&#x2F;*</span><br><span class="line">	 * Application</span><br><span class="line">	 *</span><br><span class="line">	 * We are calling the application constructors right before calling</span><br><span class="line">	 * the application&#39;s main(). All of our Unikraft systems, VFS,</span><br><span class="line">	 * networking stack is initialized at this point. This way we closely</span><br><span class="line">	 * mimic what a regular user application (e.g., BSD, Linux) would expect</span><br><span class="line">	 * from its OS being initialized.</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	uk_pr_info(&quot;Pre-init table at %p - %p\n&quot;,</span><br><span class="line">		   &amp;__preinit_array_start[0], &amp;__preinit_array_end);</span><br><span class="line">	uk_ctortab_foreach(ctorfn,</span><br><span class="line">			   __preinit_array_start, __preinit_array_end) &#123;</span><br><span class="line">		if (!*ctorfn)</span><br><span class="line">			continue;</span><br><span class="line"></span><br><span class="line">		uk_pr_debug(&quot;Call pre-init constructor: %p()...\n&quot;, *ctorfn);</span><br><span class="line">		(*ctorfn)();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	uk_pr_info(&quot;Constructor table at %p - %p\n&quot;,</span><br><span class="line">		   &amp;__init_array_start[0], &amp;__init_array_end);</span><br><span class="line">	uk_ctortab_foreach(ctorfn, __init_array_start, __init_array_end) &#123;</span><br><span class="line">		if (!*ctorfn)</span><br><span class="line">			continue;</span><br><span class="line"></span><br><span class="line">		uk_pr_debug(&quot;Call constructor: %p()...\n&quot;, *ctorfn);</span><br><span class="line">		(*ctorfn)();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">#if CONFIG_LIBPOSIX_ENVIRON</span><br><span class="line">	envp &#x3D; environ;</span><br><span class="line">	if (envp) &#123;</span><br><span class="line">		uk_pr_info(&quot;Environment variables:\n&quot;);</span><br><span class="line">		while (*envp) &#123;</span><br><span class="line">			uk_pr_info(&quot;\t%s\n&quot;, *envp);</span><br><span class="line">			envp++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">#endif &#x2F;* CONFIG_LIBPOSIX_ENVIRON *&#x2F;</span><br><span class="line"></span><br><span class="line">	uk_pr_info(&quot;Calling main(%d, [&quot;, argc);</span><br><span class="line">	for (i &#x3D; 0; i &lt; argc; ++i) &#123;</span><br><span class="line">		uk_pr_info(&quot;&#39;%s&#39;&quot;, argv[i]);</span><br><span class="line">		if ((i + 1) &lt; argc)</span><br><span class="line">			uk_pr_info(&quot;, &quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	uk_pr_info(&quot;])\n&quot;);</span><br><span class="line">	&#x2F;* 执行自定义 main 函数。*&#x2F;</span><br><span class="line">	rc &#x3D; main(argc, argv);</span><br><span class="line">	uk_pr_info(&quot;main returned %d, halting system\n&quot;, rc);</span><br><span class="line">	rc &#x3D; (rc !&#x3D; 0) ? UKPLAT_CRASH : UKPLAT_HALT;</span><br><span class="line"></span><br><span class="line">exit:</span><br><span class="line">	ukplat_terminate(rc); &#x2F;* does not return *&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="uk-ctor"><a href="#uk-ctor" class="headerlink" title="uk_ctor"></a>uk_ctor</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;* 1、ctor 相关宏定义。*&#x2F;</span><br><span class="line">&#x2F;* unikraft&#x2F;plat&#x2F;common&#x2F;include&#x2F;uk&#x2F;plat&#x2F;common&#x2F;common.lds.h *&#x2F;</span><br><span class="line">#define CTORTAB_SECTION							\</span><br><span class="line">	. &#x3D; ALIGN(__PAGE_SIZE);						\</span><br><span class="line">	uk_ctortab_start &#x3D; .;						\</span><br><span class="line">	.uk_ctortab :							\</span><br><span class="line">	&#123;								\</span><br><span class="line">		KEEP(*(SORT_BY_NAME(.uk_ctortab[0-9])))			\</span><br><span class="line">	&#125;								\</span><br><span class="line">	uk_ctortab_end &#x3D; .;</span><br><span class="line">&#x2F;* include&#x2F;uk&#x2F;ctors.h*&#x2F;</span><br><span class="line">&#x2F;**</span><br><span class="line"> * Register a Unikraft constructor function that is</span><br><span class="line"> * called during bootstrap (uk_ctortab)</span><br><span class="line"> *</span><br><span class="line"> * @param fn</span><br><span class="line"> *   Constructor function to be called</span><br><span class="line"> * @param prio</span><br><span class="line"> *   Priority level (0 (earliest) to 9 (latest))</span><br><span class="line"> *   Use the UK_PRIO_AFTER() helper macro for computing priority dependencies.</span><br><span class="line"> *   Note: Any other value for level will be ignored</span><br><span class="line"> *&#x2F;</span><br><span class="line">#define __UK_CTORTAB(fn, prio)				\</span><br><span class="line">	static const uk_ctor_func_t			\</span><br><span class="line">	__used __section(&quot;.uk_ctortab&quot; #prio)		\</span><br><span class="line">	__uk_ctortab ## prio ## _ ## fn &#x3D; (fn)</span><br><span class="line"></span><br><span class="line">#define _UK_CTORTAB(fn, prio)				\</span><br><span class="line">	__UK_CTORTAB(fn, prio)</span><br><span class="line"></span><br><span class="line">#define UK_CTOR_PRIO(fn, prio)				\</span><br><span class="line">	_UK_CTORTAB(fn, prio)</span><br><span class="line"></span><br><span class="line">#define UK_CTOR(fn) UK_CTOR_PRIO(fn, UK_PRIO_LATEST)</span><br><span class="line"></span><br><span class="line">&#x2F;* 2、libparam 相关 ctor 宏定义。*&#x2F;</span><br><span class="line">&#x2F;* unikraft&#x2F;lib&#x2F;uklibparam&#x2F;include&#x2F;uk&#x2F;libparam.h *&#x2F;</span><br><span class="line">&#x2F;* __LIBNAME__ 是在编译阶段传递的参数。具体可以查看 unikraft&#x2F;support&#x2F;build&#x2F;Makefile.rules 定义的 buildrule_cxx。*&#x2F;</span><br><span class="line">#define UK_LIBPARAM_PARAMSECTION_NAME       \</span><br><span class="line">	UK_LIBPARAM_CONCAT(UK_LIBPARAM_PARAMSECTION_NAMEPREFIX, __LIBNAME__)</span><br><span class="line">#define UK_LIBPARAM_LIBDESC_CTOR \</span><br><span class="line">	UK_LIBPARAM_CONCAT(UK_LIBPARAM_PARAMSECTION_NAME, _ctor)</span><br><span class="line">static void UK_LIBPARAM_LIBDESC_CTOR(void)</span><br><span class="line">&#123;</span><br><span class="line">	UK_LIBPARAM_LIBDESC.params_len &#x3D;</span><br><span class="line">		(__sz)((__uptr) &amp;UK_LIBPARAM_PARAMSECTION_ENDSYM -</span><br><span class="line">		       (__uptr) UK_LIBPARAM_PARAMSECTION_STARTSYM) &#x2F;</span><br><span class="line">		      sizeof(void *);</span><br><span class="line"></span><br><span class="line">	if (UK_LIBPARAM_LIBDESC.params_len &gt; 0) &#123;</span><br><span class="line">		UK_LIBPARAM_LIBDESC.params &#x3D; (struct uk_libparam_param **)</span><br><span class="line">					     UK_LIBPARAM_PARAMSECTION_STARTSYM;</span><br><span class="line">		_uk_libparam_libsec_register(&amp;UK_LIBPARAM_LIBDESC);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">UK_CTOR_PRIO(UK_LIBPARAM_LIBDESC_CTOR, 0); &#x2F;* 注册库。*&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;* 3、etcx 和 vsfcore 相关 ctor 定义。*&#x2F;</span><br><span class="line">&#x2F;* unikraft&#x2F;arch&#x2F;x86&#x2F;ectx.c *&#x2F;</span><br><span class="line">UK_CTOR_PRIO(_init_ectx_store, 0);</span><br><span class="line"></span><br><span class="line">&#x2F;* unikraft&#x2F;lib&#x2F;vfscore&#x2F;main.c *&#x2F;</span><br><span class="line">UK_CTOR_PRIO(vfscore_init, 1);</span><br><span class="line"></span><br><span class="line">&#x2F;* 4、 PCI 相关 ctor 定义。*&#x2F;</span><br><span class="line">&#x2F;* unikraft&#x2F;plat&#x2F;common&#x2F;include&#x2F;pci&#x2F;pci_bus.h *&#x2F;</span><br><span class="line">#define PCI_REGISTER_DRIVER(b)                  \</span><br><span class="line">	_PCI_REGISTER_DRIVER(__LIBNAME__, b)</span><br><span class="line">#define PCI_REGISTER_CTOR(ctor)				\</span><br><span class="line">	UK_CTOR_PRIO(ctor, UK_PRIO_AFTER(UK_BUS_REGISTER_PRIO))</span><br><span class="line">#define _PCI_REGISTER_DRIVER(libname, b)				\</span><br><span class="line">	static void						\</span><br><span class="line">	_PCI_REGFNNAME(libname, _pci_register_driver)(void)		\</span><br><span class="line">	&#123;								\</span><br><span class="line">		_pci_register_driver((b));				\</span><br><span class="line">	&#125;								\</span><br><span class="line">	PCI_REGISTER_CTOR(_PCI_REGFNNAME(libname, _pci_register_driver))</span><br><span class="line">&#x2F;* unikraft&#x2F;plat&#x2F;drivers&#x2F;virtio&#x2F;virtio_pci.c *&#x2F;</span><br><span class="line">PCI_REGISTER_DRIVER(&amp;virtio_pci_drv);</span><br><span class="line"></span><br><span class="line">&#x2F;* 5、 总线相关 ctor 定义。*&#x2F;</span><br><span class="line">&#x2F;* unikraft&#x2F;lib&#x2F;ukbus&#x2F;include&#x2F;uk&#x2F;bus.h *&#x2F;</span><br><span class="line">#define UK_BUS_REGISTER(b) \</span><br><span class="line">	_UK_BUS_REGISTER(__LIBNAME__, b, 2)</span><br><span class="line">#define _UK_BUS_REGISTER_CTOR(CTOR, prio)  \</span><br><span class="line">	UK_CTOR_PRIO(CTOR, prio)</span><br><span class="line"></span><br><span class="line">#define _UK_BUS_REGISTER(libname, b, prio)			\</span><br><span class="line">	static void						\</span><br><span class="line">	_UK_BUS_REGFNNAME(libname, _uk_bus_register)(void)	\</span><br><span class="line">	&#123;							\</span><br><span class="line">		_uk_bus_register((b));				\</span><br><span class="line">	&#125;							\</span><br><span class="line">	_UK_BUS_REGISTER_CTOR(_UK_BUS_REGFNNAME(libname, _uk_bus_register), prio)</span><br><span class="line"></span><br><span class="line">&#x2F;* unikraft&#x2F;plat&#x2F;common&#x2F;pci_bus.c *&#x2F;</span><br><span class="line">UK_BUS_REGISTER(&amp;ph.b);</span><br><span class="line">&#x2F;* unikraft&#x2F;plat&#x2F;drivers&#x2F;tap&#x2F;tap.c *&#x2F;</span><br><span class="line">UK_BUS_REGISTER(&amp;tap_bus);</span><br><span class="line">&#x2F;* unikraft&#x2F;plat&#x2F;drivers&#x2F;virtio&#x2F;virtio_bus.c *&#x2F;</span><br><span class="line">UK_BUS_REGISTER(&amp;virtio_bus);</span><br><span class="line"></span><br><span class="line">&#x2F;* unikraft&#x2F;plat&#x2F;drivers&#x2F;include&#x2F;virtio&#x2F;virtio_bus.h *&#x2F;</span><br><span class="line">#define VIRTIO_BUS_REGISTER_DRIVER(b)	\</span><br><span class="line">	_VIRTIO_BUS_REGISTER_DRIVER(__LIBNAME__, b)</span><br><span class="line">#define _VIRTIO_REGISTER_CTOR(ctor)	\</span><br><span class="line">	UK_CTOR_PRIO(ctor, UK_PRIO_AFTER(UK_BUS_REGISTER_PRIO))</span><br><span class="line">#define _VIRTIO_BUS_REGISTER_DRIVER(libname, b)				\</span><br><span class="line">	static void							\</span><br><span class="line">	_VIRTIO_BUS_REGFNAME(libname, _virtio_register_driver)(void)	\</span><br><span class="line">	&#123;								\</span><br><span class="line">		_virtio_bus_register_driver((b));			\</span><br><span class="line">	&#125;								\</span><br><span class="line">	_VIRTIO_REGISTER_CTOR(						\</span><br><span class="line">		_VIRTIO_BUS_REGFNAME(					\</span><br><span class="line">		libname, _virtio_register_driver))</span><br><span class="line">&#x2F;* unikraft&#x2F;plat&#x2F;drivers&#x2F;virtio&#x2F;virtio_9p.c *&#x2F;</span><br><span class="line">VIRTIO_BUS_REGISTER_DRIVER(&amp;v9p_drv);</span><br><span class="line">&#x2F;* unikraft&#x2F;plat&#x2F;drivers&#x2F;virtio&#x2F;virtio_blk.c *&#x2F;</span><br><span class="line">VIRTIO_BUS_REGISTER_DRIVER(&amp;vblk_drv);</span><br><span class="line">&#x2F;* unikraft&#x2F;plat&#x2F;drivers&#x2F;virtio&#x2F;virtio_net.c *&#x2F;</span><br><span class="line">VIRTIO_BUS_REGISTER_DRIVER(&amp;vnet_drv);</span><br></pre></td></tr></table></figure>

<h4 id="memory"><a href="#memory" class="headerlink" title="memory"></a>memory</h4><h4 id="tls"><a href="#tls" class="headerlink" title="tls"></a>tls</h4><h4 id="sched"><a href="#sched" class="headerlink" title="sched"></a>sched</h4><h1 id="Unikraft-linuxu-64位启动流程"><a href="#Unikraft-linuxu-64位启动流程" class="headerlink" title="Unikraft linuxu 64位启动流程"></a>Unikraft linuxu 64位启动流程</h1><h2 id="寻找入口函数-1"><a href="#寻找入口函数-1" class="headerlink" title="寻找入口函数"></a>寻找入口函数</h2><p>方法 1：阅读 unikraft/plat/linuxu/Linker.uk：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LINUXU_LDFLAGS-y +&#x3D; -Wl,-e,_liblinuxuplat_start</span><br></pre></td></tr></table></figure>

<p>从这里可以看出，当入口函数为 _liblinuxuplat_start。</p>
<p>方法 2：阅读 elf 文件。<br>以 helloworld 为例，使用以下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">readelf -a build&#x2F;helloworld_linuxu-x86_64.dbg</span><br></pre></td></tr></table></figure>
<p>查看 Entry point address 选项：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Entry point address:               0x401090</span><br></pre></td></tr></table></figure>
<p>可知入口地址为 0x401090。再进行反汇编：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">objdump -ld -C -S build&#x2F;helloworld_linuxu-x86_64.dbg &gt; helloworld.txt</span><br></pre></td></tr></table></figure>
<p>查看 helloworld.txt 文件，并找到地址为 0x401090 的函数：_liblinuxuplat_start。</p>
<h2 id="liblinuxuplat-start"><a href="#liblinuxuplat-start" class="headerlink" title="_liblinuxuplat_start"></a>_liblinuxuplat_start</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.global _liblinuxuplat_start</span><br><span class="line">_liblinuxuplat_start:</span><br><span class="line">	xorl %ebp, %ebp		# mark the outmost frame (clear the frame pointer)</span><br><span class="line"></span><br><span class="line">	popq %rdi		# argc as first argument</span><br><span class="line">	movq %rsp, %rsi		# move argv to rsi, the second parameter in x86_64 abi</span><br><span class="line"></span><br><span class="line">	# ignore environ for now</span><br><span class="line"></span><br><span class="line">	andq $~15, %rsp		# align stack to 16-byte boundary</span><br><span class="line"></span><br><span class="line">	# Run _liblinuxuplat_entry(argc, argv)</span><br><span class="line">	callq *_liblinuxuplat_entry@GOTPCREL(%rip)</span><br><span class="line"></span><br><span class="line">	# Protection</span><br><span class="line">_liblinuxuplat_start_err:</span><br><span class="line">	jmp *_liblinuxuplat_start_err(%rip)</span><br></pre></td></tr></table></figure>
<p>转到 _liblinuxuplat_entry 执行。</p>
<h2 id="liblinuxuplat-entry"><a href="#liblinuxuplat-entry" class="headerlink" title="_liblinuxuplat_entry"></a>_liblinuxuplat_entry</h2><p>由于 linuxu 是在 linux 用户态执行，所以不用像 qemu 启动那样复杂，不用设置启动协议，设置页表等功能，可以直接使用原来内核的相关功能。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void _liblinuxuplat_entry(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">	&#x2F;*</span><br><span class="line">	 * Initialize platform console</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	_liblinuxuplat_init_console();</span><br><span class="line"></span><br><span class="line">	__linuxu_plat_heap_init();</span><br><span class="line"></span><br><span class="line">	__linuxu_plat_initrd_init();</span><br><span class="line"></span><br><span class="line">	&#x2F;*</span><br><span class="line">	 * Enter Unikraft</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	ukplat_entry(argc, argv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ukplat_entry 过程与 上面一致。</p>
<p>简单分析 __linuxu_plat_heap_init</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define MB2B		(1024 * 1024)</span><br><span class="line">static __u32 heap_size &#x3D; CONFIG_LINUXU_DEFAULT_HEAPMB;</span><br><span class="line">static void __linuxu_plat_heap_init(void)</span><br><span class="line">&#123;</span><br><span class="line">	void *pret;</span><br><span class="line">	__u32 len;</span><br><span class="line">	int rc;</span><br><span class="line"></span><br><span class="line">	len &#x3D; heap_size * MB2B;</span><br><span class="line">	uk_pr_info(&quot;Allocate memory for heap (%u MiB)\n&quot;, heap_size);</span><br><span class="line"></span><br><span class="line">	&#x2F;**</span><br><span class="line">	 * Allocate heap memory</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	if (len &gt; 0) &#123;</span><br><span class="line">		pret &#x3D; sys_mapmem(NULL, len);</span><br><span class="line">		if (PTRISERR(pret)) &#123;</span><br><span class="line">			rc &#x3D; PTR2ERR(pret);</span><br><span class="line">			uk_pr_err(&quot;Failed to allocate memory for heap: %d\n&quot;,</span><br><span class="line">				  rc);</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			&#x2F;* 将新分配的内存加入到 bi-&gt;mrds *&#x2F;</span><br><span class="line">			rc &#x3D; ukplat_memregion_list_insert(</span><br><span class="line">				&amp;ukplat_bootinfo_get()-&gt;mrds,</span><br><span class="line">				&amp;(struct ukplat_memregion_desc)&#123;</span><br><span class="line">					.vbase &#x3D; (__vaddr_t)pret,</span><br><span class="line">					.pbase &#x3D; (__paddr_t)pret,</span><br><span class="line">					.len   &#x3D; len,</span><br><span class="line">					.type  &#x3D; UKPLAT_MEMRT_FREE,</span><br><span class="line">					.flags &#x3D; UKPLAT_MEMRF_READ |</span><br><span class="line">						 UKPLAT_MEMRF_WRITE |</span><br><span class="line">						 UKPLAT_MEMRF_MAP,</span><br><span class="line">				&#125;);</span><br><span class="line">			if (unlikely(rc &lt; 0))</span><br><span class="line">				uk_pr_err(&quot;Failed to add heap memory region descriptor.&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void __linuxu_plat_initrd_init(void)</span><br><span class="line">&#123;</span><br><span class="line">	void *pret;</span><br><span class="line">	__u32 len;</span><br><span class="line">	int rc;</span><br><span class="line">	struct k_stat file_info;</span><br><span class="line"></span><br><span class="line">	if (!initrd) &#123;</span><br><span class="line">		uk_pr_debug(&quot;No initrd present.\n&quot;);</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		uk_pr_debug(&quot;Mapping in initrd file: %s\n&quot;, initrd);</span><br><span class="line">		int initrd_fd &#x3D; sys_open(initrd, K_O_RDONLY, 0);</span><br><span class="line"></span><br><span class="line">		if (initrd_fd &lt; 0)</span><br><span class="line">			uk_pr_crit(&quot;Failed to open %s for initrd\n&quot;, initrd);</span><br><span class="line"></span><br><span class="line">		&#x2F;**</span><br><span class="line">		 * Find initrd file size</span><br><span class="line">		 *&#x2F;</span><br><span class="line">		if (sys_fstat(initrd_fd, &amp;file_info) &lt; 0) &#123;</span><br><span class="line">			uk_pr_crit(&quot;sys_fstat failed for initrd file\n&quot;);</span><br><span class="line">			sys_close(initrd_fd);</span><br><span class="line">		&#125;</span><br><span class="line">		len &#x3D; file_info.st_size;</span><br><span class="line">		&#x2F;**</span><br><span class="line">		 * Allocate initrd memory</span><br><span class="line">		 *&#x2F;</span><br><span class="line">		if (len &gt; 0) &#123;</span><br><span class="line">			pret &#x3D; sys_mmap(NULL, len,</span><br><span class="line">					PROT_READ | PROT_WRITE | PROT_EXEC,</span><br><span class="line">					MAP_PRIVATE, initrd_fd, 0);</span><br><span class="line">			if (PTRISERR(pret)) &#123;</span><br><span class="line">				rc &#x3D; PTR2ERR(pret);</span><br><span class="line">				uk_pr_crit(&quot;Failed to memory-map initrd: %d\n&quot;,</span><br><span class="line">					   rc);</span><br><span class="line">				sys_close(initrd_fd);</span><br><span class="line">			&#125;</span><br><span class="line">			&#x2F;* 将为 initrd 分配的内存加入到 bi-&gt;mrds *&#x2F;</span><br><span class="line">			rc &#x3D; ukplat_memregion_list_insert(</span><br><span class="line">				&amp;ukplat_bootinfo_get()-&gt;mrds,</span><br><span class="line">				&amp;(struct ukplat_memregion_desc)&#123;</span><br><span class="line">					.vbase &#x3D; (__vaddr_t)pret,</span><br><span class="line">					.pbase &#x3D; (__paddr_t)pret,</span><br><span class="line">					.len   &#x3D; len,</span><br><span class="line">					.type  &#x3D; UKPLAT_MEMRT_INITRD,</span><br><span class="line">					.flags &#x3D; UKPLAT_MEMRF_READ |</span><br><span class="line">						 UKPLAT_MEMRF_WRITE |</span><br><span class="line">						 UKPLAT_MEMRF_MAP,</span><br><span class="line">				&#125;);</span><br><span class="line">			if (unlikely(rc &lt; 0))</span><br><span class="line">				uk_pr_err(&quot;Failed to add initrd memory region descriptor.&quot;);</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			uk_pr_info(&quot;Ignoring empty initrd file.\n&quot;);</span><br><span class="line">			sys_close(initrd_fd);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>unikernel</tag>
      </tags>
  </entry>
  <entry>
    <title>virtio介绍</title>
    <url>/p/9e9d1546.html</url>
    <content><![CDATA[<p>本部分内容摘自《Viitual I/O Device(VIRTIO) Version 1.2》</p>
<span id="more"></span>

<p>本系列文档描述了“virtio”系列设备的规格。这些设备存在于虚拟环境中，但从设计上来说，对于虚拟机中的客户机来说，它们看起来就像物理设备，本文档也将它们视为物理设备。 这种相似性允许客户机使用标准驱动程序和发现机制。</p>
<p>virtio 和此规范的目的是虚拟环境和客户机应该为虚拟设备提供<font color="#FF0000">直接（Straightforward）、高效（Efficient）、标准（Standard）和可扩展（Extensible）</font>的机制，而不是针对每个环境或每个操作系统的精品机制。</p>
<ul>
<li>直接：Virtio 设备使用正常的中断和 DMA 总线机制，任何设备驱动程序作者都应该熟悉这些机制。没有奇特的翻页或 COW 机制：它只是一个普通的设备。</li>
<li>高效：Virtio 设备由用于输入和输出的描述符环组成，这些描述符的布局整齐，以避免驱动程序和设备写入相同缓存行时产生缓存影响。</li>
<li>标准：除了支持设备所连接的总线之外，Virtio 对其运行环境不做任何假设。在本规范中，virtio 设备是通过 MMIO、通道 I/O 和 PCI 总线传输实现的。</li>
<li>可扩展：Virtio 设备包含在设备设置期间由客户机操作系统确认的功能位。 这允许向前和向后兼容：设备提供它所知道的所有功能，并且驱动程序承认它理解并希望使用的功能。</li>
</ul>
<h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><p><font color="#FF0000">MUST, REQUIRED, SHALL</font> mean that the definition is an absolute requirement of the specification.</p>
<p><font color="#FF0000">MUST NOT, SHALL NOT</font> mean that the definition is an absolute prohibition of the specification.</p>
<p><font color="#FF0000">SHOULD, RECOMMENDED</font> mean that there may exist valid reasons in particular circumstances to ignore a particular item, but the full implications must be understood and carefully weighed before choosing a different course.</p>
<p><font color="#FF0000">SHOULD NOT, NOT RECOMMENDED</font> mean that there may exist valid reasons in particular circumstances when the particular behavior is acceptable or even useful, but the full implications should be understood and the case carefully weighed before implementing any behavior described with this label.</p>
<p><font color="#FF0000">MAY, OPTIONAL</font> mean that an item is truly optional.  One vendor may choose to include the item because a particular marketplace requires it or because the vendor feels that it enhances the product while another vendor may omit the same item. An implementation which does not include a particular option MUST be prepared to interoperate with another implementation which does include the option, though perhaps with reduced functionality. In the same vein an implementation which does include a particular option MUST be prepared to interoperate with another implementation which does not include the option (except, of course, for the feature the option provides.)</p>
<h3 id="旧版接口术语"><a href="#旧版接口术语" class="headerlink" title="旧版接口术语"></a>旧版接口术语</h3><p>本规范 1.0 版之前的规范草案定义了驱动程序和设备之间类似但不同的接口。由于这些已广泛部署，因此本规范包含 OPTIONAL 功能，以简化从这些早期草案接口的过渡。<br>具体来说，设备和驱动程序 MAY 支持：</p>
<ul>
<li>旧版接口（Legacy Interface）：是本规范早期草案（1.0 之前）指定的接口；</li>
<li>旧版设备（Legacy Device）：是在该规范发布之前实现的设备，并在主机端实现遗留接口；</li>
<li>旧版驱动（Legacy Driver）：是在该规范发布之前实现的驱动程序，并在客户机端实现遗留接口；</li>
</ul>
<p>旧版设备和旧版驱动程序不符合此规范。为了简化从这些早期草案接口的转换，设备 MAY 实现：</p>
<ul>
<li>过渡设备（Transitional Device）：支持符合此规范的驱动程序并允许旧驱动程序的设备。</li>
</ul>
<p>同样，驱动程序 MAY 实现：</p>
<ul>
<li>过渡驱动（Transitional Driver）：支持符合此规范的设备和传统设备的驱动程序。</li>
</ul>
<p>注意：旧接口不是必要的；即，除非需要向后兼容，否则不要实现它们！<br>不具有传统兼容性的设备或驱动程序分别称为非过渡设备和驱动程序。</p>
<h2 id="结构规范"><a href="#结构规范" class="headerlink" title="结构规范"></a>结构规范</h2>]]></content>
      <tags>
        <tag>virtio</tag>
      </tags>
  </entry>
  <entry>
    <title>virtio知识总结</title>
    <url>/p/3476b7a1.html</url>
    <content><![CDATA[<p>本部分内容摘自《Viitual I/O Device(VIRTIO) Version 1.2》</p>
<span id="more"></span>

<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><a href="#">Post not found: virtio介绍 virtio介绍</a>]]></content>
      <tags>
        <tag>virtio</tag>
      </tags>
  </entry>
  <entry>
    <title>SGX简介</title>
    <url>/p/640bec68.html</url>
    <content><![CDATA[<h2 id="1、什么是-SGX？"><a href="#1、什么是-SGX？" class="headerlink" title="1、什么是 SGX？"></a>1、什么是 SGX？</h2><h2 id="2、为什么要使用-SGX？"><a href="#2、为什么要使用-SGX？" class="headerlink" title="2、为什么要使用 SGX？"></a>2、为什么要使用 SGX？</h2><h2 id="3、SGX-基本原理"><a href="#3、SGX-基本原理" class="headerlink" title="3、SGX 基本原理"></a>3、SGX 基本原理</h2><h2 id="4、"><a href="#4、" class="headerlink" title="4、"></a>4、</h2>]]></content>
      <tags>
        <tag>SGX</tag>
      </tags>
  </entry>
</search>
